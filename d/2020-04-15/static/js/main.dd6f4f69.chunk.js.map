{"version":3,"sources":["../../node_modules/peerjs/dist sync","utils/storage.ts","components/ErrorFallback.tsx","utils/crypto.ts","utils/url.ts","utils/sleep.ts","network/peerUtils.ts","network/room.ts","capture/webcam.ts","components/SingleRoom.tsx","hooks/useVideoDevices.ts","hooks/useFaceImages.ts","components/SingleRoomEntrance.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","name","ErrorFallback","useState","waitSec","setWaitSec","useEffect","setTimeout","window","location","reload","secureRandomId","arrbuf","crypto","getRandomValues","Uint8Array","Array","from","map","b","toString","padStart","join","extractRoomIdFromLink","link","hash","URL","slice","URLSearchParams","get","sleep","ms","Promise","generatePeerJsId","roomId","peerId","getPeerIdFromPeerJsId","peerJsId","Number","split","getPeerIdFromConn","conn","peer","guessSeed","createMyPeer","index","updateNetworkStatus","type","Uint16Array","console","log","Peer","on","err","destroy","then","error","createRoom","receiveData","disposed","myPeer","lastBroadcastData","connMap","Map","addConn","set","live","markLive","value","isLive","hasConn","has","delConn","delete","getLivePeerJsIds","filter","k","forEachLiveConns","callback","values","forEach","createConnectionMap","showConnectedStatus","peerIds","connectPeer","connect","serialization","initConnection","send","data","peers","payload","isArray","startsWith","isValidPeerJsId","handlePayload","a","reInitMyPeer","initMyPeer","oldPeer","i","disconnectedId","Math","floor","random","every","broadcastData","dispose","captureImage","stream","track","ImageCapture","imageCapture","takePhoto","blob","createImageBitmap","srcImg","grabFrame","srcW","width","srcH","height","video","document","getElementById","style","display","srcObject","videoWidth","videoHeight","deviceId","constraints","navigator","mediaDevices","getUserMedia","getVideoTracks","canvas","ctx","getContext","dstW","dstH","ratio","max","min","x","y","drawImage","stop","toDataURL","getVideoDeviceInfoList","enumerateDevices","devices","list","kind","label","initialNickname","localStorage","getItem","SingleRoom","userId","nicknameRef","useRef","messageRef","searchParams","setRoomIdToUrl","setDeviceId","videoDevices","setDevices","deviceInfoList","useVideoDevices","getFaceInfo","useCallback","nickname","current","message","myImage","setMyImage","roomImages","setRoomImages","networkStatus","fatalError","setFatalError","_peerId","image","info","roomImage","received","Date","now","obsoleted","prev","found","next","item","checkObsoletedImage","twoMinAgo","changed","loop","timer","setInterval","clearTimeout","useFaceImages","className","JSON","stringify","defaultValue","href","readOnly","onChange","target","setItem","setStringItem","videoDevice","key","src","alt","placeholder","opacity","roomIdFromUrl","getRoomIdFromUrl","SingleRoomEntrance","setRoomId","linkText","setLinkText","onClick","disabled","ErrorBoundary","state","hasError","children","this","props","React","Component","App","Boolean","hostname","match","ReactDOM","render","StrictMode","serviceWorker","ready","registration","unregister","catch"],"mappings":"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","file":"static/js/main.dd6f4f69.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 22;","type StringItemName = \"nickname\" | \"TODO1\";\n\ntype JsonItemName = \"TODO2\" | \"TODO3\";\n\nexport const setStringItem = (name: StringItemName, value: string) => {\n  window.localStorage.setItem(name, value);\n};\n\nexport const getStringItem = (name: StringItemName) => {\n  return window.localStorage.getItem(name) || \"\";\n};\n\nexport const setJsonItem = (name: JsonItemName, value: unknown) => {\n  window.localStorage.setItem(name, JSON.stringify(value));\n};\n\nexport const getJsonItem = (name: JsonItemName): unknown | null => {\n  try {\n    return JSON.parse(window.localStorage.getItem(name) || \"\");\n  } catch (e) {\n    // ignore\n    return null;\n  }\n};\n\nexport const removeItem = (name: StringItemName | JsonItemName) => {\n  window.localStorage.removeItem(name);\n};\n","import React, { useEffect, useState } from \"react\";\n\nconst ErrorFallback: React.FC = () => {\n  const [waitSec, setWaitSec] = useState(60);\n\n  useEffect(() => {\n    if (waitSec > 0) {\n      setTimeout(() => {\n        setWaitSec(waitSec - 1);\n      }, 1000);\n    } else {\n      window.location.reload();\n    }\n  });\n\n  return (\n    <div>\n      <h1>Unrecoverable error occurred.</h1>\n      <p>Will auto reload in {waitSec} sec.</p>\n    </div>\n  );\n};\n\nexport default ErrorFallback;\n","export const sha256 = async (text: string) => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(text);\n  const buf = await window.crypto.subtle.digest(\"SHA-256\", data);\n  const arr = Array.from(new Uint8Array(buf));\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const secureRandomId = () => {\n  const arrbuf = window.crypto.getRandomValues(new Uint8Array(16));\n  const arr = Array.from(arrbuf);\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const rand4 = () => {\n  const rand = window.crypto.getRandomValues(new Uint16Array(1))[0];\n  return 1000 + (rand % 9000);\n};\n","export const extractRoomIdFromLink = (link: string) => {\n  try {\n    const hash = new URL(link).hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    return searchParams.get(\"roomId\");\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const getRoomIdFromUrl = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  return searchParams.get(\"roomId\");\n};\n\nexport const setRoomIdToUrl = (roomId: string) => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  searchParams.set(\"roomId\", roomId);\n  window.location.hash = searchParams.toString();\n};\n","export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","import Peer from \"peerjs\";\n\nexport const isValidPeerJsId = (\n  roomId: string,\n  peerJsId: unknown\n): peerJsId is string =>\n  typeof peerJsId === \"string\" && peerJsId.startsWith(`${roomId}_`);\n\nexport const generatePeerJsId = (roomId: string, peerId: number) =>\n  `${roomId}_${peerId}`;\n\nexport const getPeerIdFromPeerJsId = (peerJsId: string) =>\n  Number(peerJsId.split(\"_\")[1]);\n\nexport const getPeerIdFromConn = (conn: Peer.DataConnection) =>\n  getPeerIdFromPeerJsId(conn.peer);\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Peer.DataConnection;\n    live: boolean;\n  };\n  const map = new Map<string, Value>();\n  const addConn = (conn: Peer.DataConnection) => {\n    map.set(conn.peer, { conn, live: false });\n  };\n  const markLive = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.live = true;\n    }\n  };\n  const isLive = (peerJsId: string) => {\n    const value = map.get(peerJsId);\n    return value ? value.live : false;\n  };\n  const hasConn = (peerJsId: string) => map.has(peerJsId);\n  const delConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n    }\n  };\n  const getLivePeerJsIds = () =>\n    Array.from(map.keys()).filter((k) => map.get(k)?.live);\n  const forEachLiveConns = (callback: (conn: Peer.DataConnection) => void) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.live) {\n        callback(value.conn);\n      }\n    });\n  };\n  return {\n    addConn,\n    markLive,\n    isLive,\n    hasConn,\n    delConn,\n    getLivePeerJsIds,\n    forEachLiveConns,\n  };\n};\n","import Peer from \"peerjs\";\n\nimport { rand4 } from \"../utils/crypto\";\nimport { sleep } from \"../utils/sleep\";\nimport {\n  isValidPeerJsId,\n  generatePeerJsId,\n  getPeerIdFromPeerJsId,\n  getPeerIdFromConn,\n  createConnectionMap,\n} from \"./peerUtils\";\n\nconst SEED_PEERS = 5; // config\nconst guessSeed = (id: string) => getPeerIdFromPeerJsId(id) < SEED_PEERS;\n\nexport type NetworkStatus =\n  | { type: \"CONNECTING_SEED_PEERS\" }\n  | { type: \"NEW_CONNECTION\"; peerId: number }\n  | { type: \"INITIALIZING_PEER\"; index: number }\n  | { type: \"NETWORK_ERROR\" }\n  | { type: \"UNKNOWN_ERROR\" }\n  | { type: \"CONNECTED_PEERS\"; peerIds: number[] };\n\ntype UpdateNetworkStatus = (status: NetworkStatus) => void;\n\ntype ReceiveData = (peerId: number, data: unknown) => void;\n\nconst createMyPeer = (\n  index: number,\n  roomId: string,\n  updateNetworkStatus: UpdateNetworkStatus\n): Promise<Peer> => {\n  updateNetworkStatus({ type: \"INITIALIZING_PEER\", index });\n  const isSeed = index < SEED_PEERS;\n  const peerId = isSeed ? index : rand4();\n  const id = generatePeerJsId(roomId, peerId);\n  console.log(\"createMyPeer\", index, id);\n  const peer = new Peer(id);\n  return new Promise((resolve) => {\n    peer.on(\"open\", () => {\n      resolve(peer);\n    });\n    peer.on(\"error\", (err) => {\n      if (err.type === \"unavailable-id\") {\n        peer.destroy();\n        createMyPeer(index + 1, roomId, updateNetworkStatus).then(resolve);\n      } else if (err.type === \"peer-unavailable\") {\n        // ignore\n      } else if (err.type === \"network\") {\n        console.log(\"createMyPeer network error\", err);\n        updateNetworkStatus({ type: \"NETWORK_ERROR\" });\n      } else {\n        console.error(\"createMyPeer\", err.type, err);\n        updateNetworkStatus({ type: \"UNKNOWN_ERROR\" });\n      }\n    });\n  });\n};\n\nexport const createRoom = (\n  roomId: string,\n  updateNetworkStatus: UpdateNetworkStatus,\n  receiveData: ReceiveData\n) => {\n  let disposed = false;\n  let myPeer: Peer | null = null;\n  let lastBroadcastData: unknown | null = null;\n  const connMap = createConnectionMap();\n\n  const showConnectedStatus = () => {\n    const peerIds = connMap.getLivePeerJsIds().map(getPeerIdFromPeerJsId);\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIds });\n  };\n\n  const connectPeer = (id: string) => {\n    if (!myPeer) return;\n    if (myPeer.id === id) return;\n    if (connMap.hasConn(id)) return;\n    console.log(\"connectPeer\", id);\n    const conn = myPeer.connect(id, { serialization: \"json\" });\n    connMap.addConn(conn);\n    initConnection(conn);\n  };\n\n  const broadcastData = (data: unknown) => {\n    if (disposed) return;\n    lastBroadcastData = data;\n    const peers = connMap.getLivePeerJsIds();\n    connMap.forEachLiveConns((conn) => {\n      try {\n        conn.send({ data, peers });\n      } catch (e) {\n        console.error(\"broadcastData\", e);\n      }\n    });\n  };\n\n  const handlePayload = (conn: Peer.DataConnection, payload: unknown) => {\n    if (disposed) return;\n    try {\n      const peerId = getPeerIdFromConn(conn);\n      if (payload && typeof payload === \"object\") {\n        receiveData(peerId, (payload as { data: unknown }).data);\n        if (Array.isArray((payload as { peers: unknown }).peers)) {\n          (payload as { peers: unknown[] }).peers.forEach((peer) => {\n            if (isValidPeerJsId(roomId, peer)) {\n              connectPeer(peer);\n            }\n          });\n        }\n      }\n    } catch (e) {\n      console.error(\"handlePayload\", e);\n    }\n  };\n\n  const initConnection = (conn: Peer.DataConnection) => {\n    conn.on(\"open\", () => {\n      connMap.markLive(conn);\n      showConnectedStatus();\n      if (lastBroadcastData) {\n        conn.send({\n          data: lastBroadcastData,\n          peers: connMap.getLivePeerJsIds(),\n        });\n      }\n    });\n    conn.on(\"data\", (payload: unknown) => handlePayload(conn, payload));\n    conn.on(\"close\", async () => {\n      connMap.delConn(conn);\n      console.log(\"dataConnection closed\", conn);\n      showConnectedStatus();\n      if (guessSeed(conn.peer)) reInitMyPeer(conn.peer);\n    });\n  };\n\n  const initMyPeer = async () => {\n    if (disposed) return;\n    if (myPeer) return;\n    myPeer = await createMyPeer(0, roomId, updateNetworkStatus);\n    if (process.env.NODE_ENV !== \"production\") {\n      (window as any).myPeer = myPeer;\n    }\n    myPeer.on(\"connection\", (conn) => {\n      console.log(\"new connection received\", conn);\n      const peerId = getPeerIdFromConn(conn);\n      updateNetworkStatus({ type: \"NEW_CONNECTION\", peerId });\n      connMap.addConn(conn);\n      initConnection(conn);\n      connMap.markLive(conn);\n    });\n    myPeer.on(\"disconnected\", () => {\n      if (!myPeer) return;\n      const oldPeer = myPeer;\n      myPeer = null;\n      oldPeer.destroy();\n      setTimeout(initMyPeer, 60 * 1000);\n    });\n    myPeer.on(\"close\", () => {\n      myPeer = null;\n      setTimeout(initMyPeer, 60 * 1000);\n    });\n    updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n    for (let i = 0; i < SEED_PEERS; i += 1) {\n      const id = generatePeerJsId(roomId, i);\n      connectPeer(id);\n    }\n  };\n  initMyPeer();\n\n  const reInitMyPeer = async (disconnectedId: string) => {\n    if (!myPeer) return;\n    if (guessSeed(myPeer.id)) return;\n    const waitSec = 30 + Math.floor(Math.random() * 60);\n    console.log(\n      `Disconnected seed peer: ${getPeerIdFromPeerJsId(\n        disconnectedId\n      )}, reinit in ${waitSec}sec...`\n    );\n    await sleep(waitSec * 1000);\n    if (!myPeer) return;\n    if (guessSeed(myPeer.id)) return;\n    const existsAllSeeds = Array.from(Array(SEED_PEERS).keys()).every((i) => {\n      const id = generatePeerJsId(roomId, i);\n      return connMap.isLive(id);\n    });\n    if (existsAllSeeds) {\n      showConnectedStatus();\n      return;\n    }\n    const oldPeer = myPeer;\n    myPeer = null;\n    oldPeer.destroy();\n    initMyPeer();\n  };\n\n  const dispose = () => {\n    disposed = true;\n    if (myPeer) {\n      const oldPeer = myPeer;\n      myPeer = null;\n      oldPeer.destroy();\n    }\n  };\n\n  return {\n    broadcastData,\n    dispose,\n  };\n};\n","import { sleep } from \"../utils/sleep\";\n\nconst captureImage = async (stream: MediaStream, track: MediaStreamTrack) => {\n  if (typeof ImageCapture !== \"undefined\") {\n    const imageCapture = new ImageCapture(track);\n    await sleep(2000);\n    let srcImg;\n    try {\n      const blob = await imageCapture.takePhoto();\n      srcImg = await createImageBitmap(blob);\n    } catch (e) {\n      srcImg = await imageCapture.grabFrame();\n    }\n    const srcW = srcImg.width;\n    const srcH = srcImg.height;\n    return { srcImg, srcW, srcH };\n  }\n  const video = document.getElementById(\"internal-video\") as HTMLVideoElement;\n  video.style.display = \"block\";\n  video.srcObject = stream;\n  await sleep(2000);\n  const srcImg = video;\n  const srcW = video.videoWidth;\n  const srcH = video.videoHeight;\n  return { srcImg, srcW, srcH };\n};\n\nexport const takePhoto = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        video: { deviceId },\n      }\n    : { video: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const track = stream.getVideoTracks()[0];\n  const canvas = document.getElementById(\n    \"internal-canvas\"\n  ) as HTMLCanvasElement;\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const dstW = 72;\n  const dstH = 72;\n  canvas.width = dstW;\n  canvas.height = dstH;\n  const { srcImg, srcW, srcH } = await captureImage(stream, track);\n  const ratio = Math.max(dstW / srcW, dstH / srcH);\n  const width = Math.min(srcW, dstW / ratio);\n  const height = Math.min(srcH, dstH / ratio);\n  const x = (srcW - width) / 2;\n  const y = (srcH - height) / 2;\n  ctx.drawImage(srcImg, x, y, width, height, 0, 0, dstW, dstH);\n  track.stop();\n  return canvas.toDataURL(\"image/png\");\n};\n\nexport const getVideoDeviceInfoList = async () => {\n  type VideoDeviceInfo = {\n    label: string;\n    deviceId: string;\n  };\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const list: VideoDeviceInfo[] = devices\n      .filter(({ kind }) => kind === \"videoinput\")\n      .map(({ label, deviceId }) => ({ label, deviceId }));\n    return list;\n  } catch (e) {\n    // ignored\n    return [];\n  }\n};\n","import React, { useCallback, useEffect, useRef, useState } from \"react\";\n\nimport { setRoomIdToUrl } from \"../utils/url\";\nimport { setStringItem, getStringItem } from \"../utils/storage\";\nimport { useFaceImages } from \"../hooks/useFaceImages\";\nimport { useVideoDevices } from \"../hooks/useVideoDevices\";\nimport \"./SingleRoom.css\";\n\nconst BLANK_IMAGE =\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQI12NgYAAAAAMAASDVlMcAAAAASUVORK5CYII=\";\n\ntype Props = {\n  roomId: string;\n  userId: string;\n};\n\nconst initialNickname = getStringItem(\"nickname\");\n\nconst SingleRoom: React.FC<Props> = ({ roomId, userId }) => {\n  const nicknameRef = useRef(initialNickname);\n  const messageRef = useRef(\"\");\n  useEffect(() => {\n    setRoomIdToUrl(roomId);\n  }, [roomId]);\n\n  const [deviceId, setDeviceId] = useState<string>();\n  const videoDevices = useVideoDevices();\n\n  const getFaceInfo = useCallback(\n    () => ({\n      nickname: nicknameRef.current,\n      message: messageRef.current,\n    }),\n    []\n  );\n  const { myImage, roomImages, networkStatus } = useFaceImages(\n    roomId,\n    userId,\n    getFaceInfo,\n    deviceId\n  );\n\n  return (\n    <>\n      <div className=\"SingleRoom-status\">{JSON.stringify(networkStatus)}</div>\n      <div className=\"SingleRoom-room-info\">\n        <div>\n          Link to this room:\n          <input defaultValue={window.location.href} readOnly />\n          (Share this link with your colleagues)\n        </div>\n        <div>\n          Your Name:{\" \"}\n          <input\n            defaultValue={initialNickname}\n            onChange={(e) => {\n              nicknameRef.current = e.target.value;\n              setStringItem(\"nickname\", nicknameRef.current);\n            }}\n          />\n        </div>\n        <div>\n          Select Camera:{\" \"}\n          <select onChange={(e) => setDeviceId(e.target.value)}>\n            {videoDevices.map((videoDevice) => (\n              <option key={videoDevice.deviceId} value={videoDevice.deviceId}>\n                {videoDevice.label}\n              </option>\n            ))}\n          </select>\n        </div>\n      </div>\n      <div>\n        <div className=\"SingleRoom-card\">\n          <img\n            src={myImage || BLANK_IMAGE}\n            className=\"SingleRoom-photo\"\n            alt=\"myself\"\n          />\n          <div className=\"SingleRoom-name\">{nicknameRef.current}</div>\n          <div className=\"SingleRoom-mesg\">\n            <form>\n              <input\n                onChange={(e) => {\n                  messageRef.current = e.target.value;\n                }}\n                placeholder=\"Enter message.\"\n              />\n            </form>\n          </div>\n        </div>\n        {roomImages.map((item) => (\n          <div\n            key={item.userId}\n            className=\"SingleRoom-card\"\n            style={{ opacity: item.obsoleted ? 0.2 : 1 }}\n          >\n            <img src={item.image} className=\"SingleRoom-photo\" alt=\"friend\" />\n            <div className=\"SingleRoom-name\">{item.info.nickname}</div>\n            <div className=\"SingleRoom-mesg\">{item.info.message}</div>\n          </div>\n        ))}\n      </div>\n    </>\n  );\n};\n\nexport default SingleRoom;\n","import { useEffect, useState } from \"react\";\n\nimport { getVideoDeviceInfoList } from \"../capture/webcam\";\n\ntype DeviceInfoList = ReturnType<typeof getVideoDeviceInfoList> extends Promise<\n  infer T\n>\n  ? T\n  : never;\n\nexport const useVideoDevices = () => {\n  const [devices, setDevices] = useState<DeviceInfoList>([]);\n  useEffect(() => {\n    (async () => {\n      const deviceInfoList = await getVideoDeviceInfoList();\n      setDevices(deviceInfoList);\n    })();\n  }, []);\n  return devices;\n};\n","import { useEffect, useState } from \"react\";\n\nimport { createRoom, NetworkStatus } from \"../network/room\";\nimport { takePhoto } from \"../capture/webcam\";\n\ntype ImageUrl = string;\ntype FaceInfo = {\n  nickname: string;\n  message: string;\n};\ntype RoomImage = {\n  userId: string;\n  image: ImageUrl;\n  info: FaceInfo;\n  received: number; // in milliseconds\n  obsoleted: boolean;\n};\n\nconst isFaceInfo = (x: unknown): x is FaceInfo =>\n  x &&\n  typeof x === \"object\" &&\n  typeof (x as { nickname: unknown }).nickname === \"string\" &&\n  typeof (x as { message: unknown }).message === \"string\";\n\nexport const useFaceImages = (\n  roomId: string,\n  userId: string,\n  getFaceInfo: () => FaceInfo,\n  deviceId?: string\n) => {\n  const [myImage, setMyImage] = useState<ImageUrl>();\n  const [roomImages, setRoomImages] = useState<RoomImage[]>([]);\n  const [networkStatus, updateNetworkStatus] = useState<NetworkStatus>();\n  const [fatalError, setFatalError] = useState<Error>();\n\n  if (fatalError) {\n    throw fatalError;\n  }\n  if (\n    networkStatus &&\n    (networkStatus.type === \"NETWORK_ERROR\" ||\n      networkStatus.type === \"UNKNOWN_ERROR\")\n  ) {\n    throw new Error(\"network error\");\n  }\n\n  // TODO: split two effects so that changing deviceId won't reconnect.\n  useEffect(() => {\n    const receiveData = (_peerId: number, data: unknown) => {\n      if (\n        data &&\n        typeof data === \"object\" &&\n        typeof (data as { userId: unknown }).userId === \"string\" &&\n        typeof (data as { image: unknown }).image === \"string\" &&\n        isFaceInfo((data as { info: unknown }).info)\n      ) {\n        const roomImage: RoomImage = {\n          userId: (data as { userId: string }).userId,\n          image: (data as { image: ImageUrl }).image,\n          info: (data as { info: FaceInfo }).info,\n          received: Date.now(),\n          obsoleted: false,\n        };\n        setRoomImages((prev) => {\n          let found = false;\n          const next = prev.map((item) => {\n            if (item.userId === roomImage.userId) {\n              found = true;\n              return roomImage;\n            }\n            return item;\n          });\n          return found ? next : [...prev, roomImage];\n        });\n      }\n    };\n    const { broadcastData, dispose } = createRoom(\n      roomId,\n      updateNetworkStatus,\n      receiveData\n    );\n    const checkObsoletedImage = () => {\n      const twoMinAgo = Date.now() - 2 * 60 * 1000;\n      setRoomImages((prev) => {\n        let changed = false;\n        const next = prev.map((item) => {\n          if (item.received < twoMinAgo && !item.obsoleted) {\n            changed = true;\n            return { ...item, obsoleted: true };\n          }\n          return item;\n        });\n        return changed ? next : prev;\n      });\n    };\n    const loop = async () => {\n      try {\n        checkObsoletedImage();\n        const image = await takePhoto(deviceId);\n        setMyImage(image);\n        const data = {\n          userId,\n          image,\n          info: getFaceInfo(),\n        };\n        broadcastData(data);\n      } catch (e) {\n        console.error(e);\n        setFatalError(e);\n      }\n    };\n    loop();\n    const timer = setInterval(loop, 2 * 60 * 1000);\n    return () => {\n      dispose();\n      clearTimeout(timer);\n    };\n  }, [roomId, userId, getFaceInfo, deviceId]);\n\n  return {\n    myImage,\n    roomImages,\n    networkStatus,\n  };\n};\n","import React, { useState } from \"react\";\n\nimport { secureRandomId } from \"../utils/crypto\";\nimport { getRoomIdFromUrl, extractRoomIdFromLink } from \"../utils/url\";\nimport SingleRoom from \"./SingleRoom\";\nimport \"./SingleRoomEntrance.css\";\n\nconst roomIdFromUrl = getRoomIdFromUrl();\nconst userId = secureRandomId();\n\nconst SingleRoomEntrance: React.FC = () => {\n  const [roomId, setRoomId] = useState<string | null>(roomIdFromUrl);\n  const [linkText, setLinkText] = useState(\"\");\n\n  const onCreateNew = () => {\n    setRoomId(secureRandomId());\n  };\n\n  const onEnter = () => {\n    setRoomId(extractRoomIdFromLink(linkText));\n  };\n\n  if (roomId) {\n    return <SingleRoom roomId={roomId} userId={userId} />;\n  }\n\n  return (\n    <div className=\"SingleRoomEntrance-init\">\n      <button type=\"button\" onClick={onCreateNew}>\n        Create a new room\n      </button>\n      OR\n      <input\n        value={linkText}\n        onChange={(e) => setLinkText(e.target.value)}\n        placeholder=\"Enter room link...\"\n      />\n      <button\n        type=\"button\"\n        onClick={onEnter}\n        disabled={!extractRoomIdFromLink(linkText)}\n      >\n        Enter room\n      </button>\n    </div>\n  );\n};\n\nexport default SingleRoomEntrance;\n","import React from \"react\";\n\nimport ErrorFallback from \"./ErrorFallback\";\nimport SingleRoomEntrance from \"./SingleRoomEntrance\";\nimport \"./App.css\";\n\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n\n  render() {\n    const { children } = this.props;\n    const { hasError } = this.state;\n    if (hasError) return <ErrorFallback />;\n    return children;\n  }\n}\n\nconst App: React.FC = () => (\n  <div className=\"App\">\n    <ErrorBoundary>\n      <SingleRoomEntrance />\n    </ErrorBoundary>\n  </div>\n);\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}