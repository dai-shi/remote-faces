{"version":3,"sources":["utils/types.ts","utils/sleep.ts","network/pubsubUtils.ts","network/trackUtils.ts","network/pubsubRoom.ts"],"names":["isObject","x","hasStringProp","prop","hasObjectProp","sleep","ms","Promise","resolve","setTimeout","peerIndexCounter","createConnectionMap","map","Map","setAcceptingMediaTypes","conn","mediaTypes","value","get","peer","acceptingMediaTypes","getAcceptingMediaTypes","addConn","peerId","userId","Error","peerIndex","audioWorkers","vidoeSetImages","set","getConn","findConn","Array","from","values","find","v","delConn","delete","getPeerIndexList","forEachConns","callback","forEach","size","setupMap","WeakMap","setupTrackStopOnLongMute","track","pc","has","onmute","timeout","readyState","transceiver","getTransceivers","t","receiver","currentDirection","stop","dispatchEvent","Event","addEventListener","loopbackPeerConnection","reject","a","pcIn","RTCPeerConnection","pcOut","candidate","addIceCandidate","event","close","addTrack","createOffer","offer","setLocalDescription","setRemoteDescription","createAnswer","answer","videoTrackToImageConverter","kind","canvas","document","createElement","ctx","getContext","imageCapture","ImageCapture","getImage","grabFrame","bitmap","width","height","drawImage","toDataURL","console","log","createImage","src","img","Image","onload","onerror","imageToVideoTrackConverter","captureStream","getVideoTracks","videoTrack","setImage","dataURL","topicsForMediaTypes","getTopicForMediaType","roomId","mediaType","key","topic","sha256","slice","ROOM_ID_PREFIX_LEN","createRoom","updateNetworkStatus","notifyNewPeer","receiveData","receiveTrack","disposed","connMap","roomTopic","importCryptoKey","cryptoKey","type","Ipfs","create","repo","secureRandomId","config","Addresses","Swarm","getWebrtcStarFromUrl","Discovery","MDNS","Enabled","webRTCStar","myIpfs","id","myPeerId","pubsub","subscribe","msg","pubsubHandler","parsePayload","encrypted","decryptStringFromChunks","str","undefined","payload","JSON","parse","info","sendPayload","encryptStringToChunks","stringify","publish","Buffer","error","sendPayloadDirectly","broadcastData","data","sendData","mediaTypeDisposeMap","acceptAudioMedia","disposeList","audioHandler","warn","audioCtx","AudioContext","destination","createMediaStreamDestination","currTime","pending","worker","Worker","onmessage","e","buffer","Float32Array","currentTime","audioBuffer","createBuffer","copyToChannel","audioBufferSource","createBufferSource","connect","onended","start","audioTrack","stream","getAudioTracks","push","terminate","decryptBufferToChunks","byteOffset","byteLength","bufList","buf","postMessage","unshift","unsubscribe","acceptVideoMedia","videoHandler","acceptMediaTypes","mTypes","existingMediaType","includes","dispose","endsWith","handlePayloadMediaTypes","payloadMediaTypes","isArray","every","handlePayloadData","handlePayload","initConnection","payloadUserId","getUserIdFromPayload","peerIndexList","checkPeers","peers","length","trackDisposeMap","runDispose","addAudioTrack","MediaStream","trackSource","createMediaStreamSource","audioWorklet","addModule","audioEncoder","AudioWorkletNode","port","encryptBufferFromChunks","splice","addVideoTrack","videoDisposed","loop","mediaTypeMap","removeTrack"],"mappings":"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","file":"static/js/7.6a1f970c.chunk.js","sourcesContent":["export const isObject = (x: unknown): x is Record<string, unknown> =>\n  typeof x === \"object\" && x !== null;\n\nexport const hasStringProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, string> =>\n  typeof (x as Record<Prop, unknown>)[prop] === \"string\";\n\nexport const hasObjectProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, Record<string, unknown>> =>\n  isObject((x as Record<Prop, unknown>)[prop]);\n\nexport type ReturnPromiseType<\n  F extends (...args: any) => any\n> = ReturnType<F> extends Promise<infer T> ? T : never;\n","export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","let peerIndexCounter = 0;\n\nconst getNextPeerIndex = () => {\n  peerIndexCounter += 1;\n  return peerIndexCounter;\n};\n\n// XXX It would be nice to reuse audio worker for all connections\nexport type Connection = {\n  peerIndex: number;\n  peer: string; // ipfsId\n  userId: string;\n  audioWorkers: Map<string, Worker>; // <mediaType, audioDecoder>\n  vidoeSetImages: Map<string, (s: string) => void>; // <mediaType, setImage>\n};\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Connection;\n    acceptingMediaTypes: string[];\n  };\n  const map = new Map<string, Value>();\n\n  const setAcceptingMediaTypes = (conn: Connection, mediaTypes: string[]) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.acceptingMediaTypes = mediaTypes;\n    }\n  };\n\n  const getAcceptingMediaTypes = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (!value) return [];\n    return value.acceptingMediaTypes;\n  };\n\n  const addConn = (peerId: string, userId: string) => {\n    const value = map.get(peerId);\n    if (value) {\n      throw new Error(\"addConn: already exists\");\n    }\n    const conn: Connection = {\n      peerIndex: getNextPeerIndex(),\n      peer: peerId,\n      userId,\n      audioWorkers: new Map(),\n      vidoeSetImages: new Map(),\n    };\n    map.set(conn.peer, {\n      conn,\n      acceptingMediaTypes: [],\n    });\n    return conn;\n  };\n\n  const getConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return null;\n    return value.conn;\n  };\n\n  const findConn = (peerIndex: number) => {\n    const value = Array.from(map.values()).find(\n      (v) => v.conn.peerIndex === peerIndex\n    );\n    if (value) return value.conn;\n    return null;\n  };\n\n  const delConn = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n    } else {\n      throw new Error(\"delConn: does not exist\");\n    }\n  };\n\n  const getPeerIndexList = () =>\n    Array.from(map.values()).map((v) => v.conn.peerIndex);\n\n  const forEachConns = (callback: (conn: Connection) => void) => {\n    Array.from(map.values()).forEach((value) => {\n      callback(value.conn);\n    });\n  };\n\n  const size = () => map.size;\n\n  return {\n    setAcceptingMediaTypes,\n    getAcceptingMediaTypes,\n    addConn,\n    getConn,\n    findConn,\n    delConn,\n    getPeerIndexList,\n    forEachConns,\n    size,\n  };\n};\n","const setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = (timeout = 1000) => {\n    if (track.readyState === \"ended\") return;\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    } else if (timeout < 64000) {\n      setTimeout(() => {\n        onmute(timeout * 2);\n      }, timeout);\n    }\n  };\n  track.addEventListener(\"mute\", () => onmute());\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n\nexport const videoTrackToImageConverter = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") {\n    throw new Error(\"track kind is not video\");\n  }\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const imageCapture = new ImageCapture(track);\n  const getImage = async () => {\n    try {\n      const bitmap = await imageCapture.grabFrame();\n      canvas.width = bitmap.width;\n      canvas.height = bitmap.height;\n      ctx.drawImage(bitmap, 0, 0);\n      return canvas.toDataURL(\"image/jpeg\");\n    } catch (e) {\n      console.log(\"failed to grab frame from viedeo track\", e);\n      return null;\n    }\n  };\n  return { getImage };\n};\n\nconst createImage = (src: string): Promise<HTMLImageElement> =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n\nexport const imageToVideoTrackConverter = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const [videoTrack] = canvasStream.getVideoTracks();\n  const setImage = async (dataURL: string) => {\n    const img = await createImage(dataURL);\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n  };\n  return { videoTrack, setImage };\n};\n","import Ipfs from \"ipfs\";\n\nimport { sleep } from \"../utils/sleep\";\nimport {\n  sha256,\n  secureRandomId,\n  importCryptoKey,\n  encryptStringToChunks,\n  decryptStringFromChunks,\n  encryptBufferFromChunks,\n  decryptBufferToChunks,\n} from \"../utils/crypto\";\nimport { getWebrtcStarFromUrl } from \"../utils/url\";\nimport { isObject } from \"../utils/types\";\nimport { ROOM_ID_PREFIX_LEN, PeerInfo, CreateRoom } from \"./common\";\nimport { Connection, createConnectionMap } from \"./pubsubUtils\";\nimport {\n  loopbackPeerConnection,\n  videoTrackToImageConverter,\n  imageToVideoTrackConverter,\n} from \"./trackUtils\";\n\n// copied from node_modules/ipfs-core/dist/src/components/pubsub.d.ts\ntype Message = {\n  from: string;\n  seqno: Uint8Array;\n  data: Uint8Array;\n  topicIDs: string[];\n};\n\nconst topicsForMediaTypes = new Map<string, string>();\n\nconst getTopicForMediaType = async (roomId: string, mediaType: string) => {\n  const key = `${roomId} ${mediaType}`;\n  let topic = topicsForMediaTypes.get(key);\n  if (!topic) {\n    topic = (await sha256(key)).slice(0, ROOM_ID_PREFIX_LEN);\n    topicsForMediaTypes.set(key, topic);\n  }\n  return topic;\n};\n\nexport const createRoom: CreateRoom = async (\n  roomId,\n  userId,\n  updateNetworkStatus,\n  notifyNewPeer,\n  receiveData,\n  receiveTrack\n) => {\n  let disposed = false;\n  const connMap = createConnectionMap();\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myConnMap = connMap;\n  }\n  let mediaTypes: string[] = [];\n\n  const roomTopic = roomId.slice(0, ROOM_ID_PREFIX_LEN);\n  const cryptoKey = await importCryptoKey(roomId.slice(ROOM_ID_PREFIX_LEN));\n\n  updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex: 0 });\n  const myIpfs = await Ipfs.create({\n    repo: secureRandomId(),\n    config: {\n      Addresses: {\n        Swarm: [\n          getWebrtcStarFromUrl() ||\n            \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\n        ],\n      },\n      Discovery: {\n        MDNS: { Enabled: true },\n        webRTCStar: { Enabled: true },\n      },\n    },\n  });\n  const myPeerId = (await myIpfs.id()).id;\n  await myIpfs.pubsub.subscribe(roomTopic, (msg) => pubsubHandler(msg));\n  await myIpfs.pubsub.subscribe(`${roomTopic} ${myPeerId}`, (msg) =>\n    pubsubHandler(msg)\n  );\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myIpfs = myIpfs;\n  }\n\n  const parsePayload = async (encrypted: ArrayBuffer): Promise<unknown> => {\n    try {\n      const str = await decryptStringFromChunks(encrypted, cryptoKey);\n      if (str === null) return undefined;\n      const payload = JSON.parse(str);\n      console.log(\"decrypted payload\", payload);\n      return payload;\n    } catch (e) {\n      console.info(\"Error in parsePayload\", e, encrypted);\n      return undefined;\n    }\n  };\n\n  const sendPayload = async (topic: string, payload: unknown) => {\n    try {\n      console.log(\"payload to encrypt\", topic, payload);\n      for await (const encrypted of encryptStringToChunks(\n        JSON.stringify(payload),\n        cryptoKey\n      )) {\n        await myIpfs.pubsub.publish(topic, Buffer.from(encrypted), {});\n      }\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const sendPayloadDirectly = async (conn: Connection, payload: unknown) => {\n    const topic = `${roomTopic} ${conn.peer}`;\n    // XXX this doesn't seem to work in ipfs v0.48.0\n    await sendPayload(topic, payload);\n  };\n\n  const broadcastData = async (data: unknown) => {\n    if (disposed) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayload(roomTopic, payload);\n  };\n\n  const sendData = async (data: unknown, peerIndex: number) => {\n    if (disposed) return;\n    const conn = connMap.findConn(peerIndex);\n    if (!conn) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayloadDirectly(conn, payload);\n  };\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).sendData = sendData;\n  }\n\n  const mediaTypeDisposeMap = new Map<string, (() => void)[]>();\n\n  const acceptAudioMedia = async (mediaType: string) => {\n    const disposeList: (() => void)[] = [];\n    mediaTypeDisposeMap.set(mediaType, disposeList);\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const audioHandler = async (msg: Message) => {\n      if (msg.from === myPeerId) return;\n      const conn = connMap.getConn(msg.from);\n      if (!conn) {\n        console.warn(\"conn not ready\");\n        return;\n      }\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      if (!conn.audioWorkers.has(mediaType)) {\n        const audioCtx = new AudioContext();\n        const destination = audioCtx.createMediaStreamDestination();\n        let currTime = 0;\n        let pending = 0;\n        const worker = new Worker(\"audio-decoder.js\", { type: \"module\" });\n        worker.onmessage = (e) => {\n          const buffer = new Float32Array(e.data);\n          if (!pending) {\n            currTime = audioCtx.currentTime;\n          }\n          currTime += 0.06; // 60ms\n          pending += 1;\n          const audioBuffer = audioCtx.createBuffer(1, 2880, 48000);\n          audioBuffer.copyToChannel(buffer, 0);\n          const audioBufferSource = audioCtx.createBufferSource();\n          audioBufferSource.buffer = audioBuffer;\n          audioBufferSource.connect(destination);\n          audioBufferSource.onended = () => {\n            pending -= 1;\n          };\n          audioBufferSource.start(currTime);\n        };\n        conn.audioWorkers.set(mediaType, worker);\n        const audioTrack = destination.stream.getAudioTracks()[0];\n        receiveTrack(mediaType, await loopbackPeerConnection(audioTrack), info);\n        // XXX currently no way to detect track stop\n        disposeList.push(() => {\n          audioCtx.close();\n          audioTrack.dispatchEvent(new Event(\"ended\"));\n          worker.terminate();\n          conn.audioWorkers.delete(mediaType);\n        });\n      }\n      const bufList = await decryptBufferToChunks(\n        msg.data.buffer,\n        msg.data.byteOffset,\n        msg.data.byteLength,\n        cryptoKey\n      );\n      const worker = conn.audioWorkers.get(mediaType);\n      if (worker) {\n        bufList.forEach((buf) => {\n          worker.postMessage([buf], [buf]);\n        });\n      }\n    };\n    myIpfs.pubsub.subscribe(topic, audioHandler);\n    disposeList.unshift(() => {\n      myIpfs.pubsub.unsubscribe(topic, audioHandler);\n    });\n  };\n\n  const acceptVideoMedia = async (mediaType: string) => {\n    const disposeList: (() => void)[] = [];\n    mediaTypeDisposeMap.set(mediaType, disposeList);\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const videoHandler = async (msg: Message) => {\n      if (msg.from === myPeerId) return;\n      const conn = connMap.getConn(msg.from);\n      if (!conn) {\n        console.warn(\"conn not ready\");\n        return;\n      }\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      if (!conn.vidoeSetImages.has(mediaType)) {\n        const { videoTrack, setImage } = imageToVideoTrackConverter();\n        conn.vidoeSetImages.set(mediaType, setImage);\n        receiveTrack(mediaType, videoTrack, info);\n        // XXX currently no way to detect track stop\n        disposeList.push(() => {\n          videoTrack.dispatchEvent(new Event(\"ended\"));\n          conn.vidoeSetImages.delete(mediaType);\n        });\n      }\n      const setImage = conn.vidoeSetImages.get(mediaType);\n      try {\n        const dataURL = await decryptStringFromChunks(msg.data, cryptoKey);\n        if (setImage && dataURL) {\n          setImage(dataURL);\n        }\n      } catch (e) {\n        console.info(\"Error in parse for video media\", e);\n      }\n    };\n    myIpfs.pubsub.subscribe(topic, videoHandler);\n    disposeList.unshift(() => {\n      myIpfs.pubsub.unsubscribe(topic, videoHandler);\n    });\n  };\n\n  const acceptMediaTypes = (mTypes: string[]) => {\n    if (disposed) return;\n    mediaTypeDisposeMap.forEach((disposeList, existingMediaType) => {\n      if (!mTypes.includes(existingMediaType)) {\n        disposeList.forEach((dispose) => dispose());\n        mediaTypeDisposeMap.delete(existingMediaType);\n      }\n    });\n    mTypes.forEach((mediaType) => {\n      if (mediaTypeDisposeMap.has(mediaType)) return;\n      if (mediaType.endsWith(\"Audio\")) {\n        acceptAudioMedia(mediaType);\n      } else if (mediaType.endsWith(\"Video\")) {\n        acceptVideoMedia(mediaType);\n      } else {\n        throw new Error(\"pubsubRoom: cannot guess mediaType (Audio/Video)\");\n      }\n    });\n    mediaTypes = mTypes;\n    broadcastData(null);\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Connection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setAcceptingMediaTypes(conn, payloadMediaTypes as string[]);\n    }\n  };\n\n  const handlePayloadData = (conn: Connection, data: unknown) => {\n    const info: PeerInfo = {\n      userId: conn.userId,\n      peerIndex: conn.peerIndex,\n      mediaTypes: connMap.getAcceptingMediaTypes(conn),\n    };\n    try {\n      receiveData(data, info);\n    } catch (e) {\n      console.warn(\"receiveData\", e);\n    }\n  };\n\n  const handlePayload = async (conn: Connection, payload: unknown) => {\n    try {\n      if (!isObject(payload)) return;\n\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, payload);\n    }\n  };\n\n  const initConnection = (peerId: string, payloadUserId: string) => {\n    const conn = connMap.addConn(peerId, payloadUserId);\n    notifyNewPeer(conn.peerIndex);\n    updateNetworkStatus({\n      type: \"NEW_CONNECTION\",\n      peerIndex: conn.peerIndex,\n    });\n    return conn;\n  };\n\n  const getUserIdFromPayload = (payload: unknown) => {\n    if (!isObject(payload)) return null;\n    const payloadUserId = (payload as { userId: unknown }).userId;\n    if (typeof payloadUserId !== \"string\") return null;\n    return payloadUserId;\n  };\n\n  const pubsubHandler = async (msg: Message) => {\n    if (disposed) return;\n    if (msg.from === myPeerId) return;\n    const payload = await parsePayload(msg.data);\n    if (payload === undefined) return;\n    const payloadUserId = getUserIdFromPayload(payload);\n    let conn = connMap.getConn(msg.from);\n    if (!conn) {\n      if (payloadUserId) {\n        conn = initConnection(msg.from, payloadUserId);\n      } else {\n        console.warn(\"cannot initialize conn without user id\");\n      }\n    }\n    if (conn) {\n      await handlePayload(conn, payload);\n    }\n    const peerIndexList = connMap.getPeerIndexList();\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const checkPeers = async () => {\n    if (disposed) return;\n    const peers = await myIpfs.pubsub.peers(roomTopic);\n    connMap.forEachConns((conn) => {\n      if (!peers.includes(conn.peer)) {\n        connMap.delConn(conn);\n        updateNetworkStatus({\n          type: \"CONNECTION_CLOSED\",\n          peerIndex: conn.peerIndex,\n        });\n      }\n    });\n    if (!peers.length) {\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      await sleep(1000);\n      checkPeers();\n      return;\n    }\n    if (!connMap.size()) {\n      await broadcastData(null);\n    }\n    await sleep(5000);\n    checkPeers();\n  };\n  checkPeers();\n\n  const trackDisposeMap = new WeakMap<MediaStreamTrack, () => void>();\n  const runDispose = (dispose?: () => void) => {\n    if (dispose) {\n      dispose();\n    }\n  };\n\n  const addAudioTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    runDispose(trackDisposeMap.get(track));\n    const stream = new MediaStream([track]);\n    const audioCtx = new AudioContext();\n    const trackSource = audioCtx.createMediaStreamSource(stream);\n    await audioCtx.audioWorklet.addModule(\"audio-encoder.js\");\n    const audioEncoder = new AudioWorkletNode(audioCtx, \"audio-encoder\");\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const bufList: ArrayBuffer[] = [];\n    audioEncoder.port.onmessage = async (event) => {\n      bufList.push(event.data);\n      if (bufList.length < 17) return;\n      const encrypted = await encryptBufferFromChunks(\n        bufList.splice(0, bufList.length),\n        cryptoKey\n      );\n      myIpfs.pubsub.publish(topic, Buffer.from(encrypted), {});\n    };\n    trackSource.connect(audioEncoder);\n    trackDisposeMap.set(track, () => {\n      audioCtx.close();\n    });\n  };\n\n  const addVideoTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    runDispose(trackDisposeMap.get(track));\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const { getImage } = await videoTrackToImageConverter(track);\n    let videoDisposed = false;\n    const loop = async () => {\n      if (videoDisposed) return;\n      const dataURL = await getImage();\n      if (dataURL) {\n        for await (const encrypted of encryptStringToChunks(\n          dataURL,\n          cryptoKey\n        )) {\n          if (videoDisposed) return;\n          await myIpfs.pubsub.publish(topic, Buffer.from(encrypted), {});\n          await sleep(1000);\n        }\n      } else {\n        await sleep(5000);\n      }\n      loop();\n    };\n    loop();\n    trackDisposeMap.set(track, () => {\n      videoDisposed = true;\n    });\n  };\n\n  const mediaTypeMap = new Map<string, MediaStreamTrack>();\n\n  const addTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    if (disposed) return;\n    if (mediaTypeMap.has(mediaType)) {\n      throw new Error(`track is already added for ${mediaType}`);\n    }\n    mediaTypeMap.set(mediaType, track);\n    if (mediaType.endsWith(\"Audio\")) {\n      addAudioTrack(mediaType, track);\n    } else if (mediaType.endsWith(\"Video\")) {\n      addVideoTrack(mediaType, track);\n    } else {\n      throw new Error(\"pubsubRoom: cannot guess mediaType (Audio/Video)\");\n    }\n  };\n\n  const removeTrack = (mediaType: string) => {\n    if (disposed) return;\n    const track = mediaTypeMap.get(mediaType);\n    if (!track) {\n      console.log(\"track is already removed for\", mediaType);\n      return;\n    }\n    mediaTypeMap.delete(mediaType);\n    runDispose(trackDisposeMap.get(track));\n  };\n\n  const dispose = async () => {\n    disposed = true;\n    await myIpfs.pubsub.unsubscribe(`${roomTopic} ${myPeerId}`, pubsubHandler);\n    await myIpfs.pubsub.unsubscribe(roomTopic, pubsubHandler);\n    await myIpfs.stop();\n  };\n\n  return {\n    broadcastData,\n    sendData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n"],"sourceRoot":""}