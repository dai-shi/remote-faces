import{c as ie}from"./index.c2190364.js";import{i as V,s as S}from"./SingleRoom.e03ecbb9.js";import{R,i as ce,n as de,v as ue,w as z,x as j,A as pe,C as fe,D as le}from"./index.17df8600.js";import{v as ye,l as we,i as ge}from"./trackUtils.b921598c.js";let H=0;const be=()=>(H+=1,H),he=()=>{const i=new Map;return{setAcceptingMediaTypes:(r,o)=>{const f=i.get(r.peer);f&&(f.acceptingMediaTypes=o)},getAcceptingMediaTypes:r=>{const o=i.get(r.peer);return o?o.acceptingMediaTypes:[]},addConn:(r,o)=>{if(i.get(r))throw new Error("addConn: already exists");const C={peerIndex:be(),peer:r,userId:o,audioWorkers:new Map,vidoeSetImages:new Map};return i.set(C.peer,{conn:C,acceptingMediaTypes:[]}),C},getConn:r=>{const o=i.get(r);return o?o.conn:null},findConn:r=>{const o=Array.from(i.values()).find(f=>f.conn.peerIndex===r);return o?o.conn:null},delConn:r=>{const o=i.get(r.peer);if(o&&o.conn===r)i.delete(r.peer);else throw new Error("delConn: does not exist")},getPeerIndexList:()=>Array.from(i.values()).map(r=>r.conn.peerIndex),forEachConns:r=>{Array.from(i.values()).forEach(o=>{r(o.conn)})},size:()=>i.size}},G=new Map,k=async(i,I)=>{const y=`${i} ${I}`;let h=G.get(y);return h||(h=(await fe(y)).slice(0,R),G.set(y,h)),h},xe=async(i,I,y,h,U,P)=>{let w=!1;const d=he();let M=[];const g=i.slice(0,R),r=await ce(i.slice(R));y({type:"INITIALIZING_PEER",peerIndex:0});const o=await ie({repo:de(),config:{Addresses:{Swarm:[ue()||"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/"]},Bootstrap:[]}}),f=(await o.id()).id;await o.pubsub.subscribe(g,e=>A(e)),await o.pubsub.subscribe(`${g} ${f}`,e=>A(e));const C=async e=>{try{const t=await z(e,r);if(t===null)return;const n=JSON.parse(t);return console.log("decrypted payload",n),n}catch(t){console.info("Error in parsePayload",t,e);return}},_=async(e,t)=>{try{console.log("payload to encrypt",e,t);for await(const n of j(JSON.stringify(t),r))await o.pubsub.publish(e,new Uint8Array(n),{})}catch(n){console.error("sendPayload",n)}},J=async(e,t)=>{const n=`${g} ${e.peer}`;await _(n,t)},T=async e=>{if(w)return;await _(g,{userId:I,data:e,mediaTypes:M})},K=async(e,t)=>{if(w)return;const n=d.findConn(t);if(!n)return;await J(n,{userId:I,data:e,mediaTypes:M})},E=new Map,X=async e=>{const t=[];E.set(e,t);const n=await k(i,e),a=async c=>{if(!("from"in c)||c.from.toString()===f.toString())return;const s=d.getConn(c.from.toString());if(!s){console.warn("conn not ready");return}const b={userId:s.userId,peerIndex:s.peerIndex,mediaTypes:d.getAcceptingMediaTypes(s)};if(!s.audioWorkers.has(e)){const p=new AudioContext,$=p.createMediaStreamDestination();let W=0,L=0;const O=new Worker("audio-decoder.js",{type:"module"});O.onmessage=se=>{const ae=new Float32Array(se.data);L||(W=p.currentTime),W+=.06,L+=1;const B=p.createBuffer(1,2880,48e3);B.copyToChannel(ae,0);const x=p.createBufferSource();x.buffer=B,x.connect($),x.onended=()=>{L-=1},x.start(W)},s.audioWorkers.set(e,O);const F=$.stream.getAudioTracks()[0];P(e,await we(F),b),t.push(()=>{p.close(),F.dispatchEvent(new Event("ended")),O.terminate(),s.audioWorkers.delete(e)})}const l=await le(c.data.buffer,c.data.byteOffset,c.data.byteLength,r),u=s.audioWorkers.get(e);u&&l.forEach(p=>{u.postMessage([p],[p])})};o.pubsub.subscribe(n,a),t.unshift(()=>{o.pubsub.unsubscribe(n,a)})},Z=async e=>{const t=[];E.set(e,t);const n=await k(i,e),a=async c=>{if(!("from"in c)||c.from.toString()===f.toString())return;const s=d.getConn(c.from.toString());if(!s){console.warn("conn not ready");return}const b={userId:s.userId,peerIndex:s.peerIndex,mediaTypes:d.getAcceptingMediaTypes(s)};if(!s.vidoeSetImages.has(e)){const{videoTrack:u,setImage:p}=ge();s.vidoeSetImages.set(e,p),P(e,u,b),t.push(()=>{u.dispatchEvent(new Event("ended")),s.vidoeSetImages.delete(e)})}const l=s.vidoeSetImages.get(e);try{const u=await z(c.data,r);l&&u&&l(u)}catch(u){console.info("Error in parse for video media",u)}};o.pubsub.subscribe(n,a),t.unshift(()=>{o.pubsub.unsubscribe(n,a)})},q=e=>{w||(E.forEach((t,n)=>{e.includes(n)||(t.forEach(a=>a()),E.delete(n))}),e.forEach(t=>{if(!E.has(t))if(t.endsWith("Audio"))X(t);else if(t.endsWith("Video"))Z(t);else throw new Error("pubsubRoom: cannot guess mediaType (Audio/Video)")}),M=e,T(null))},Q=async(e,t)=>{Array.isArray(t)&&t.every(n=>typeof n=="string")&&d.setAcceptingMediaTypes(e,t)},Y=(e,t)=>{const n={userId:e.userId,peerIndex:e.peerIndex,mediaTypes:d.getAcceptingMediaTypes(e)};try{U(t,n)}catch(a){console.warn("receiveData",a)}},ee=async(e,t)=>{try{if(!V(t))return;Q(e,t.mediaTypes),Y(e,t.data)}catch(n){console.info("Error in handlePayload",n,t)}},te=(e,t)=>{const n=d.addConn(e,t);return h(n.peerIndex),y({type:"NEW_CONNECTION",peerIndex:n.peerIndex}),n},ne=e=>{if(!V(e))return null;const t=e.userId;return typeof t!="string"?null:t},A=async e=>{if(w||!("from"in e)||e.from.toString()===f.toString())return;const t=await C(e.data);if(t===void 0)return;const n=ne(t);let a=d.getConn(e.from.toString());a||(n?a=te(e.from.toString(),n):console.warn("cannot initialize conn without user id")),a&&await ee(a,t);const c=d.getPeerIndexList();y({type:"CONNECTED_PEERS",peerIndexList:c})},D=async()=>{if(w)return;const e=await o.pubsub.peers(g);if(d.forEachConns(t=>{e.some(n=>n.toString()===t.peer)||(d.delConn(t),y({type:"CONNECTION_CLOSED",peerIndex:t.peerIndex}))}),!e.length){y({type:"CONNECTING_SEED_PEERS"}),await S(1e3),D();return}d.size()||await T(null),await S(5e3),D()};D();const v=new WeakMap,N=e=>{e&&e()},oe=async(e,t)=>{N(v.get(t));const n=new MediaStream([t]),a=new AudioContext,c=a.createMediaStreamSource(n);await a.audioWorklet.addModule("audio-encoder.js");const s=new AudioWorkletNode(a,"audio-encoder"),b=await k(i,e),l=[];s.port.onmessage=async u=>{if(l.push(u.data),l.length<17)return;const p=await pe(l.splice(0,l.length),r);o.pubsub.publish(b,new Uint8Array(p),{})},c.connect(s),v.set(t,()=>{a.close()})},re=async(e,t)=>{N(v.get(t));const n=await k(i,e),{getImage:a}=await ye(t);let c=!1;const s=async()=>{if(c)return;const b=await a();if(b)for await(const l of j(b,r)){if(c)return;await o.pubsub.publish(n,new Uint8Array(l),{}),await S(1e3)}else await S(5e3);s()};s(),v.set(t,()=>{c=!0})},m=new Map;return{broadcastData:T,sendData:K,acceptMediaTypes:q,addTrack:async(e,t)=>{if(!w){if(m.has(e))throw new Error(`track is already added for ${e}`);if(m.set(e,t),e.endsWith("Audio"))oe(e,t);else if(e.endsWith("Video"))re(e,t);else throw new Error("pubsubRoom: cannot guess mediaType (Audio/Video)")}},removeTrack:e=>{if(w)return;const t=m.get(e);if(!t){console.log("track is already removed for",e);return}m.delete(e),N(v.get(t))},dispose:async()=>{w=!0,await o.pubsub.unsubscribe(`${g} ${f}`,A),await o.pubsub.unsubscribe(g,A),await o.stop()}}};export{xe as createRoom};
