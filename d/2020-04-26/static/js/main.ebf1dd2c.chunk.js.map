{"version":3,"sources":["../../node_modules/peerjs/dist sync","components/ErrorFallback.tsx","utils/crypto.ts","utils/url.ts","network/peerUtils.ts","network/room.ts","hooks/useRoom.ts","media/devices.ts","utils/sleep.ts","media/capture.ts","hooks/useFaceImages.ts","media/video.ts","media/audio.ts","hooks/useFaceVideos.ts","components/FaceImages.tsx","hooks/useMomentaryChat.ts","components/MomentaryChat.tsx","components/SingleRoom.tsx","utils/storage.ts","hooks/useAvailableDevices.ts","components/SingleRoomEntrance.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","ErrorFallback","useState","waitSec","setWaitSec","useEffect","setTimeout","window","location","reload","secureRandomId","arrbuf","crypto","getRandomValues","Uint8Array","Array","from","map","b","toString","padStart","join","rand4","Uint16Array","extractRoomIdFromLink","link","hash","URL","slice","URLSearchParams","get","generatePeerId","roomId","peerIndex","getPeerIndexFromPeerId","peerId","Number","split","getPeerIndexFromConn","conn","peer","guessSeed","createRoom","userId","updateNetworkStatus","receiveData","receiveTrack","disposed","myPeer","lastBroadcastData","connMap","Map","addConn","value","close","set","markConnected","connected","isConnected","setUserId","getUserId","setLiveMode","liveMode","getLiveMode","hasConn","has","delConn","delete","getConnectedPeerIds","filter","k","forEachConnectedConns","callback","values","forEach","forEachLiveConns","clearAll","size","console","log","clear","createConnectionMap","localStream","showConnectedStatus","peerIndexList","type","connectPeer","connect","serialization","initConnection","broadcastData","data","replaceLastData","peers","send","error","sendSDP","sdp","SDP","handleSDP","a","offer","peerConnection","setRemoteDescription","createAnswer","answer","setLocalDescription","warn","handlePayload","payload","payloadUserId","handleUserId","payloadLiveMode","addAllStreamTracks","removeAllStreamTracks","handleLiveMode","isArray","startsWith","isValidPeerId","connUserId","info","on","addEventListener","createOffer","event","track","length","reInitMyPeer","disconnected","Math","floor","random","initMyPeer","index","isSeed","Peer","debug","i","seedId","err","destroy","destroyed","reconnect","force","existsAllSeeds","oldPeer","removeTrack","senders","getSenders","sender","find","s","getTracks","addTrack","name","enableLiveMode","MediaStream","disableLiveMode","dispose","roomEntryMap","register","networkStatusListener","dataListener","trackListener","roomEntryKey","entry","networkStatusListeners","Set","dataListeners","trackListeners","room","status","listener","count","add","unregister","useRoomNetworkStatus","networkStatus","useBroadcastData","broadcastDataRef","useRef","useCallback","current","broadcastDataByRegister","useRoomData","isValidData","latestData","setLatestData","undefined","getVideoDeviceInfoList","navigator","mediaDevices","enumerateDevices","devices","list","kind","label","deviceId","getAudioDeviceInfoList","sleep","ms","Promise","captureImage","stream","ImageCapture","imageCapture","takePhoto","blob","createImageBitmap","srcImg","grabFrame","srcW","width","srcH","height","video","document","getElementById","style","display","savedSrcObject","srcObject","revert","videoWidth","videoHeight","constraints","getUserMedia","getVideoTracks","canvas","ctx","getContext","dstW","dstH","ratio","max","min","x","y","drawImage","stop","toDataURL","isImageData","image","nickname","message","isFaceInfo","getVideoStream","timer","setInterval","canvasStream","captureStream","clearInterval","getAudioStream","audio","getAudioTracks","applyConstraints","echoCancellation","echoCancellationType","ideal","noiseSuppression","addTrackWithNewStream","newStream","clone","removeTrackWithNewStream","t","useFaceVideos","videoEnabled","audioEnabled","videoDeviceId","audioDeviceId","faceStream","setFaceStream","faceStreamMap","setFaceStreamMap","enabled","functions","setFunctions","latestTrack","setLatestTrack","result","useRoomMedia","cleanupFns","fn","prev","timeout","onended","onmute","clearTimeout","onunmute","push","removeEventListener","videoStream","disposeVideo","videoTrack","audioStream","disposeAudio","audioTrack","FaceImage","React","memo","statusMesg","obsoleted","unmuted","videoRef","hasVideo","hasAudio","className","opacity","ref","autoPlay","muted","src","alt","title","liveType","myImage","setMyImage","roomImages","setRoomImages","fatalError","setFatalError","faceInfo","roomImage","received","Date","now","item","changed","next","checkObsoletedImage","twoMinAgo","tenMinAgo","loop","useFaceImages","key","isChatData","chatSeq","chatText","chatInReplyTo","compareReply","countDiff","reactions","ReactionButton","text","onClick","aria-label","MomentaryChatContent","chatList","replyChat","reply","replyTo","replies","chatSeqRef","receivedSeqMap","setChatList","addChatItem","chatData","replyMap","entries","sort","chatItem","sendChat","inReplyTo","useMomentaryChat","setText","onSubmit","preventDefault","onChange","target","placeholder","disabled","initialNickname","localStorage","getItem","getStringItem","SingleRoom","setNickname","setStatusMesg","searchParams","setRoomIdToUrl","videoDevices","setDevices","deviceInfoList","useVideoDevices","audioDevices","useAudioDevices","setVideoDeviceId","setAudioDeviceId","setLiveType","configOpen","setConfigOpen","appLink","href","replace","JSON","stringify","readOnly","defaultValue","setItem","setStringItem","videoDevice","audioDevice","roomIdFromUrl","getRoomIdFromUrl","SingleRoomEntrance","setRoomId","linkText","setLinkText","ErrorBoundary","state","hasError","children","this","props","Component","App","Boolean","hostname","match","ReactDOM","render","StrictMode","serviceWorker","ready","then","registration","catch"],"mappings":"qNAAA,SAASA,EAAoBC,GAC5B,IAAIC,EAAI,IAAIC,MAAM,uBAAyBF,EAAM,KAEjD,MADAC,EAAEE,KAAO,mBACHF,EAEPF,EAAoBK,KAAO,WAAa,MAAO,IAC/CL,EAAoBM,QAAUN,EAC9BO,EAAOC,QAAUR,EACjBA,EAAoBS,GAAK,I,8KCeVC,EArBiB,WAAO,IAAD,EACNC,mBAAS,IADH,mBAC7BC,EAD6B,KACpBC,EADoB,KAapC,OAVAC,qBAAU,WACJF,EAAU,EACZG,YAAW,WACTF,EAAWD,EAAU,KACpB,KAEHI,OAAOC,SAASC,YAKlB,6BACE,6DACA,kDAAwBN,EAAxB,W,+BCTOO,EAAiB,WAC5B,IAAMC,EAASJ,OAAOK,OAAOC,gBAAgB,IAAIC,WAAW,KAG5D,OAFYC,MAAMC,KAAKL,GACPM,KAAI,SAACC,GAAD,OAAOA,EAAEC,SAAS,IAAIC,SAAS,EAAG,QAAMC,KAAK,KAItDC,EAAQ,WAEnB,OAAO,IADMf,OAAOK,OAAOC,gBAAgB,IAAIU,YAAY,IAAI,GACzC,KClBXC,EAAwB,SAACC,GACpC,IACE,IAAMC,EAAO,IAAIC,IAAIF,GAAMC,KAAKE,MAAM,GAEtC,OADqB,IAAIC,gBAAgBH,GACrBI,IAAI,UACxB,MAAOrC,GACP,OAAO,O,gCCEEsC,EAAiB,SAACC,EAAgBC,GAAjB,gBACzBD,EADyB,YACfC,IAEFC,EAAyB,SAACC,GAAD,OACpCC,OAAOD,EAAOE,MAAM,KAAK,KAEdC,EAAuB,SAACC,GAAD,OAClCL,EAAuBK,EAAKC,OCFxBC,EAAY,SAACzC,GACjB,IAAMiC,EAAYC,EAAuBlC,GACzC,OAJ0B,IAIIiC,GAAaA,GAHjB,IAqBfS,EAAa,SACxBV,EACAW,EACAC,EACAC,EACAC,GAEA,IAAIC,GAAW,EACXC,EAAsB,KACtBC,EAAoC,KAClCC,ED1B2B,WAOjC,IAAMjC,EAAM,IAAIkC,IAmFhB,MAAO,CACLC,QAlFc,SAACb,GACf,IAAMc,EAAQpC,EAAIa,IAAIS,EAAKC,MACvBa,GACFA,EAAMd,KAAKe,QAEbrC,EAAIsC,IAAIhB,EAAKC,KAAM,CAAED,UA8ErBiB,cA3EoB,SAACjB,GACrB,IAAMc,EAAQpC,EAAIa,IAAIS,EAAKC,MACvBa,IACFA,EAAMI,WAAY,IAyEpBC,YArEkB,SAACvB,GACnB,IAAMkB,EAAQpC,EAAIa,IAAIK,GACtB,OAAQkB,GAASA,EAAMI,YAAc,GAoErCE,UAjEgB,SAACpB,EAA2BI,GAC5C,IAAMU,EAAQpC,EAAIa,IAAIS,EAAKC,MACvBa,IACFA,EAAMV,OAASA,IA+DjBiB,UA3DgB,SAACrB,GACjB,IAAMc,EAAQpC,EAAIa,IAAIS,EAAKC,MAC3B,OAAOa,GAASA,EAAMV,QA0DtBkB,YAvDkB,SAACtB,EAA2BuB,GAC9C,IAAMT,EAAQpC,EAAIa,IAAIS,EAAKC,MACvBa,IACFA,EAAMS,SAAWA,IAqDnBC,YAjDkB,SAACxB,GACnB,IAAMc,EAAQpC,EAAIa,IAAIS,EAAKC,MAC3B,OAAQa,GAASA,EAAMS,WAAa,GAgDpCE,QA7Cc,SAAC7B,GAAD,OAAoBlB,EAAIgD,IAAI9B,IA8C1C+B,QA5Cc,SAAC3B,GACf,IAAMc,EAAQpC,EAAIa,IAAIS,EAAKC,MACvBa,GAASA,EAAMd,OAASA,GAC1BtB,EAAIkD,OAAO5B,EAAKC,OA0ClB4B,oBAtC0B,kBAC1BrD,MAAMC,KAAKC,EAAIrB,QAAQyE,QAAO,SAACC,GAAD,uBAAOrD,EAAIa,IAAIwC,UAAf,aAAO,EAAYb,cAsCjDc,sBApC4B,SAC5BC,GAEAzD,MAAMC,KAAKC,EAAIwD,UAAUC,SAAQ,SAACrB,GAC5BA,EAAMI,WACRe,EAASnB,EAAMd,UAgCnBoC,iBA3BuB,SAACH,GACxBzD,MAAMC,KAAKC,EAAIwD,UAAUC,SAAQ,SAACrB,GAC5BA,EAAMI,WAAaJ,EAAMS,UAC3BU,EAASnB,EAAMd,UAyBnBqC,SApBe,WACX3D,EAAI4D,MACNC,QAAQC,IAAI,yBAA0B9D,GAExCA,EAAI+D,UC7DUC,GACZnB,GAAW,EACXoB,EAAkC,KAEhCC,EAAsB,WAC1B,IAAIpC,EAAJ,CACA,IAAMqC,EAAgBlC,EACnBkB,sBACAnD,IAAIiB,GACPU,EAAoB,CAAEyC,KAAM,kBAAmBD,oBAG3CE,EAAc,SAACtF,GACnB,IAAI+C,GACCC,GAAUA,EAAOhD,KAAOA,IACzBkD,EAAQc,QAAQhE,GAApB,CACA8E,QAAQC,IAAI,cAAe/E,GAC3B,IAAMuC,EAAOS,EAAOuC,QAAQvF,EAAI,CAAEwF,cAAe,SACjDC,EAAelD,KAGXmD,EAAgB,SAACC,EAAeC,GACpC,IAAI7C,EAAJ,CACI6C,IACF3C,EAAoB0C,GAEtB,IAAME,EAAQ3C,EAAQkB,sBACtBlB,EAAQqB,uBAAsB,SAAChC,GAC7B,IACEA,EAAKuD,KAAK,CAAEnD,SAAQgD,OAAME,QAAO/B,aACjC,MAAOrE,GACPqF,QAAQiB,MAAM,gBAAiBtG,SAK/BuG,EAAU,SAACzD,EAA2B0D,GAC1C1D,EAAKuD,KAAK,CAAEI,IAAKD,KAGbE,EAAS,uCAAG,WAAO5D,EAA2B0D,GAAlC,mBAAAG,EAAA,yDACXH,GAAsB,kBAARA,EADH,oDAEiC,kBAArCA,EAA2BI,MAFvB,wBAGNA,EAAUJ,EAAVI,MAHM,kBAKN9D,EAAK+D,eAAeC,qBAAqBF,GALnC,uBAMS9D,EAAK+D,eAAeE,eAN7B,cAMNC,EANM,iBAONlE,EAAK+D,eAAeI,oBAAoBD,GAPlC,QAQZT,EAAQzD,EAAM,CAAEkE,WARJ,kDAUZ3B,QAAQC,IAAI,yBAAZ,MAVY,mCAY0C,kBAAvCkB,EAA4BQ,OAZ/B,wBAaNA,EAAWR,EAAXQ,OAbM,oBAeNlE,EAAK+D,eAAeC,qBAAqBE,GAfnC,2DAiBZ3B,QAAQC,IAAI,0BAAZ,MAjBY,gCAoBdD,QAAQ6B,KAAK,cAAeV,GApBd,kEAAH,wDAoDTW,EAAgB,SAACrE,EAA2BsE,GAChD,IAAI9D,IACC8D,GAA8B,kBAAZA,GAAvB,CAEAV,EAAU5D,EAAOsE,EAA8BX,KAhC5B,SAAC3D,EAA2BuE,GAClB,kBAAlBA,GACT5D,EAAQS,UAAUpB,EAAMuE,GA+B1BC,CAAaxE,EAAOsE,EAAiClE,QA3BhC,SACrBJ,EACAyE,GAE+B,mBAApBA,IACT9D,EAAQW,YAAYtB,EAAMyE,GACtBA,EAGF1G,YAAW,WACT2G,EAAmB1E,KAClB,KAIHjC,YAAW,WACT4G,EAAsB3E,KACrB,MAWP4E,CAAe5E,EAAOsE,EAAmC/C,UAErD/C,MAAMqG,QAASP,EAAgChB,QAChDgB,EAAiChB,MAAMnB,SAAQ,SAAClC,ID9I1B,SAC3BR,EACAG,GAF2B,MAIT,kBAAXA,GAAuBA,EAAOkF,WAAP,UAAqBrF,EAArB,OC2IpBsF,CAActF,EAAQQ,IACxB8C,EAAY9C,MAKlB,IAAM+E,EAAarE,EAAQU,UAAUrB,GACrC,GAAIgF,EAAY,CACd,IAAMC,EAAiB,CACrB7E,OAAQ4E,EACRtF,UAAWK,EAAqBC,GAChCuB,SAAUZ,EAAQa,YAAYxB,IAEhC,IACEM,EAAagE,EAA8BlB,KAAM6B,GACjD,MAAO/H,GACPqF,QAAQiB,MAAM,cAAetG,OAK7BgG,EAAiB,SAAClD,GAClBW,EAAQQ,YAAYnB,EAAKC,MAC3BD,EAAKe,SAGPJ,EAAQE,QAAQb,GAChBA,EAAKkF,GAAG,QAAQ,WACdvE,EAAQM,cAAcjB,GACtB4C,IACIlC,GACFV,EAAKuD,KAAK,CACRnD,SACAgD,KAAM1C,EACN4C,MAAO3C,EAAQkB,sBACfN,gBAINvB,EAAKkF,GAAG,QAAQ,SAACZ,GAAD,OAAsBD,EAAcrE,EAAMsE,MAC1DtE,EAAK+D,eAAeoB,iBAAiB,oBAArC,sBAA0D,4BAAAtB,EAAA,yDACnDlD,EAAQQ,YAAYnB,EAAKC,MAD0B,iEAEpCD,EAAK+D,eAAeqB,cAFgB,cAElDtB,EAFkD,gBAGlD9D,EAAK+D,eAAeI,oBAAoBL,GAHU,OAIxDL,EAAQzD,EAAM,CAAE8D,UAJwC,4CAM1D9D,EAAK+D,eAAeoB,iBAAiB,SAAS,SAACE,GAC7C,IAAML,EAAarE,EAAQU,UAAUrB,GACrC,GAAIgF,EAAY,CACd,IAAMC,EAAO,CACX7E,OAAQ4E,EACRtF,UAAWC,EAAuBK,EAAKC,MACvCsB,SAAUZ,EAAQa,YAAYxB,IAEhCO,EAAa8E,EAAMC,MAAOL,OAG9BjF,EAAKkF,GAAG,SAAS,WAQf,GAPAvE,EAAQgB,QAAQ3B,GAChBuC,QAAQC,IAAI,wBAAyBxC,GACrCK,EAAoB,CAClByC,KAAM,oBACNpD,UAAWK,EAAqBC,KAElC4C,IAC6C,IAAzCjC,EAAQkB,sBAAsB0D,OAChCC,GAAa,QACR,GACLtF,EAAUF,EAAKC,OACfQ,IACCA,EAAOgF,eACPvF,EAAUO,EAAOhD,IAClB,CACA,IAAMG,EAAU,GAAK8H,KAAKC,MAAsB,GAAhBD,KAAKE,UACrCrD,QAAQC,IAAR,kCAC6B7C,EACzBK,EAAKC,MAFT,uBAGkBrC,EAHlB,WAKAG,WAAWyH,EAAwB,IAAV5H,SAKzBiI,EAAa,SAAbA,IAA+C,IAAjCC,EAAgC,uDA1N1B,GA2NxB,IAAItF,IACAC,EAAJ,CACAE,EAAQ0B,WACR,IAAM0D,EA9NkB,IA8NcD,GAASA,GA7NvB,GA8NlBpG,EAAYqG,EAASD,EAAQ/G,IACnCsB,EAAoB,CAAEyC,KAAM,oBAAqBpD,cACjD,IAAMjC,EAAK+B,EAAeC,EAAQC,GAClC6C,QAAQC,IAAI,mBAAoBsD,EAAOrI,GACvC,IAAMwC,EAAO,IAAI+F,IAAKvI,EAAI,CAAEwI,MAAO,IACnCxF,EAASR,EACTA,EAAKiF,GAAG,QAAQ,WACdzE,EAASR,EAITI,EAAoB,CAAEyC,KAAM,0BAC5B,IAAK,IAAIoD,EA3Oa,GA2OYA,GA1OZ,GA0OsCA,GAAK,EAAG,CAClE,IAAMC,EAAS3G,EAAeC,EAAQyG,GACtCnD,EAAYoD,OAGhBlG,EAAKiF,GAAG,SAAS,SAACkB,GACC,mBAAbA,EAAItD,MACNrC,EAAS,KACTR,EAAKoG,UACLR,EAAWC,EAAQ,IACG,qBAAbM,EAAItD,OAES,YAAbsD,EAAItD,MACbP,QAAQC,IAAI,2BAA4BsD,EAAOM,GAC/CnG,EAAKoG,YAEL9D,QAAQiB,MAAM,aAAcsC,EAAOM,EAAItD,KAAMsD,GAC7C/F,EAAoB,CAAEyC,KAAM,uBAGhC7C,EAAKiF,GAAG,cAAc,SAAClF,GACjBS,IAAWR,GAIfsC,QAAQC,IAAI,0BAA2BxC,GACvCK,EAAoB,CAClByC,KAAM,iBACNpD,UAAWK,EAAqBC,KAElCkD,EAAelD,IARbA,EAAKe,WAUTd,EAAKiF,GAAG,gBAAgB,WACtB3C,QAAQC,IAAI,0BAA2BsD,GACvC/H,YAAW,WACL0C,IAAWR,GAASA,EAAKqG,YAC3B/D,QAAQC,IAAI,0BAA2BsD,GACvCzF,EAAoB,CAAEyC,KAAM,iBAC5B7C,EAAKsG,eAEN,QAELtG,EAAKiF,GAAG,SAAS,WACXzE,IAAWR,GACbsC,QAAQC,IAAI,qCAAsCsD,GAClDrF,EAAS,KACT1C,WAAW8H,EAAY,MAEvBtD,QAAQC,IAAI,8BAA+BsD,QAIjDD,IAEA,IAAML,EAAe,SAACgB,GACpB,GAAK/F,IACDA,EAAOgF,aAAX,CACA,IAAKe,EAAO,CACV,GAAItG,EAAUO,EAAOhD,IAAK,OAE1B,IADA,IAAIgJ,GAAiB,EACZP,EAvSa,GAuSYA,GAtSZ,GAsSsCA,GAAK,EAAG,CAClE,IAAMzI,EAAK+B,EAAeC,EAAQyG,GAClC,IAAKvF,EAAQQ,YAAY1D,GAAK,CAC5BgJ,GAAiB,EACjB,OAGJ,GAAIA,EAEF,YADA7D,IAIJ,IAAM8D,EAAUjG,EAChBA,EAAS,KACTiG,EAAQL,UACRR,MA2CIc,EAAc,SAACrB,GACd3C,IACLA,EAAYgE,YAAYrB,GACxB3E,EAAQyB,iBAAR,uCAAyB,WAAOpC,GAAP,iBAAA6D,EAAA,sDACjB+C,EAAU5G,EAAK+D,eAAe8C,cAC9BC,EAASF,EAAQG,MAAK,SAACC,GAAD,OAAOA,EAAE1B,QAAUA,OAE7CtF,EAAK+D,eAAe4C,YAAYG,GAJX,2CAAzB,yDASIpC,EAAqB,SAAC1E,GACrB2C,GACLA,EAAYsE,YAAY9E,SAAQ,SAACmD,GAC/B,IACE,IAAK3C,EAAa,OAClB3C,EAAK+D,eAAemD,SAAS5B,EAAO3C,GACpC,MAAOzF,GACP,GAAe,uBAAXA,EAAEiK,KAGJ,MAAMjK,OAMRyH,EAAwB,SAAC3E,GACbA,EAAK+D,eAAe8C,aAC5B1E,SAAQ,SAAC2E,GACXA,EAAOxB,OACTtF,EAAK+D,eAAe4C,YAAYG,OAYtC,MAAO,CACL3D,gBACAiE,eAtFqB,WACjB7F,EACFgB,QAAQ6B,KAAK,6BAGf7C,GAAW,EACXoB,EAAc,IAAI0E,YAClBlE,EAAczC,KAgFd4G,gBA7EsB,WACjB/F,GAILA,GAAW,EACPoB,GACFA,EAAYsE,YAAY9E,QAAQwE,GAElChE,EAAc,KACdQ,EAAczC,IARZ6B,QAAQ6B,KAAK,8BA4Ef8C,SAjEe,SAAC5B,GACX3C,IACLA,EAAYuE,SAAS5B,GACrB3E,EAAQyB,iBAAR,uCAAyB,WAAOpC,GAAP,SAAA6D,EAAA,kEAEhBlB,EAFgB,iDAGrB3C,EAAK+D,eAAemD,SAAS5B,EAAO3C,GAHf,mDAKN,uBAAX,KAAEwE,KALe,6GAAzB,yDA+DAR,cACAY,QAbc,WACd/G,GAAW,EACPC,GACFA,EAAO4F,aCtYPmB,EAAe,IAAI5G,IACnB6G,EAAW,SACfhI,EACAW,EACAsH,EACAC,EACAC,GAEA,IAAMC,EAAY,UAAMpI,EAAN,YAAgBW,GAC9B0H,EAAQN,EAAajI,IAAIsI,GAC7B,IAAKC,EAAO,CACV,IAAMC,EAAyB,IAAIC,IAC7BC,EAAgB,IAAID,IACpBE,EAAiB,IAAIF,IAgBrBG,EAAOhI,EACXV,EACAW,GAjB0B,SAACgI,GAC3BL,EAAuB5F,SAAQ,SAACkG,GAC9BA,EAASD,SAGO,SAAChF,EAAe6B,GAClCgD,EAAc9F,SAAQ,SAACkG,GACrBA,EAASjF,EAAM6B,SAGE,SAACK,EAAyBL,GAC7CiD,EAAe/F,SAAQ,SAACkG,GACtBA,EAAS/C,EAAOL,SAUpB6C,EAAQ,CACNK,OACAJ,yBACAE,gBACAC,iBACAI,MAAO,GAETd,EAAaxG,IAAI6G,EAAcC,GAE7BJ,GACFI,EAAMC,uBAAuBQ,IAAIb,GAE/BC,GACFG,EAAMG,cAAcM,IAAIZ,GAEtBC,IACFE,EAAMI,eAAeK,IAAIX,GACS,IAA9BE,EAAMI,eAAe5F,MACvBwF,EAAMK,KAAKf,kBAGfU,EAAMQ,OAAS,EAoBf,MAAO,CACLnF,cAAe2E,EAAMK,KAAKhF,cAC1B+D,SAAUY,EAAMK,KAAKjB,SACrBP,YAAamB,EAAMK,KAAKxB,YACxB6B,WAvBiB,WACbd,GACDI,EAAoBC,uBAAuBnG,OAAO8F,GAEjDC,GACDG,EAAoBG,cAAcrG,OAAO+F,GAExCC,IACDE,EAAoBI,eAAetG,OAAOgG,GACM,IAA5CE,EAAoBI,eAAe5F,MACrCwF,EAAoBK,KAAKb,mBAG7BQ,EAAoBQ,OAAS,EACzBR,EAAoBQ,OAAS,IAC/BR,EAAoBK,KAAKZ,UAC1BC,EAAa5F,OAAOiG,OAWbY,EAAuB,SAAChJ,EAAgBW,GAAoB,IAAD,EACzBzC,qBADyB,mBAC/D+K,EAD+D,KAChDrI,EADgD,KAEtE,GAAIqI,GAAwC,kBAAvBA,EAAc5F,KACjC,MAAM,IAAI3F,MAAM,iBAMlB,OAJAW,qBAAU,WAER,OADuB2J,EAAShI,EAAQW,EAAQC,GAAxCmI,aAEP,CAAC/I,EAAQW,IACLsI,GAKIC,EAAmB,SAAClJ,EAAgBW,GAC/C,IAAMwI,EAAmBC,mBACnB1F,EAAgB2F,uBAAY,WAC5BF,EAAiBG,SACnBH,EAAiBG,QAAjB,MAAAH,EAAgB,aAIjB,IASH,OARA9K,qBAAU,WAAO,IAAD,EACiD2J,EAC7DhI,EACAW,GAFqB4I,EADT,EACN7F,cAAwCqF,EADlC,EACkCA,WAKhD,OADAI,EAAiBG,QAAUC,EACpBR,IACN,CAAC/I,EAAQW,IACL+C,GAGI8F,EAAc,SACzBxJ,EACAW,EACA8I,GACI,IAAD,EACiCvL,qBADjC,mBACIwL,EADJ,KACgBC,EADhB,KAeH,OAVAtL,qBAAU,WAQR,OADuB2J,EAAShI,EAAQW,OAAQiJ,GAN3B,SAACjG,EAAe6B,GAInC,OAHIiE,EAAY9F,IACdgG,EAAc,CAAEhG,KAAMA,EAAc6B,UAE/B,KAEDuD,aAEP,CAAC/I,EAAQW,EAAQ8I,IACbC,GCnJIG,EAAsB,uCAAG,8BAAAzF,EAAA,+EAEZ0F,UAAUC,aAAaC,mBAFX,cAE5BC,EAF4B,OAG5BC,EAAqBD,EACxB5H,QAAO,kBAAuB,eAAvB,EAAG8H,QACVlL,KAAI,kBAA0B,CAAEmL,MAA5B,EAAGA,MAAgCC,SAAnC,EAAUA,aALiB,kBAM3BH,GAN2B,yDAS3B,IAT2B,yDAAH,qDAatBI,EAAsB,uCAAG,8BAAAlG,EAAA,+EAEZ0F,UAAUC,aAAaC,mBAFX,cAE5BC,EAF4B,OAG5BC,EAAqBD,EACxB5H,QAAO,kBAAuB,eAAvB,EAAG8H,QACVlL,KAAI,kBAA0B,CAAEmL,MAA5B,EAAGA,MAAgCC,SAAnC,EAAUA,aALiB,kBAM3BH,GAN2B,yDAS3B,IAT2B,yDAAH,qD,eClBtBK,EAAQ,SAACC,GAAD,OACnB,IAAIC,SAAQ,SAAC5M,GAAD,OAAaS,WAAWT,EAAS2M,OCCzCE,EAAY,uCAAG,WAAOC,EAAqB9E,GAA5B,mCAAAzB,EAAA,yDACS,qBAAjBwG,aADQ,wBAEXC,EAAe,IAAID,aAAa/E,GAFrB,SAGX0E,EAAM,KAHK,gCAMIM,EAAaC,YANjB,cAMTC,EANS,iBAOAC,kBAAkBD,GAPlB,QAOfE,EAPe,0EASAJ,EAAaK,YATb,QASfD,EATe,sBAWXE,EAAOF,EAAOG,MACdC,EAAOJ,EAAOK,OAZH,kBAaV,CAAEL,SAAQE,OAAME,SAbN,eAebE,EAAQC,SAASC,eAAe,mBAChCC,MAAMC,QAAU,QAChBC,EAAiBL,EAAMM,UACvBC,EAAS,WACbP,EAAMM,UAAYD,GAEpBL,EAAMM,UAAYlB,EArBC,UAsBbJ,EAAM,KAtBO,eAuBbU,EAASM,EACTJ,EAAOI,EAAMQ,WACbV,EAAOE,EAAMS,YAzBA,kBA0BZ,CAAEf,SAAQE,OAAME,OAAMS,WA1BV,0DAAH,wDA6BLhB,EAAS,uCAAG,WAAOT,GAAP,+CAAAjG,EAAA,6DACjB6H,EAAc5B,EAChB,CACEkB,MAAO,CAAElB,aAEX,CAAEkB,OAAO,GALU,SAMFzB,UAAUC,aAAamC,aAAaD,GANlC,cAMjBtB,EANiB,OAOjB9E,EAAQ8E,EAAOwB,iBAAiB,GAChCC,EAASZ,SAASC,eACtB,mBAEIY,EAAMD,EAAOE,WAAW,MACxBC,EAAO,GACPC,EAAO,GACbJ,EAAOhB,MAAQmB,EACfH,EAAOd,OAASkB,EAfO,UAgBsB9B,EAAaC,EAAQ9E,GAhB3C,wBAgBfoF,EAhBe,EAgBfA,OAAQE,EAhBO,EAgBPA,KAAME,EAhBC,EAgBDA,KAAMS,EAhBL,EAgBKA,OACtBW,EAAQxG,KAAKyG,IAAIH,EAAOpB,EAAMqB,EAAOnB,GACrCD,EAAQnF,KAAK0G,IAAIxB,EAAMoB,EAAOE,GAC9BnB,EAASrF,KAAK0G,IAAItB,EAAMmB,EAAOC,GAC/BG,GAAKzB,EAAOC,GAAS,EACrByB,GAAKxB,EAAOC,GAAU,EAC5Be,EAAIS,UAAU7B,EAAQ2B,EAAGC,EAAGzB,EAAOE,EAAQ,EAAG,EAAGiB,EAAMC,GACnDV,GACFA,IAEFjG,EAAMkH,OA1BiB,kBA2BhBX,EAAOY,UAAU,cA3BD,4CAAH,sDCHhBC,EAAc,SAACL,GAAD,OAClBA,GACa,kBAANA,GACoC,kBAAnCA,EAAyBM,OAThB,SAACN,GAAD,OACjBA,GACa,kBAANA,GAC0C,kBAAzCA,EAA4BO,UACW,kBAAvCP,EAA2BQ,QAMnCC,CAAYT,EAAwBpH,O,OC9BzB8H,EAAc,uCAAG,WAAOjD,GAAP,6CAAAjG,EAAA,6DACtB6H,EAAc5B,EAChB,CACEkB,MAAO,CAAElB,aAEX,CAAEkB,OAAO,GALe,SAMPzB,UAAUC,aAAamC,aAAaD,GAN7B,cAMtBtB,EANsB,OAOtB9E,EAAQ8E,EAAOwB,iBAAiB,IAChCZ,EAAQC,SAASC,eAAe,mBAChCC,MAAMC,QAAU,QACtBJ,EAAMM,UAAYlB,EAVU,UAWtBJ,EAAM,KAXgB,eAYtBY,EAAOI,EAAMQ,WACbV,EAAOE,EAAMS,YACbI,EAASZ,SAASC,eACtB,mBAEIY,EAAMD,EAAOE,WAAW,MACjB,GACA,GACbF,EAAOhB,MAFM,GAGbgB,EAAOd,OAFM,GAGPmB,EAAQxG,KAAKyG,IAJN,GAIiBvB,EAHjB,GAG8BE,GACrCD,EAAQnF,KAAK0G,IAAIxB,EALV,GAKuBsB,GAC9BnB,EAASrF,KAAK0G,IAAItB,EALX,GAKwBoB,GAC/BG,GAAKzB,EAAOC,GAAS,EACrByB,GAAKxB,EAAOC,GAAU,EACtBiC,EAAQC,aAAY,WACxBnB,EAAIS,UAAUvB,EAAOqB,EAAGC,EAAGzB,EAAOE,EAAQ,EAAG,EAVlC,GACA,MAUV,IAAO,IACJmC,EAAgBrB,EAAesB,gBAC/B5F,EAAU,WACdyD,EAAMG,MAAMC,QAAU,OACtBgC,cAAcJ,GACd1H,EAAMkH,OACNU,EAAatB,iBAAiB,GAAGY,QAnCP,kBAqCrB,CACLpC,OAAQ8C,EACR3F,YAvC0B,4CAAH,sDCFd8F,EAAc,uCAAG,WAAOvD,GAAP,qBAAAjG,EAAA,6DACtB6H,EAAc5B,EAChB,CACEwD,MAAO,CAAExD,aAEX,CAAEwD,OAAO,GALe,SAMP/D,UAAUC,aAAamC,aAAaD,GAN7B,cAMtBtB,EANsB,OAOtB9E,EAAQ8E,EAAOmD,iBAAiB,GAPV,SAQtBjI,EAAMkI,iBAAiB,CAC3BC,kBAAkB,EAClBC,qBAAsB,CAAEC,MAAO,UAC/BC,iBAAkB,CAAED,OAAO,KAXD,cAatBpG,EAAU,WACdjC,EAAMkH,QAdoB,kBAgBrB,CACLpC,SACA7C,YAlB0B,2CAAH,sDCMrBsG,EAAwB,SAC5BvI,EACA8E,GAEA,IAAM0D,EAAY1D,EAASA,EAAO2D,QAAU,IAAI1G,YAEhD,OADAyG,EAAU5G,SAAS5B,GACZwI,GAGHE,EAA2B,SAC/B1I,EACA8E,GAKA,IAAM0D,EAAY,IAAIzG,YAQtB,OAPI+C,GACFA,EAAOnD,YAAY9E,SAAQ,SAAC8L,GACtBA,IAAM3I,GACRwI,EAAU5G,SAAS+G,MAIrBH,EAAU7G,YAAY1B,OAAS,EAC1BuI,EAEF,MAGII,EAAgB,SAC3BzO,EACAW,EACA+N,EACAC,EACAC,EACAC,GACI,IAAD,EACiC3Q,mBAA6B,MAD9D,mBACI4Q,EADJ,KACgBC,EADhB,OAEuC7Q,mBAEvC,IAJA,mBAEI8Q,EAFJ,KAEmBC,EAFnB,OPgHuB,SAC1BjP,EACAW,EACAuO,GACI,IAAD,EAC+BhR,mBAG/B,IAJA,mBACIiR,EADJ,KACeC,EADf,OAKmClR,mBAG5B,MARP,mBAKImR,EALJ,KAKiBC,EALjB,KAkCH,OAzBAjR,qBAAU,WACR,GAAI6Q,EAAS,CACX,IAGMK,EAASvH,EACbhI,EACAW,OACAiJ,OACAA,GAPoB,SAAC/D,EAAyBL,GAC9C8J,EAAe,CAAEzJ,QAAOL,YAa1B,OAJA4J,EAAa,CACX3H,SAAU8H,EAAO9H,SACjBP,YAAaqI,EAAOrI,cAEf,WACLkI,EAAa,IACbG,EAAOxG,cAIXuG,EAAe,QAEd,CAACtP,EAAQW,EAAQuO,IACb,eAAKC,EAAZ,CAAuBE,gBOjJwBG,CAC7CxP,EACAW,EACA+N,GAAgBC,GAHVlH,EALL,EAKKA,SAAUP,EALf,EAKeA,YAAamI,EAL5B,EAK4BA,YAOzBI,EAAarG,iBAAoB,IA8FvC,OA7FA/K,qBAAU,WAIR,OAHgB,WACdoR,EAAWnG,QAAQ5G,SAAQ,SAACgN,GAAD,OAAQA,UAGpC,IAEHrR,qBAAU,WACR,GAAKgR,EAAL,CADc,IAENxJ,EAAgBwJ,EAAhBxJ,MAAOL,EAAS6J,EAAT7J,KACfyJ,GAAiB,SAACU,GAAD,sBACZA,EADY,eAEdnK,EAAK7E,OAASyN,EAAsBvI,EAAO8J,EAAKnK,EAAK7E,cAExD,IAUIiP,EAVEC,EAAU,WACdZ,GAAiB,SAACU,GAAD,sBACZA,EADY,eAEdnK,EAAK7E,OAAS4N,EAAyB1I,EAAO8J,EAAKnK,EAAK7E,eAG7DkF,EAAMH,iBAAiB,QAASmK,GAKhC,IAAMC,EAAS,WACbC,aAAaH,GACbA,EAAUtR,YAAW,WACnB2Q,GAAiB,SAACU,GAAD,sBACZA,EADY,eAEdnK,EAAK7E,OAAS4N,EAAyB1I,EAAO8J,EAAKnK,EAAK7E,gBAE1D,MAELkF,EAAMH,iBAAiB,OAAQoK,GAC/B,IAAME,EAAW,WACfD,aAAaH,IAEf/J,EAAMH,iBAAiB,SAAUsK,GACjCP,EAAWnG,QAAQ2G,MAAK,WACtBpK,EAAMqK,oBAAoB,QAASL,GACnCE,aAAaH,GACb/J,EAAMqK,oBAAoB,OAAQJ,GAClCjK,EAAMqK,oBAAoB,SAAUF,SAErC,CAACX,IAEJhR,qBAAU,WACR,IAAIyJ,EAA+B,KAiBnC,OAhBI4G,GAAgBjH,GAAYP,GAC9B,sBAAC,kCAAA9C,EAAA,sEAIWkJ,EAAesB,GAJ1B,gBAEWuB,EAFX,EAEGxF,OACSyF,EAHZ,EAGGtI,QAEIuI,EAAaF,EAAYhE,iBAAiB,GAChD1E,EAAS4I,GACTtB,GAAc,SAACY,GAAD,OAAUvB,EAAsBiC,EAAYV,MAC1D7H,EAAU,WACRiH,GAAc,SAACY,GAAD,OAAUpB,EAAyB8B,EAAYV,MAC7DzI,EAAYmJ,GACZD,KAXH,0CAAD,GAeK,WACDtI,GAASA,OAEd,CAAC9H,EAAQ0O,EAAcE,EAAenH,EAAUP,IAEnD7I,qBAAU,WACR,IAAIyJ,EAA+B,KAiBnC,OAhBI6G,GAAgBlH,GAAYP,GAC9B,sBAAC,kCAAA9C,EAAA,sEAIWwJ,EAAeiB,GAJ1B,gBAEWyB,EAFX,EAEG3F,OACS4F,EAHZ,EAGGzI,QAEI0I,EAAaF,EAAYxC,iBAAiB,GAChDrG,EAAS+I,GACTzB,GAAc,SAACY,GAAD,OAAUvB,EAAsBoC,EAAYb,MAC1D7H,EAAU,WACRiH,GAAc,SAACY,GAAD,OAAUpB,EAAyBiC,EAAYb,MAC7DzI,EAAYsJ,GACZD,KAXH,0CAAD,GAeK,WACDzI,GAASA,OAEd,CAAC9H,EAAQ2O,EAAcE,EAAepH,EAAUP,IAE5C,CAAE4H,aAAYE,kBC5IjByB,EAAYC,IAAMC,MAQrB,YAA4E,IAAzEzD,EAAwE,EAAxEA,MAAOC,EAAiE,EAAjEA,SAAUyD,EAAuD,EAAvDA,WAAYC,EAA2C,EAA3CA,UAAW/O,EAAgC,EAAhCA,SAAU6I,EAAsB,EAAtBA,OAAQmG,EAAc,EAAdA,QACxDC,EAAW3H,iBAAyB,MAC1C/K,qBAAU,WACJsM,GAAUoG,EAASzH,UACrByH,EAASzH,QAAQuC,UAAYlB,KAE9B,CAACA,IACJ,IAAMqG,IAAarG,GAAUA,EAAOwB,iBAAiBrG,OAAS,EACxDmL,IAAatG,GAAUA,EAAOmD,iBAAiBhI,OAAS,EAC9D,OACE,yBAAKoL,UAAU,kBAAkBxF,MAAO,CAAEyF,QAASN,EAAY,GAAM,IAClE/O,GAAY6I,EACX,2BACEuG,UAAU,mBACVE,IAAKL,EACLM,UAAQ,EACRC,OAAQR,IAGV,yBACES,IAAKrE,GA9Bb,qHA+BQgE,UAAU,mBACVM,IAAI,WAGR,yBAAKN,UAAU,mBAAmB/D,GAClC,yBAAK+D,UAAU,mBAAmBN,GACjC9O,GAAYkP,GAAYC,GACvB,yBAAKC,UAAU,4BAA4BO,MAAM,kBAAjD,UAID3P,GAAYkP,IAAaC,GACxB,yBAAKC,UAAU,4BAA4BO,MAAM,YAAjD,WAIAZ,GAAa/O,IAAa6I,GAC1B,yBAAKuG,UAAU,4BAA4BO,MAAM,YAAjD,cAoEOf,MAAMC,MAlDe,SAAC,GAQ9B,IAPL3Q,EAOI,EAPJA,OACAW,EAMI,EANJA,OACAwM,EAKI,EALJA,SACAyD,EAII,EAJJA,WACAc,EAGI,EAHJA,SACA9C,EAEI,EAFJA,cACAC,EACI,EADJA,cACI,EJ/CuB,SAC3B7O,EACAW,EACAwM,EACAyD,EACAvG,GACI,IAAD,EAC2BnM,qBAD3B,mBACIyT,EADJ,KACaC,EADb,OAEiC1T,mBAAsB,IAFvD,mBAEI2T,EAFJ,KAEgBC,EAFhB,OAGiC5T,qBAHjC,mBAGI6T,EAHJ,KAGgBC,EAHhB,KAIGC,EAAW7I,iBAAO,CAAE+D,WAAUC,QAASwD,IAG7C,GAFAqB,EAAS3I,QAAU,CAAE6D,WAAUC,QAASwD,GAEpCmB,EACF,MAAMA,EAGR,IAAMrO,EAAgBwF,EAAiBlJ,EAAQW,GACzC+I,EAAaF,EAAuBxJ,EAAQW,EAAQsM,GAC1D5O,qBAAU,WACR,GAAIqL,EAAY,CACd,IAAMwI,EAAS,eACVxI,EAAW/F,KADD,CAEbhD,OAAQ+I,EAAWlE,KAAK7E,OACxBwR,SAAUC,KAAKC,MACfxB,WAAW,EACX/O,SAAU4H,EAAWlE,KAAK1D,SAC1B7B,UAAWyJ,EAAWlE,KAAKvF,YAE7B6R,GAAc,SAACnC,GAEb,OADcA,EAAKrI,MAAK,SAACgL,GAAD,OAAUA,EAAK3R,SAAWuR,EAAUvR,UAIrDgP,EAAK1Q,KAAI,SAACqT,GAAD,OACdA,EAAK3R,SAAWuR,EAAUvR,OAASuR,EAAYI,KAHzC,GAAN,mBAAW3C,GAAX,CAAiBuC,UAOtB,CAACxI,IAEJ,IAAMT,EAAgBD,EAAqBhJ,EAAQW,GAgEnD,OA/DAtC,qBAAU,WACR,GAAI4K,GAAwC,sBAAvBA,EAAc5F,KAA8B,CAAC,IACxDpD,EAAcgJ,EAAdhJ,UACR6R,GAAc,SAACnC,GACb,IAAI4C,GAAU,EACRC,EAAO7C,EAAK1Q,KAAI,SAACqT,GACrB,OAAIA,EAAKrS,YAAcA,GACrBsS,GAAU,EACH,eAAKD,EAAZ,CAAkBzB,WAAW,KAExByB,KAET,OAAOC,EAAUC,EAAO7C,QAG3B,CAAC1G,IAEJ5K,qBAAU,WACR,IAAMoU,EAAsB,WAC1B,IAAMC,EAAYN,KAAKC,MAAQ,KACzBM,EAAYP,KAAKC,MAAQ,IAC/BP,GAAc,SAACnC,GACb,IAAI4C,GAAU,EACRC,EAAO7C,EACV1Q,KAAI,SAACqT,GACJ,OAAIA,EAAKH,SAAWO,IAAcJ,EAAKzB,WACrC0B,GAAU,EACH,eAAKD,EAAZ,CAAkBzB,WAAW,KAE3ByB,EAAKH,SAAWQ,GAAaL,EAAKzB,WACpC0B,GAAU,EACH,MAEFD,KAERjQ,QAAO,SAACiQ,GAAD,OAAUA,KAEpB,OAAOC,EAAUC,EAAO7C,MAGtBiD,EAAI,uCAAG,8BAAAxO,EAAA,sEAETqO,IAFS,SAGW3H,EAAUT,GAHrB,OAGH6C,EAHG,OAIT0E,EAAW1E,GACLvJ,EAAO,CACXhD,SACAuM,QACA1H,KAAMyM,EAAS3I,SAEjB5F,EAAcC,GAAM,GAVX,kDAYTb,QAAQiB,MAAR,MACAiO,EAAc,EAAD,IAbJ,0DAAH,qDAgBVY,IACA,IAAMrF,EAAQC,YAAYoF,EAAM,MAChC,OAAO,WACL7C,aAAaxC,MAEd,CAACvN,EAAQW,EAAQ0J,EAAU3G,IAEvB,CACLiO,UACAE,cI3D8BgB,CAC9B7S,EACAW,EACAwM,EACAyD,EACAhC,GALM+C,EADJ,EACIA,QAASE,EADb,EACaA,WADb,EAQkCpD,EACpCzO,EACAW,EACa,UAAb+Q,GAAqC,gBAAbA,EACX,gBAAbA,EACA9C,EACAC,GANMC,EARJ,EAQIA,WAAYE,EARhB,EAQgBA,cASpB,OACE,yBAAKkC,UAAU,uBACb,kBAACT,EAAD,CACEvD,MAAOyE,EACPxE,SAAUA,EACVyD,WAAYA,EACZ9O,SAAuB,QAAb4P,EACV/G,OAAQmE,QAAclF,IAEvBiI,EAAW5S,KAAI,SAACqT,GAAD,OACd,kBAAC7B,EAAD,CACEqC,IAAKR,EAAK3R,OACVuM,MAAOoF,EAAKpF,MACZC,SAAUmF,EAAK9M,KAAK2H,SACpByD,WAAY0B,EAAK9M,KAAK4H,QACtByD,UAAWyB,EAAKzB,UAChB/O,SAAUwQ,EAAKxQ,SACf6I,OAAQqE,EAAcsD,EAAK3R,cAAWiJ,EACtCkH,QAAsB,gBAAbY,WCnGbqB,G,MAAa,SAACnG,GAAD,OACjBA,GACa,kBAANA,GACsC,kBAArCA,EAA0BjM,QACe,kBAAzCiM,EAA4BO,UACW,kBAAvCP,EAA2BoG,SACc,kBAAzCpG,EAA4BqG,WACwB,qBAAnDrG,EAAiCsG,eAE1B,kBADNtG,EAA6CsG,cAClDvS,QAEY,kBADPiM,EAA8CsG,cACnDF,WAYDG,EAAe,SAAC/O,EAAUlF,GAC9B,IAAMkU,EAAYlU,EAAE,GAAKkF,EAAE,GAC3B,OAAkB,IAAdgP,EACKhP,EAAE,GAAG0B,OAAS5G,EAAE,GAAG4G,OAErBsN,GCrCHC,EAAY,CAAC,eAAM,eAAM,eAAM,eAAM,gBAErCC,EAGD,SAAC,GAAD,IAAGC,EAAH,EAAGA,KAAMC,EAAT,EAASA,QAAT,OACH,4BAAQnQ,KAAK,SAASmQ,QAAS,kBAAMA,EAAQD,KAC3C,0BAAME,aAAW,YAAYF,KAI3BG,EAAuBhD,IAAMC,MAGhC,gBAAGgD,EAAH,EAAGA,SAAUC,EAAb,EAAaA,UAAb,OACD,wBAAI1C,UAAU,sBACXyC,EAAS1U,KAAI,SAACqT,GACb,IAAMuB,EAAQ,SAACN,GAAD,OAAkBK,EAAUL,EAAMjB,EAAKwB,UACrD,OACE,wBAAIhB,IAAKR,EAAKQ,IAAK5B,UAAU,0BAC3B,yBAAKA,UAAU,iCACb,yBAAKA,UAAU,sCACb,yBAAKA,UAAU,4BACZmC,EAAUpU,KAAI,SAACsU,GAAD,OACb,kBAAC,EAAD,CAAgBT,IAAKS,EAAMA,KAAMA,EAAMC,QAASK,SAItD,yBAAK3C,UAAU,0BACZoB,EAAKnF,UAAY,YAGtB,6BAAMmF,EAAKiB,MACVjB,EAAKyB,QAAQ9U,KAAI,mCAAEsU,EAAF,KAAQ1K,EAAR,YAChB,yBAAKqI,UAAU,kBACZqC,EADH,IACU1K,cAgDP6H,MAAMC,MAjCkB,SAAC,GAAkC,IAAD,EDVzC,SAC9B3Q,EACAW,EACAwM,GAEA,IAAM6G,EAAa5K,iBAAO,GACpB6K,EAAiB7K,iBAAO,IAAIjI,KAF/B,EAG6BjD,mBAAqB,IAHlD,mBAGIyV,EAHJ,KAGcO,EAHd,KAKGC,EAAc9K,uBAAY,SAAC+K,GAC/B,IAAKH,EAAe3K,QAAQxJ,IAAIsU,EAASzT,SAAW,GAAKyT,EAASpB,QAKlE,GAJEiB,EAAe3K,QAAQ/H,IAAI6S,EAASzT,OAAQyT,EAASpB,SAInDoB,EAASlB,cAAe,CAAC,IACnBD,EAA4BmB,EAA5BnB,SAAUC,EAAkBkB,EAAlBlB,cAClBgB,GAAY,SAACvE,GAAD,OACVA,EAAK1Q,KAAI,SAACqT,GACR,GACEA,EAAKwB,QAAQnT,SAAWuS,EAAcvS,QACtC2R,EAAKwB,QAAQd,UAAYE,EAAcF,QACvC,CACA,IAAMqB,EAAW,IAAIlT,IAAImR,EAAKyB,SAC9BM,EAAS9S,IAAI0R,GAAWoB,EAASvU,IAAImT,IAAa,GAAK,GACvD,IAAMc,EAAO,YAAOM,EAASC,WAE7B,OADAP,EAAQQ,KAAKpB,GACN,eAAKb,EAAZ,CAAkByB,YAEpB,OAAOzB,YAGN,CACL,IAAMkC,EAAqB,CACzB1B,IAAI,GAAD,OAAKsB,EAASzT,OAAd,YAAwByT,EAASpB,SACpCc,QAAS,CACPnT,OAAQyT,EAASzT,OACjBqS,QAASoB,EAASpB,SAEpB7F,SAAUiH,EAASjH,SACnBoG,KAAMa,EAASnB,SACfc,QAAS,IAEXG,GAAY,SAACvE,GAAD,MAAU,CAAC6E,GAAD,mBAAc7E,IAAM/P,MAAM,EAvF3B,WAyFtB,IAEG8D,EAAgBwF,EAAiBlJ,EAAQW,GACzC4O,EAAS/F,EAAsBxJ,EAAQW,EAAQoS,GAsCrD,OArCA1U,qBAAU,WACJkR,GACF4E,EAAY5E,EAAO5L,SAmChB,CACLgQ,WACAc,SAjCepL,uBACf,SAACkK,GACC,IAAM5P,EAAiB,CACrBhD,SACAwM,WACA6F,QAASgB,EAAW1K,QACpB2J,SAAUM,GAEZS,EAAW1K,SAAW,EACtB5F,EAAcC,GACdwQ,EAAYxQ,KAEd,CAACD,EAAe/C,EAAQwM,EAAUgH,IAsBlCP,UAnBgBvK,uBAChB,SAACkK,EAAcmB,GACb,IAAM/Q,EAAiB,CACrBhD,SACAwM,WACA6F,QAASgB,EAAW1K,QACpB2J,SAAUM,EACVL,cAAewB,GAEjBV,EAAW1K,SAAW,EACtB5F,EAAcC,GACdwQ,EAAYxQ,KAEd,CAACD,EAAe/C,EAAQwM,EAAUgH,KCxEMQ,CAD6B,EAA/B3U,OAA+B,EAAvBW,OAAuB,EAAfwM,UAChDwG,EAD+D,EAC/DA,SAAUc,EADqD,EACrDA,SAAUb,EAD2C,EAC3CA,UAD2C,EAO/C1V,mBAAS,IAPsC,mBAOhEqV,EAPgE,KAO1DqB,EAP0D,KAgBvE,OACE,yBAAK1D,UAAU,2BACb,0BAAM2D,SAVO,SAACjP,GAChBA,EAAMkP,iBACFvB,IACFkB,EAASlB,GACTqB,EAAQ,OAON,2BACEvT,MAAOkS,EACPwB,SAAU,SAACtX,GAAD,OAAOmX,EAAQnX,EAAEuX,OAAO3T,QAClC4T,YAAY,uBAEd,4BAAQ5R,KAAK,SAAS6R,UAAW3B,GAAjC,SAIF,kBAACG,EAAD,CAAsBC,SAAUA,EAAUC,UAAWA,QCrErDuB,ECLuB,SAACzN,GAC5B,IACE,OAAOnJ,OAAO6W,aAAaC,QAAQ3N,IAAS,GAC5C,MAAOjK,GAEP,MAAO,IDAa6X,CAAc,YAgHvBC,GA9GqB,SAAC,GAAwB,IAAtBvV,EAAqB,EAArBA,OAAQW,EAAa,EAAbA,OAAa,EAC1BzC,mBAASiX,GADiB,mBACnDhI,EADmD,KACzCqI,EADyC,OAEtBtX,mBAAS,IAFa,mBAEnD0S,EAFmD,KAEvC6E,EAFuC,KAG1DpX,qBAAU,YdNkB,SAAC2B,GAC7B,IAAMN,EAAOnB,OAAOC,SAASkB,KAAKE,MAAM,GAClC8V,EAAe,IAAI7V,gBAAgBH,GACzCgW,EAAanU,IAAI,SAAUvB,GAC3BzB,OAAOC,SAASkB,KAAOgW,EAAavW,WcGlCwW,CAAe3V,KACd,CAACA,IAEJ,IAAM4V,EEbuB,WAAO,IAAD,EACL1X,mBAA8B,IADzB,mBAC5B+L,EAD4B,KACnB4L,EADmB,KAQnC,OANAxX,qBAAU,WACR,sBAAC,4BAAA+F,EAAA,sEAC8ByF,IAD9B,OACOiM,EADP,OAECD,EAAWC,GAFZ,0CAAD,KAIC,IACI7L,EFKc8L,GACfC,EEGuB,WAAO,IAAD,EACL9X,mBAA8B,IADzB,mBAC5B+L,EAD4B,KACnB4L,EADmB,KAQnC,OANAxX,qBAAU,WACR,sBAAC,4BAAA+F,EAAA,sEAC8BkG,IAD9B,OACOwL,EADP,OAECD,EAAWC,GAFZ,0CAAD,KAIC,IACI7L,EFXcgM,GARqC,EAShB/X,qBATgB,mBASnD0Q,EATmD,KASpCsH,EAToC,OAUhBhY,qBAVgB,mBAUnD2Q,EAVmD,KAUpCsH,EAVoC,OAW1BjY,mBAAmB,OAXO,mBAWnDwT,EAXmD,KAWzC0E,EAXyC,OAYtBlY,oBAAkB,GAZI,mBAYnDmY,EAZmD,KAYvCC,EAZuC,KAcpDrN,EAAgBD,EAAqBhJ,EAAQW,GAE7C4V,EAAO,yBAAqBhY,OAAOC,SAASgY,KAAKC,QACrD,cACA,KAGF,OACE,oCACE,yBAAKvF,UAAU,qBAAqBwF,KAAKC,UAAU1N,IACnD,yBAAKiI,UAAU,wBACZmF,EACC,oCACE,4BAAQhT,KAAK,SAASmQ,QAAS,kBAAM8C,GAAc,KAAnD,eAGA,kDAEE,2BAAOjV,MAAO9C,OAAOC,SAASgY,KAAMI,UAAQ,IAF9C,yCAIE,uBAAGJ,KAAMD,GAAT,aAEF,yBAAKrF,UAAU,uBAAf,aACa,IACX,2BACE2F,aAAc1B,EACdJ,SAAU,SAACtX,GACT+X,EAAY/X,EAAEuX,OAAO3T,OCxDV,SAACqG,EAAsBrG,GAClD,IACE9C,OAAO6W,aAAa0B,QAAQpP,EAAMrG,GAClC,MAAO5D,GACPqF,QAAQC,IAAI,wCAAyCtF,IDqDvCsZ,CAAc,WAAYtZ,EAAEuX,OAAO3T,WAIzC,yBAAK6P,UAAU,yBAAf,eACe,IACb,2BACE6D,SAAU,SAACtX,GACTgY,EAAchY,EAAEuX,OAAO3T,QAEzB4T,YAAY,0BAGhB,8CACiB,IACf,4BAAQF,SAAU,SAACtX,GAAD,OAAOyY,EAAiBzY,EAAEuX,OAAO3T,SAChDuU,EAAa3W,KAAI,SAAC+X,GAAD,OAChB,4BACElE,IAAKkE,EAAY3M,SACjBhJ,MAAO2V,EAAY3M,UAElB2M,EAAY5M,YAKrB,2CACc,IACZ,4BAAQ2K,SAAU,SAACtX,GAAD,OAAO0Y,EAAiB1Y,EAAEuX,OAAO3T,SAChD2U,EAAa/W,KAAI,SAACgY,GAAD,OAChB,4BACEnE,IAAKmE,EAAY5M,SACjBhJ,MAAO4V,EAAY5M,UAElB4M,EAAY7M,YAKrB,0CACa,IACX,4BAAQ2K,SAAU,SAACtX,GAAD,OAAO2Y,EAAY3Y,EAAEuX,OAAO3T,SAC5C,4BAAQA,MAAM,OAAd,OACA,4BAAQA,MAAM,SAAd,cACA,4BAAQA,MAAM,eAAd,sBAKN,4BAAQgC,KAAK,SAASmQ,QAAS,kBAAM8C,GAAc,KAAnD,gBAKJ,kBAAC,EAAD,CACEtW,OAAQA,EACRW,OAAQA,EACRiO,cAAeA,EACfC,cAAeA,EACf1B,SAAUA,EACVyD,WAAYA,EACZc,SAAUA,IAEZ,kBAAC,EAAD,CAAe1R,OAAQA,EAAQW,OAAQA,EAAQwM,SAAUA,MGrHzD+J,GjBG0B,WAC9B,IAAMxX,EAAOnB,OAAOC,SAASkB,KAAKE,MAAM,GAExC,OADqB,IAAIC,gBAAgBH,GACrBI,IAAI,UiBNJqX,GAChBxW,GAASjC,IAwCA0Y,GAtCsB,WAAO,IAAD,EACblZ,mBAAwBgZ,IADX,mBAClClX,EADkC,KAC1BqX,EAD0B,OAETnZ,mBAAS,IAFA,mBAElCoZ,EAFkC,KAExBC,EAFwB,KAYzC,OAAIvX,EACK,kBAAC,GAAD,CAAYA,OAAQA,EAAQW,OAAQA,KAI3C,yBAAKuQ,UAAU,2BACb,4BAAQ7N,KAAK,SAASmQ,QAdN,WAClB6D,EAAU3Y,OAaR,qBADF,KAKE,2BACE2C,MAAOiW,EACPvC,SAAU,SAACtX,GAAD,OAAO8Z,EAAY9Z,EAAEuX,OAAO3T,QACtC4T,YAAY,uBAEd,4BACE5R,KAAK,SACLmQ,QArBU,WACd6D,EAAU7X,EAAsB8X,KAqB5BpC,UAAW1V,EAAsB8X,IAHnC,gBC/BAE,I,kNACJC,MAAQ,CAAEC,UAAU,G,uDAMV,IACAC,EAAaC,KAAKC,MAAlBF,SAER,OADqBC,KAAKH,MAAlBC,SACa,kBAAC,EAAD,MACdC,K,kDAPP,MAAO,CAAED,UAAU,O,GAJKhH,IAAMoH,YAuBnBC,GARO,kBACpB,yBAAK7G,UAAU,OACb,kBAAC,GAAD,KACE,kBAAC,GAAD,SCZc8G,QACW,cAA7BzZ,OAAOC,SAASyZ,UAEe,UAA7B1Z,OAAOC,SAASyZ,UAEhB1Z,OAAOC,SAASyZ,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,GAAD,OAEF7M,SAASC,eAAe,SD8HpB,kBAAmB3B,WACrBA,UAAUwO,cAAcC,MACrBC,MAAK,SAACC,GACLA,EAAa1P,gBAEd2P,OAAM,SAAC3U,GACNjB,QAAQiB,MAAMA,EAAMqJ,c","file":"static/js/main.ebf1dd2c.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 25;","import React, { useEffect, useState } from \"react\";\n\nconst ErrorFallback: React.FC = () => {\n  const [waitSec, setWaitSec] = useState(30);\n\n  useEffect(() => {\n    if (waitSec > 0) {\n      setTimeout(() => {\n        setWaitSec(waitSec - 1);\n      }, 1000);\n    } else {\n      window.location.reload();\n    }\n  });\n\n  return (\n    <div>\n      <h1>Unrecoverable error occurred.</h1>\n      <p>Will auto reload in {waitSec} sec.</p>\n    </div>\n  );\n};\n\nexport default ErrorFallback;\n","export const sha256 = async (text: string) => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(text);\n  const buf = await window.crypto.subtle.digest(\"SHA-256\", data);\n  const arr = Array.from(new Uint8Array(buf));\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const secureRandomId = () => {\n  const arrbuf = window.crypto.getRandomValues(new Uint8Array(32));\n  const arr = Array.from(arrbuf);\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const rand4 = () => {\n  const rand = window.crypto.getRandomValues(new Uint16Array(1))[0];\n  return 1000 + (rand % 9000);\n};\n","export const extractRoomIdFromLink = (link: string) => {\n  try {\n    const hash = new URL(link).hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    return searchParams.get(\"roomId\");\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const getRoomIdFromUrl = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  return searchParams.get(\"roomId\");\n};\n\nexport const setRoomIdToUrl = (roomId: string) => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  searchParams.set(\"roomId\", roomId);\n  window.location.hash = searchParams.toString();\n};\n","import Peer from \"peerjs\";\n\nexport const isValidPeerId = (\n  roomId: string,\n  peerId: unknown\n): peerId is string =>\n  typeof peerId === \"string\" && peerId.startsWith(`${roomId}_`);\n\nexport const generatePeerId = (roomId: string, peerIndex: number) =>\n  `${roomId}_${peerIndex}`;\n\nexport const getPeerIndexFromPeerId = (peerId: string) =>\n  Number(peerId.split(\"_\")[1]);\n\nexport const getPeerIndexFromConn = (conn: Peer.DataConnection) =>\n  getPeerIndexFromPeerId(conn.peer);\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Peer.DataConnection;\n    connected?: boolean;\n    userId?: string;\n    liveMode?: boolean;\n  };\n  const map = new Map<string, Value>();\n\n  const addConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.conn.close();\n    }\n    map.set(conn.peer, { conn });\n  };\n\n  const markConnected = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.connected = true;\n    }\n  };\n\n  const isConnected = (peerId: string) => {\n    const value = map.get(peerId);\n    return (value && value.connected) || false;\n  };\n\n  const setUserId = (conn: Peer.DataConnection, userId: string) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.userId = userId;\n    }\n  };\n\n  const getUserId = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    return value && value.userId;\n  };\n\n  const setLiveMode = (conn: Peer.DataConnection, liveMode: boolean) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.liveMode = liveMode;\n    }\n  };\n\n  const getLiveMode = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    return (value && value.liveMode) || false;\n  };\n\n  const hasConn = (peerId: string) => map.has(peerId);\n\n  const delConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n    }\n  };\n\n  const getConnectedPeerIds = () =>\n    Array.from(map.keys()).filter((k) => map.get(k)?.connected);\n\n  const forEachConnectedConns = (\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.connected) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const forEachLiveConns = (callback: (conn: Peer.DataConnection) => void) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.connected && value.liveMode) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const clearAll = () => {\n    if (map.size) {\n      console.log(\"connectionMap garbage:\", map);\n    }\n    map.clear();\n  };\n\n  return {\n    addConn,\n    markConnected,\n    isConnected,\n    setUserId,\n    getUserId,\n    setLiveMode,\n    getLiveMode,\n    hasConn,\n    delConn,\n    getConnectedPeerIds,\n    forEachConnectedConns,\n    forEachLiveConns,\n    clearAll,\n  };\n};\n","import Peer from \"peerjs\";\n\nimport { rand4 } from \"../utils/crypto\";\nimport {\n  isValidPeerId,\n  generatePeerId,\n  getPeerIndexFromPeerId,\n  getPeerIndexFromConn,\n  createConnectionMap,\n} from \"./peerUtils\";\n\nconst MIN_SEED_PEER_INDEX = 10; // config\nconst MAX_SEED_PEER_INDEX = 14; // config\nconst guessSeed = (id: string) => {\n  const peerIndex = getPeerIndexFromPeerId(id);\n  return MIN_SEED_PEER_INDEX <= peerIndex && peerIndex <= MAX_SEED_PEER_INDEX;\n};\n\nexport type NetworkStatus =\n  | { type: \"CONNECTING_SEED_PEERS\" }\n  | { type: \"NEW_CONNECTION\"; peerIndex: number }\n  | { type: \"CONNECTION_CLOSED\"; peerIndex: number }\n  | { type: \"INITIALIZING_PEER\"; peerIndex: number }\n  | { type: \"RECONNECTING\" }\n  | { type: \"UNKNOWN_ERROR\" }\n  | { type: \"CONNECTED_PEERS\"; peerIndexList: number[] };\n\ntype UpdateNetworkStatus = (status: NetworkStatus) => void;\n\nexport type PeerInfo = { userId: string; peerIndex: number; liveMode: boolean };\ntype ReceiveData = (data: unknown, info: PeerInfo) => void;\ntype ReceiveTrack = (track: MediaStreamTrack, info: PeerInfo) => void;\n\nexport const createRoom = (\n  roomId: string,\n  userId: string,\n  updateNetworkStatus: UpdateNetworkStatus,\n  receiveData: ReceiveData,\n  receiveTrack: ReceiveTrack\n) => {\n  let disposed = false;\n  let myPeer: Peer | null = null;\n  let lastBroadcastData: unknown | null = null;\n  const connMap = createConnectionMap();\n  let liveMode = false;\n  let localStream: MediaStream | null = null;\n\n  const showConnectedStatus = () => {\n    if (disposed) return;\n    const peerIndexList = connMap\n      .getConnectedPeerIds()\n      .map(getPeerIndexFromPeerId);\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const connectPeer = (id: string) => {\n    if (disposed) return;\n    if (!myPeer || myPeer.id === id) return;\n    if (connMap.hasConn(id)) return;\n    console.log(\"connectPeer\", id);\n    const conn = myPeer.connect(id, { serialization: \"json\" });\n    initConnection(conn);\n  };\n\n  const broadcastData = (data: unknown, replaceLastData?: boolean) => {\n    if (disposed) return;\n    if (replaceLastData) {\n      lastBroadcastData = data;\n    }\n    const peers = connMap.getConnectedPeerIds();\n    connMap.forEachConnectedConns((conn) => {\n      try {\n        conn.send({ userId, data, peers, liveMode });\n      } catch (e) {\n        console.error(\"broadcastData\", e);\n      }\n    });\n  };\n\n  const sendSDP = (conn: Peer.DataConnection, sdp: unknown) => {\n    conn.send({ SDP: sdp });\n  };\n\n  const handleSDP = async (conn: Peer.DataConnection, sdp: unknown) => {\n    if (!sdp || typeof sdp !== \"object\") return;\n    if (typeof (sdp as { offer: unknown }).offer === \"object\") {\n      const { offer } = sdp as { offer: object };\n      try {\n        await conn.peerConnection.setRemoteDescription(offer as any);\n        const answer = await conn.peerConnection.createAnswer();\n        await conn.peerConnection.setLocalDescription(answer);\n        sendSDP(conn, { answer });\n      } catch (e) {\n        console.log(\"handleSDP offer failed\", e);\n      }\n    } else if (typeof (sdp as { answer: unknown }).answer === \"object\") {\n      const { answer } = sdp as { answer: object };\n      try {\n        await conn.peerConnection.setRemoteDescription(answer as any);\n      } catch (e) {\n        console.log(\"handleSDP answer failed\", e);\n      }\n    } else {\n      console.warn(\"unkonwn SDP\", sdp);\n    }\n  };\n\n  const handleUserId = (conn: Peer.DataConnection, payloadUserId: unknown) => {\n    if (typeof payloadUserId === \"string\") {\n      connMap.setUserId(conn, payloadUserId as string);\n    }\n  };\n\n  const handleLiveMode = (\n    conn: Peer.DataConnection,\n    payloadLiveMode: unknown\n  ) => {\n    if (typeof payloadLiveMode === \"boolean\") {\n      connMap.setLiveMode(conn, payloadLiveMode as boolean);\n      if (payloadLiveMode) {\n        // We need to delay because negotiation is in progress\n        // FIXME there should be better way than timeout\n        setTimeout(() => {\n          addAllStreamTracks(conn);\n        }, 3000);\n      } else {\n        // We need to delay because negotiation is in progress\n        // FIXME there should be better way than timeout\n        setTimeout(() => {\n          removeAllStreamTracks(conn);\n        }, 3000);\n      }\n    }\n  };\n\n  const handlePayload = (conn: Peer.DataConnection, payload: unknown) => {\n    if (disposed) return;\n    if (!payload && typeof payload !== \"object\") return;\n\n    handleSDP(conn, (payload as { SDP?: unknown }).SDP);\n    handleUserId(conn, (payload as { userId?: unknown }).userId);\n    handleLiveMode(conn, (payload as { liveMode?: unknown }).liveMode);\n\n    if (Array.isArray((payload as { peers?: unknown }).peers)) {\n      (payload as { peers: unknown[] }).peers.forEach((peer) => {\n        if (isValidPeerId(roomId, peer)) {\n          connectPeer(peer);\n        }\n      });\n    }\n\n    const connUserId = connMap.getUserId(conn);\n    if (connUserId) {\n      const info: PeerInfo = {\n        userId: connUserId,\n        peerIndex: getPeerIndexFromConn(conn),\n        liveMode: connMap.getLiveMode(conn),\n      };\n      try {\n        receiveData((payload as { data: unknown }).data, info);\n      } catch (e) {\n        console.error(\"receiveData\", e);\n      }\n    }\n  };\n\n  const initConnection = (conn: Peer.DataConnection) => {\n    if (connMap.isConnected(conn.peer)) {\n      conn.close();\n      return;\n    }\n    connMap.addConn(conn);\n    conn.on(\"open\", () => {\n      connMap.markConnected(conn);\n      showConnectedStatus();\n      if (lastBroadcastData) {\n        conn.send({\n          userId,\n          data: lastBroadcastData,\n          peers: connMap.getConnectedPeerIds(),\n          liveMode,\n        });\n      }\n    });\n    conn.on(\"data\", (payload: unknown) => handlePayload(conn, payload));\n    conn.peerConnection.addEventListener(\"negotiationneeded\", async () => {\n      if (!connMap.isConnected(conn.peer)) return;\n      const offer = await conn.peerConnection.createOffer();\n      await conn.peerConnection.setLocalDescription(offer);\n      sendSDP(conn, { offer });\n    });\n    conn.peerConnection.addEventListener(\"track\", (event: RTCTrackEvent) => {\n      const connUserId = connMap.getUserId(conn);\n      if (connUserId) {\n        const info = {\n          userId: connUserId,\n          peerIndex: getPeerIndexFromPeerId(conn.peer),\n          liveMode: connMap.getLiveMode(conn),\n        };\n        receiveTrack(event.track, info);\n      }\n    });\n    conn.on(\"close\", () => {\n      connMap.delConn(conn);\n      console.log(\"dataConnection closed\", conn);\n      updateNetworkStatus({\n        type: \"CONNECTION_CLOSED\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      showConnectedStatus();\n      if (connMap.getConnectedPeerIds().length === 0) {\n        reInitMyPeer(true);\n      } else if (\n        guessSeed(conn.peer) &&\n        myPeer &&\n        !myPeer.disconnected &&\n        !guessSeed(myPeer.id)\n      ) {\n        const waitSec = 30 + Math.floor(Math.random() * 60);\n        console.log(\n          `Disconnected seed peer: ${getPeerIndexFromPeerId(\n            conn.peer\n          )}, reinit in ${waitSec}sec...`\n        );\n        setTimeout(reInitMyPeer, waitSec * 1000);\n      }\n    });\n  };\n\n  const initMyPeer = (index = MIN_SEED_PEER_INDEX) => {\n    if (disposed) return;\n    if (myPeer) return;\n    connMap.clearAll();\n    const isSeed = MIN_SEED_PEER_INDEX <= index && index <= MAX_SEED_PEER_INDEX;\n    const peerIndex = isSeed ? index : rand4();\n    updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex });\n    const id = generatePeerId(roomId, peerIndex);\n    console.log(\"initMyPeer start\", index, id);\n    const peer = new Peer(id, { debug: 2 });\n    myPeer = peer;\n    peer.on(\"open\", () => {\n      myPeer = peer;\n      if (process.env.NODE_ENV !== \"production\") {\n        (window as any).myPeer = myPeer;\n      }\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const seedId = generatePeerId(roomId, i);\n        connectPeer(seedId);\n      }\n    });\n    peer.on(\"error\", (err) => {\n      if (err.type === \"unavailable-id\") {\n        myPeer = null;\n        peer.destroy();\n        initMyPeer(index + 1);\n      } else if (err.type === \"peer-unavailable\") {\n        // ignore\n      } else if (err.type === \"network\") {\n        console.log(\"initMyPeer network error\", index, err);\n        peer.destroy();\n      } else {\n        console.error(\"initMyPeer\", index, err.type, err);\n        updateNetworkStatus({ type: \"UNKNOWN_ERROR\" });\n      }\n    });\n    peer.on(\"connection\", (conn) => {\n      if (myPeer !== peer) {\n        conn.close();\n        return;\n      }\n      console.log(\"new connection received\", conn);\n      updateNetworkStatus({\n        type: \"NEW_CONNECTION\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      initConnection(conn);\n    });\n    peer.on(\"disconnected\", () => {\n      console.log(\"initMyPeer disconnected\", index);\n      setTimeout(() => {\n        if (myPeer === peer && !peer.destroyed) {\n          console.log(\"initMyPeer reconnecting\", index);\n          updateNetworkStatus({ type: \"RECONNECTING\" });\n          peer.reconnect();\n        }\n      }, 5 * 1000);\n    });\n    peer.on(\"close\", () => {\n      if (myPeer === peer) {\n        console.log(\"initMyPeer closed, re-initializing\", index);\n        myPeer = null;\n        setTimeout(initMyPeer, 10 * 1000);\n      } else {\n        console.log(\"initMyPeer closed, ignoring\", index);\n      }\n    });\n  };\n  initMyPeer();\n\n  const reInitMyPeer = (force?: boolean) => {\n    if (!myPeer) return;\n    if (myPeer.disconnected) return; // should already be handled\n    if (!force) {\n      if (guessSeed(myPeer.id)) return;\n      let existsAllSeeds = true;\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const id = generatePeerId(roomId, i);\n        if (!connMap.isConnected(id)) {\n          existsAllSeeds = false;\n          break;\n        }\n      }\n      if (existsAllSeeds) {\n        showConnectedStatus();\n        return;\n      }\n    }\n    const oldPeer = myPeer;\n    myPeer = null;\n    oldPeer.destroy();\n    initMyPeer();\n  };\n\n  const enableLiveMode = () => {\n    if (liveMode) {\n      console.warn(\"liveMode already enabled\");\n      return;\n    }\n    liveMode = true;\n    localStream = new MediaStream();\n    broadcastData(lastBroadcastData);\n  };\n\n  const disableLiveMode = () => {\n    if (!liveMode) {\n      console.warn(\"liveMode already disabled\");\n      return;\n    }\n    liveMode = false;\n    if (localStream) {\n      localStream.getTracks().forEach(removeTrack);\n    }\n    localStream = null;\n    broadcastData(lastBroadcastData);\n  };\n\n  const addTrack = (track: MediaStreamTrack) => {\n    if (!localStream) return;\n    localStream.addTrack(track);\n    connMap.forEachLiveConns(async (conn) => {\n      try {\n        if (!localStream) return;\n        conn.peerConnection.addTrack(track, localStream);\n      } catch (e) {\n        if (e.name === \"InvalidAccessError\") {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n    });\n  };\n\n  const removeTrack = (track: MediaStreamTrack) => {\n    if (!localStream) return;\n    localStream.removeTrack(track);\n    connMap.forEachLiveConns(async (conn) => {\n      const senders = conn.peerConnection.getSenders();\n      const sender = senders.find((s) => s.track === track);\n      if (sender) {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const addAllStreamTracks = (conn: Peer.DataConnection) => {\n    if (!localStream) return;\n    localStream.getTracks().forEach((track) => {\n      try {\n        if (!localStream) return;\n        conn.peerConnection.addTrack(track, localStream);\n      } catch (e) {\n        if (e.name === \"InvalidAccessError\") {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n    });\n  };\n\n  const removeAllStreamTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection.getSenders();\n    senders.forEach((sender) => {\n      if (sender.track) {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const dispose = () => {\n    disposed = true;\n    if (myPeer) {\n      myPeer.destroy();\n    }\n  };\n\n  return {\n    broadcastData,\n    enableLiveMode,\n    disableLiveMode,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n","import { useEffect, useState, useCallback, useRef } from \"react\";\n\nimport { PeerInfo, createRoom, NetworkStatus } from \"../network/room\";\n\ntype NetworkStatusListener = (status: NetworkStatus) => void;\ntype DataListener = (data: unknown, info: PeerInfo) => void;\ntype TrackListener = (track: MediaStreamTrack, info: PeerInfo) => void;\ntype RoomEntry = {\n  room: ReturnType<typeof createRoom>;\n  networkStatusListeners: Set<NetworkStatusListener>;\n  dataListeners: Set<DataListener>;\n  trackListeners: Set<TrackListener>;\n  count: number;\n};\nconst roomEntryMap = new Map<string, RoomEntry>();\nconst register = (\n  roomId: string,\n  userId: string,\n  networkStatusListener?: NetworkStatusListener,\n  dataListener?: DataListener,\n  trackListener?: TrackListener\n) => {\n  const roomEntryKey = `${roomId}_${userId}`;\n  let entry = roomEntryMap.get(roomEntryKey);\n  if (!entry) {\n    const networkStatusListeners = new Set<NetworkStatusListener>();\n    const dataListeners = new Set<DataListener>();\n    const trackListeners = new Set<TrackListener>();\n    const updateNetworkStatus = (status: NetworkStatus) => {\n      networkStatusListeners.forEach((listener) => {\n        listener(status);\n      });\n    };\n    const receiveData = (data: unknown, info: PeerInfo) => {\n      dataListeners.forEach((listener) => {\n        listener(data, info);\n      });\n    };\n    const receiveTrack = (track: MediaStreamTrack, info: PeerInfo) => {\n      trackListeners.forEach((listener) => {\n        listener(track, info);\n      });\n    };\n    const room = createRoom(\n      roomId,\n      userId,\n      updateNetworkStatus,\n      receiveData,\n      receiveTrack\n    );\n    entry = {\n      room,\n      networkStatusListeners,\n      dataListeners,\n      trackListeners,\n      count: 0,\n    };\n    roomEntryMap.set(roomEntryKey, entry);\n  }\n  if (networkStatusListener) {\n    entry.networkStatusListeners.add(networkStatusListener);\n  }\n  if (dataListener) {\n    entry.dataListeners.add(dataListener);\n  }\n  if (trackListener) {\n    entry.trackListeners.add(trackListener);\n    if (entry.trackListeners.size === 1) {\n      entry.room.enableLiveMode();\n    }\n  }\n  entry.count += 1;\n  const unregister = () => {\n    if (networkStatusListener) {\n      (entry as RoomEntry).networkStatusListeners.delete(networkStatusListener);\n    }\n    if (dataListener) {\n      (entry as RoomEntry).dataListeners.delete(dataListener);\n    }\n    if (trackListener) {\n      (entry as RoomEntry).trackListeners.delete(trackListener);\n      if ((entry as RoomEntry).trackListeners.size === 0) {\n        (entry as RoomEntry).room.disableLiveMode();\n      }\n    }\n    (entry as RoomEntry).count -= 1;\n    if ((entry as RoomEntry).count <= 0) {\n      (entry as RoomEntry).room.dispose();\n      roomEntryMap.delete(roomEntryKey);\n    }\n  };\n  return {\n    broadcastData: entry.room.broadcastData,\n    addTrack: entry.room.addTrack,\n    removeTrack: entry.room.removeTrack,\n    unregister,\n  };\n};\n\nexport const useRoomNetworkStatus = (roomId: string, userId: string) => {\n  const [networkStatus, updateNetworkStatus] = useState<NetworkStatus>();\n  if (networkStatus && networkStatus.type === \"UNKNOWN_ERROR\") {\n    throw new Error(\"Network Error\");\n  }\n  useEffect(() => {\n    const { unregister } = register(roomId, userId, updateNetworkStatus);\n    return unregister;\n  }, [roomId, userId]);\n  return networkStatus;\n};\n\ntype BroadcastData = ReturnType<typeof createRoom>[\"broadcastData\"];\n\nexport const useBroadcastData = (roomId: string, userId: string) => {\n  const broadcastDataRef = useRef<BroadcastData>();\n  const broadcastData = useCallback((...args: Parameters<BroadcastData>) => {\n    if (broadcastDataRef.current) {\n      broadcastDataRef.current(...args);\n    } else {\n      // TODO pending queue\n    }\n  }, []);\n  useEffect(() => {\n    const { broadcastData: broadcastDataByRegister, unregister } = register(\n      roomId,\n      userId\n    );\n    broadcastDataRef.current = broadcastDataByRegister;\n    return unregister;\n  }, [roomId, userId]);\n  return broadcastData;\n};\n\nexport const useRoomData = <Data>(\n  roomId: string,\n  userId: string,\n  isValidData: (data: unknown) => boolean\n) => {\n  const [latestData, setLatestData] = useState<{\n    data: Data;\n    info: PeerInfo;\n  }>();\n  useEffect(() => {\n    const dataListener = (data: unknown, info: PeerInfo) => {\n      if (isValidData(data)) {\n        setLatestData({ data: data as Data, info });\n      }\n      return false;\n    };\n    const { unregister } = register(roomId, userId, undefined, dataListener);\n    return unregister;\n  }, [roomId, userId, isValidData]);\n  return latestData;\n};\n\nexport const useRoomMedia = (\n  roomId: string,\n  userId: string,\n  enabled: boolean\n) => {\n  const [functions, setFunctions] = useState<{\n    addTrack?: (track: MediaStreamTrack) => void;\n    removeTrack?: (track: MediaStreamTrack) => void;\n  }>({});\n  const [latestTrack, setLatestTrack] = useState<{\n    track: MediaStreamTrack;\n    info: PeerInfo;\n  } | null>(null);\n  useEffect(() => {\n    if (enabled) {\n      const trackListener = (track: MediaStreamTrack, info: PeerInfo) => {\n        setLatestTrack({ track, info });\n      };\n      const result = register(\n        roomId,\n        userId,\n        undefined,\n        undefined,\n        trackListener\n      );\n      setFunctions({\n        addTrack: result.addTrack,\n        removeTrack: result.removeTrack,\n      });\n      return () => {\n        setFunctions({});\n        result.unregister();\n      };\n    }\n    // not enabled\n    setLatestTrack(null);\n    return undefined;\n  }, [roomId, userId, enabled]);\n  return { ...functions, latestTrack };\n};\n","type DeviceInfo = {\n  label: string;\n  deviceId: string;\n};\n\nexport const getVideoDeviceInfoList = async () => {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const list: DeviceInfo[] = devices\n      .filter(({ kind }) => kind === \"videoinput\")\n      .map(({ label, deviceId }) => ({ label, deviceId }));\n    return list;\n  } catch (e) {\n    // ignored\n    return [];\n  }\n};\n\nexport const getAudioDeviceInfoList = async () => {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const list: DeviceInfo[] = devices\n      .filter(({ kind }) => kind === \"audioinput\")\n      .map(({ label, deviceId }) => ({ label, deviceId }));\n    return list;\n  } catch (e) {\n    // ignored\n    return [];\n  }\n};\n","export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","import { sleep } from \"../utils/sleep\";\n\nconst captureImage = async (stream: MediaStream, track: MediaStreamTrack) => {\n  if (typeof ImageCapture !== \"undefined\") {\n    const imageCapture = new ImageCapture(track);\n    await sleep(2000);\n    let srcImg;\n    try {\n      const blob = await imageCapture.takePhoto();\n      srcImg = await createImageBitmap(blob);\n    } catch (e) {\n      srcImg = await imageCapture.grabFrame();\n    }\n    const srcW = srcImg.width;\n    const srcH = srcImg.height;\n    return { srcImg, srcW, srcH };\n  }\n  const video = document.getElementById(\"internal-video\") as HTMLVideoElement;\n  video.style.display = \"block\";\n  const savedSrcObject = video.srcObject;\n  const revert = () => {\n    video.srcObject = savedSrcObject;\n  };\n  video.srcObject = stream;\n  await sleep(2000);\n  const srcImg = video;\n  const srcW = video.videoWidth;\n  const srcH = video.videoHeight;\n  return { srcImg, srcW, srcH, revert };\n};\n\nexport const takePhoto = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        video: { deviceId },\n      }\n    : { video: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const track = stream.getVideoTracks()[0];\n  const canvas = document.getElementById(\n    \"internal-canvas\"\n  ) as HTMLCanvasElement;\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const dstW = 72;\n  const dstH = 72;\n  canvas.width = dstW;\n  canvas.height = dstH;\n  const { srcImg, srcW, srcH, revert } = await captureImage(stream, track);\n  const ratio = Math.max(dstW / srcW, dstH / srcH);\n  const width = Math.min(srcW, dstW / ratio);\n  const height = Math.min(srcH, dstH / ratio);\n  const x = (srcW - width) / 2;\n  const y = (srcH - height) / 2;\n  ctx.drawImage(srcImg, x, y, width, height, 0, 0, dstW, dstH);\n  if (revert) {\n    revert();\n  }\n  track.stop();\n  return canvas.toDataURL(\"image/png\");\n};\n","import { useEffect, useState, useRef } from \"react\";\n\nimport { takePhoto } from \"../media/capture\";\nimport { useRoomData, useBroadcastData, useRoomNetworkStatus } from \"./useRoom\";\n\ntype ImageUrl = string;\ntype FaceInfo = {\n  nickname: string;\n  message: string;\n};\ntype ImageData = {\n  image: ImageUrl;\n  info: FaceInfo;\n};\ntype RoomImage = ImageData & {\n  userId: string;\n  received: number; // in milliseconds\n  obsoleted: boolean;\n  liveMode: boolean;\n  peerIndex: number;\n};\n\nconst isFaceInfo = (x: unknown): x is FaceInfo =>\n  x &&\n  typeof x === \"object\" &&\n  typeof (x as { nickname: unknown }).nickname === \"string\" &&\n  typeof (x as { message: unknown }).message === \"string\";\n\nconst isImageData = (x: unknown): x is ImageData =>\n  x &&\n  typeof x === \"object\" &&\n  typeof (x as { image: unknown }).image === \"string\" &&\n  isFaceInfo((x as { info: unknown }).info);\n\nexport const useFaceImages = (\n  roomId: string,\n  userId: string,\n  nickname: string,\n  statusMesg: string,\n  deviceId?: string\n) => {\n  const [myImage, setMyImage] = useState<ImageUrl>();\n  const [roomImages, setRoomImages] = useState<RoomImage[]>([]);\n  const [fatalError, setFatalError] = useState<Error>();\n  const faceInfo = useRef({ nickname, message: statusMesg });\n  faceInfo.current = { nickname, message: statusMesg };\n\n  if (fatalError) {\n    throw fatalError;\n  }\n\n  const broadcastData = useBroadcastData(roomId, userId);\n  const latestData = useRoomData<ImageData>(roomId, userId, isImageData);\n  useEffect(() => {\n    if (latestData) {\n      const roomImage = {\n        ...latestData.data,\n        userId: latestData.info.userId,\n        received: Date.now(),\n        obsoleted: false,\n        liveMode: latestData.info.liveMode,\n        peerIndex: latestData.info.peerIndex,\n      };\n      setRoomImages((prev) => {\n        const found = prev.find((item) => item.userId === roomImage.userId);\n        if (!found) {\n          return [...prev, roomImage];\n        }\n        return prev.map((item) =>\n          item.userId === roomImage.userId ? roomImage : item\n        );\n      });\n    }\n  }, [latestData]);\n\n  const networkStatus = useRoomNetworkStatus(roomId, userId);\n  useEffect(() => {\n    if (networkStatus && networkStatus.type === \"CONNECTION_CLOSED\") {\n      const { peerIndex } = networkStatus;\n      setRoomImages((prev) => {\n        let changed = false;\n        const next = prev.map((item) => {\n          if (item.peerIndex === peerIndex) {\n            changed = true;\n            return { ...item, obsoleted: true };\n          }\n          return item;\n        });\n        return changed ? next : prev;\n      });\n    }\n  }, [networkStatus]);\n\n  useEffect(() => {\n    const checkObsoletedImage = () => {\n      const twoMinAgo = Date.now() - 2 * 60 * 1000;\n      const tenMinAgo = Date.now() - 10 * 60 * 1000;\n      setRoomImages((prev) => {\n        let changed = false;\n        const next = prev\n          .map((item) => {\n            if (item.received < twoMinAgo && !item.obsoleted) {\n              changed = true;\n              return { ...item, obsoleted: true };\n            }\n            if (item.received < tenMinAgo && item.obsoleted) {\n              changed = true;\n              return null;\n            }\n            return item;\n          })\n          .filter((item) => item) as typeof prev;\n\n        return changed ? next : prev;\n      });\n    };\n    const loop = async () => {\n      try {\n        checkObsoletedImage();\n        const image = await takePhoto(deviceId);\n        setMyImage(image);\n        const data = {\n          userId,\n          image,\n          info: faceInfo.current,\n        };\n        broadcastData(data, true);\n      } catch (e) {\n        console.error(e);\n        setFatalError(e);\n      }\n    };\n    loop();\n    const timer = setInterval(loop, 2 * 60 * 1000);\n    return () => {\n      clearTimeout(timer);\n    };\n  }, [roomId, userId, deviceId, broadcastData]);\n\n  return {\n    myImage,\n    roomImages,\n  };\n};\n","import { sleep } from \"../utils/sleep\";\n\nexport const getVideoStream = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        video: { deviceId },\n      }\n    : { video: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const track = stream.getVideoTracks()[0];\n  const video = document.getElementById(\"internal-video\") as HTMLVideoElement;\n  video.style.display = \"block\";\n  video.srcObject = stream;\n  await sleep(1000);\n  const srcW = video.videoWidth;\n  const srcH = video.videoHeight;\n  const canvas = document.getElementById(\n    \"internal-canvas\"\n  ) as HTMLCanvasElement;\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const dstW = 72;\n  const dstH = 72;\n  canvas.width = dstW;\n  canvas.height = dstH;\n  const ratio = Math.max(dstW / srcW, dstH / srcH);\n  const width = Math.min(srcW, dstW / ratio);\n  const height = Math.min(srcH, dstH / ratio);\n  const x = (srcW - width) / 2;\n  const y = (srcH - height) / 2;\n  const timer = setInterval(() => {\n    ctx.drawImage(video, x, y, width, height, 0, 0, dstW, dstH);\n  }, 1000 / 30);\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const dispose = () => {\n    video.style.display = \"none\";\n    clearInterval(timer);\n    track.stop();\n    canvasStream.getVideoTracks()[0].stop();\n  };\n  return {\n    stream: canvasStream,\n    dispose,\n  };\n};\n","export const getAudioStream = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        audio: { deviceId },\n      }\n    : { audio: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const track = stream.getAudioTracks()[0];\n  await track.applyConstraints({\n    echoCancellation: true,\n    echoCancellationType: { ideal: \"system\" },\n    noiseSuppression: { ideal: true },\n  } as MediaTrackConstraints);\n  const dispose = () => {\n    track.stop();\n  };\n  return {\n    stream,\n    dispose,\n  };\n};\n","import { useEffect, useState, useRef } from \"react\";\n\nimport { getVideoStream } from \"../media/video\";\nimport { getAudioStream } from \"../media/audio\";\nimport { useRoomMedia } from \"./useRoom\";\n\nconst addTrackWithNewStream = (\n  track: MediaStreamTrack,\n  stream: MediaStream | null\n) => {\n  const newStream = stream ? stream.clone() : new MediaStream();\n  newStream.addTrack(track);\n  return newStream;\n};\n\nconst removeTrackWithNewStream = (\n  track: MediaStreamTrack,\n  stream: MediaStream | null\n) => {\n  // XXX removeTrack doesn't remove from the result... a workaround\n  // const newStream = stream ? stream.clone() : new MediaStream();\n  // newStream.removeTrack(track);\n  const newStream = new MediaStream();\n  if (stream) {\n    stream.getTracks().forEach((t) => {\n      if (t !== track) {\n        newStream.addTrack(t);\n      }\n    });\n  }\n  if (newStream.getTracks().length > 0) {\n    return newStream;\n  }\n  return null;\n};\n\nexport const useFaceVideos = (\n  roomId: string,\n  userId: string,\n  videoEnabled: boolean,\n  audioEnabled: boolean,\n  videoDeviceId?: string,\n  audioDeviceId?: string\n) => {\n  const [faceStream, setFaceStream] = useState<MediaStream | null>(null);\n  const [faceStreamMap, setFaceStreamMap] = useState<{\n    [userId: string]: MediaStream | null;\n  }>({});\n  const { addTrack, removeTrack, latestTrack } = useRoomMedia(\n    roomId,\n    userId,\n    videoEnabled || audioEnabled\n  );\n\n  type CleanupFn = () => void;\n  const cleanupFns = useRef<CleanupFn[]>([]);\n  useEffect(() => {\n    const cleanup = () => {\n      cleanupFns.current.forEach((fn) => fn());\n    };\n    return cleanup;\n  }, []);\n\n  useEffect(() => {\n    if (!latestTrack) return;\n    const { track, info } = latestTrack;\n    setFaceStreamMap((prev) => ({\n      ...prev,\n      [info.userId]: addTrackWithNewStream(track, prev[info.userId]),\n    }));\n    const onended = () => {\n      setFaceStreamMap((prev) => ({\n        ...prev,\n        [info.userId]: removeTrackWithNewStream(track, prev[info.userId]),\n      }));\n    };\n    track.addEventListener(\"ended\", onended);\n    // XXX we don't get \"ended\" event with removeTrack,\n    // so a workaround with \"mute\" but \"mute\" is dispatched occasionally,\n    // so use this timeout hack\n    let timeout: NodeJS.Timeout;\n    const onmute = () => {\n      clearTimeout(timeout);\n      timeout = setTimeout(() => {\n        setFaceStreamMap((prev) => ({\n          ...prev,\n          [info.userId]: removeTrackWithNewStream(track, prev[info.userId]),\n        }));\n      }, 3000);\n    };\n    track.addEventListener(\"mute\", onmute);\n    const onunmute = () => {\n      clearTimeout(timeout);\n    };\n    track.addEventListener(\"unmute\", onunmute);\n    cleanupFns.current.push(() => {\n      track.removeEventListener(\"ended\", onended);\n      clearTimeout(timeout);\n      track.removeEventListener(\"mute\", onmute);\n      track.removeEventListener(\"unmute\", onunmute);\n    });\n  }, [latestTrack]);\n\n  useEffect(() => {\n    let dispose: (() => void) | null = null;\n    if (videoEnabled && addTrack && removeTrack) {\n      (async () => {\n        const {\n          stream: videoStream,\n          dispose: disposeVideo,\n        } = await getVideoStream(videoDeviceId);\n        const videoTrack = videoStream.getVideoTracks()[0];\n        addTrack(videoTrack);\n        setFaceStream((prev) => addTrackWithNewStream(videoTrack, prev));\n        dispose = () => {\n          setFaceStream((prev) => removeTrackWithNewStream(videoTrack, prev));\n          removeTrack(videoTrack);\n          disposeVideo();\n        };\n      })();\n    }\n    return () => {\n      if (dispose) dispose();\n    };\n  }, [roomId, videoEnabled, videoDeviceId, addTrack, removeTrack]);\n\n  useEffect(() => {\n    let dispose: (() => void) | null = null;\n    if (audioEnabled && addTrack && removeTrack) {\n      (async () => {\n        const {\n          stream: audioStream,\n          dispose: disposeAudio,\n        } = await getAudioStream(audioDeviceId);\n        const audioTrack = audioStream.getAudioTracks()[0];\n        addTrack(audioTrack);\n        setFaceStream((prev) => addTrackWithNewStream(audioTrack, prev));\n        dispose = () => {\n          setFaceStream((prev) => removeTrackWithNewStream(audioTrack, prev));\n          removeTrack(audioTrack);\n          disposeAudio();\n        };\n      })();\n    }\n    return () => {\n      if (dispose) dispose();\n    };\n  }, [roomId, audioEnabled, audioDeviceId, addTrack, removeTrack]);\n\n  return { faceStream, faceStreamMap };\n};\n","import React, { useRef, useEffect } from \"react\";\n\nimport \"./FaceImages.css\";\nimport { useFaceImages } from \"../hooks/useFaceImages\";\nimport { useFaceVideos } from \"../hooks/useFaceVideos\";\n\nconst BLANK_IMAGE =\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQI12NgYAAAAAMAASDVlMcAAAAASUVORK5CYII=\";\n\nconst FaceImage = React.memo<{\n  image?: string;\n  nickname: string;\n  statusMesg: string;\n  obsoleted?: boolean;\n  liveMode?: boolean;\n  stream?: MediaStream;\n  unmuted?: boolean;\n}>(({ image, nickname, statusMesg, obsoleted, liveMode, stream, unmuted }) => {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  useEffect(() => {\n    if (stream && videoRef.current) {\n      videoRef.current.srcObject = stream;\n    }\n  }, [stream]);\n  const hasVideo = !!stream && stream.getVideoTracks().length > 0;\n  const hasAudio = !!stream && stream.getAudioTracks().length > 0;\n  return (\n    <div className=\"FaceImages-card\" style={{ opacity: obsoleted ? 0.2 : 1 }}>\n      {liveMode && stream ? (\n        <video\n          className=\"FaceImages-photo\"\n          ref={videoRef}\n          autoPlay\n          muted={!unmuted}\n        />\n      ) : (\n        <img\n          src={image || BLANK_IMAGE}\n          className=\"FaceImages-photo\"\n          alt=\"myself\"\n        />\n      )}\n      <div className=\"FaceImages-name\">{nickname}</div>\n      <div className=\"FaceImages-mesg\">{statusMesg}</div>\n      {liveMode && hasVideo && hasAudio && (\n        <div className=\"FaceImages-live-indicator\" title=\"Video/Audio On\">\n          &#9672;\n        </div>\n      )}\n      {liveMode && hasVideo && !hasAudio && (\n        <div className=\"FaceImages-live-indicator\" title=\"Video On\">\n          &#9673;\n        </div>\n      )}\n      {!obsoleted && liveMode && !stream && (\n        <div className=\"FaceImages-live-indicator\" title=\"Video On\">\n          &#9678;\n        </div>\n      )}\n    </div>\n  );\n});\n\ntype Props = {\n  roomId: string;\n  userId: string;\n  nickname: string;\n  statusMesg: string;\n  liveType: \"off\" | \"video\" | \"video+audio\";\n  videoDeviceId?: string;\n  audioDeviceId?: string;\n};\n\nconst FaceImages: React.FC<Props> = ({\n  roomId,\n  userId,\n  nickname,\n  statusMesg,\n  liveType,\n  videoDeviceId,\n  audioDeviceId,\n}) => {\n  const { myImage, roomImages } = useFaceImages(\n    roomId,\n    userId,\n    nickname,\n    statusMesg,\n    videoDeviceId\n  );\n  const { faceStream, faceStreamMap } = useFaceVideos(\n    roomId,\n    userId,\n    liveType === \"video\" || liveType === \"video+audio\",\n    liveType === \"video+audio\",\n    videoDeviceId,\n    audioDeviceId\n  );\n\n  return (\n    <div className=\"FaceImage-container\">\n      <FaceImage\n        image={myImage}\n        nickname={nickname}\n        statusMesg={statusMesg}\n        liveMode={liveType !== \"off\"}\n        stream={faceStream || undefined}\n      />\n      {roomImages.map((item) => (\n        <FaceImage\n          key={item.userId}\n          image={item.image}\n          nickname={item.info.nickname}\n          statusMesg={item.info.message}\n          obsoleted={item.obsoleted}\n          liveMode={item.liveMode}\n          stream={faceStreamMap[item.userId] || undefined}\n          unmuted={liveType === \"video+audio\"}\n        />\n      ))}\n    </div>\n  );\n};\n\nexport default React.memo(FaceImages);\n","import { useEffect, useState, useCallback, useRef } from \"react\";\n\nimport { useRoomData, useBroadcastData } from \"./useRoom\";\n\nconst MAX_CHAT_LIST_SIZE = 100;\n\ntype ChatData = {\n  userId: string;\n  nickname: string;\n  chatSeq: number;\n  chatText: string;\n  chatInReplyTo?: {\n    userId: string;\n    chatSeq: number;\n  };\n};\n\nconst isChatData = (x: unknown): x is ChatData =>\n  x &&\n  typeof x === \"object\" &&\n  typeof (x as { userId: unknown }).userId === \"string\" &&\n  typeof (x as { nickname: unknown }).nickname === \"string\" &&\n  typeof (x as { chatSeq: unknown }).chatSeq === \"number\" &&\n  typeof (x as { chatText: unknown }).chatText === \"string\" &&\n  (typeof (x as { chatInReplyTo: unknown }).chatInReplyTo === \"undefined\" ||\n    typeof (x as { chatInReplyTo: { userId: unknown } }).chatInReplyTo\n      .userId === \"string\" ||\n    typeof (x as { chatInReplyTo: { chatSeq: unknown } }).chatInReplyTo\n      .chatSeq === \"number\");\n\ntype Reply = [string, number];\n\ntype ChatItem = {\n  key: string;\n  replyTo: { userId: string; chatSeq: number };\n  nickname: string;\n  text: string;\n  replies: Reply[];\n};\n\nconst compareReply = (a: Reply, b: Reply) => {\n  const countDiff = b[1] - a[1];\n  if (countDiff === 0) {\n    return a[0].length - b[0].length;\n  }\n  return countDiff;\n};\n\nexport const useMomentaryChat = (\n  roomId: string,\n  userId: string,\n  nickname: string\n) => {\n  const chatSeqRef = useRef(1);\n  const receivedSeqMap = useRef(new Map<string, number>());\n  const [chatList, setChatList] = useState<ChatItem[]>([]);\n\n  const addChatItem = useCallback((chatData: ChatData) => {\n    if ((receivedSeqMap.current.get(chatData.userId) || 0) < chatData.chatSeq) {\n      receivedSeqMap.current.set(chatData.userId, chatData.chatSeq);\n    } else {\n      return;\n    }\n    if (chatData.chatInReplyTo) {\n      const { chatText, chatInReplyTo } = chatData;\n      setChatList((prev) =>\n        prev.map((item) => {\n          if (\n            item.replyTo.userId === chatInReplyTo.userId &&\n            item.replyTo.chatSeq === chatInReplyTo.chatSeq\n          ) {\n            const replyMap = new Map(item.replies);\n            replyMap.set(chatText, (replyMap.get(chatText) || 0) + 1);\n            const replies = [...replyMap.entries()];\n            replies.sort(compareReply);\n            return { ...item, replies };\n          }\n          return item;\n        })\n      );\n    } else {\n      const chatItem: ChatItem = {\n        key: `${chatData.userId}_${chatData.chatSeq}`,\n        replyTo: {\n          userId: chatData.userId,\n          chatSeq: chatData.chatSeq,\n        },\n        nickname: chatData.nickname,\n        text: chatData.chatText,\n        replies: [],\n      };\n      setChatList((prev) => [chatItem, ...prev].slice(0, MAX_CHAT_LIST_SIZE));\n    }\n  }, []);\n\n  const broadcastData = useBroadcastData(roomId, userId);\n  const result = useRoomData<ChatData>(roomId, userId, isChatData);\n  useEffect(() => {\n    if (result) {\n      addChatItem(result.data);\n    }\n  });\n\n  const sendChat = useCallback(\n    (text: string) => {\n      const data: ChatData = {\n        userId,\n        nickname,\n        chatSeq: chatSeqRef.current,\n        chatText: text,\n      };\n      chatSeqRef.current += 1;\n      broadcastData(data);\n      addChatItem(data);\n    },\n    [broadcastData, userId, nickname, addChatItem]\n  );\n\n  const replyChat = useCallback(\n    (text: string, inReplyTo: { userId: string; chatSeq: number }) => {\n      const data: ChatData = {\n        userId,\n        nickname,\n        chatSeq: chatSeqRef.current,\n        chatText: text,\n        chatInReplyTo: inReplyTo,\n      };\n      chatSeqRef.current += 1;\n      broadcastData(data);\n      addChatItem(data);\n    },\n    [broadcastData, userId, nickname, addChatItem]\n  );\n\n  return {\n    chatList,\n    sendChat,\n    replyChat,\n  };\n};\n","import React, { useState } from \"react\";\n\nimport \"./MomentaryChat.css\";\nimport { useMomentaryChat } from \"../hooks/useMomentaryChat\";\n\ntype ChatList = ReturnType<typeof useMomentaryChat>[\"chatList\"];\ntype ReplyChat = ReturnType<typeof useMomentaryChat>[\"replyChat\"];\n\nconst reactions = [\"\", \"\", \"\", \"\", \"\"];\n\nconst ReactionButton: React.FC<{\n  text: string;\n  onClick: (text: string) => void;\n}> = ({ text, onClick }) => (\n  <button type=\"button\" onClick={() => onClick(text)}>\n    <span aria-label=\"Reaction\">{text}</span>\n  </button>\n);\n\nconst MomentaryChatContent = React.memo<{\n  chatList: ChatList;\n  replyChat: ReplyChat;\n}>(({ chatList, replyChat }) => (\n  <ul className=\"MomentaryChat-list\">\n    {chatList.map((item) => {\n      const reply = (text: string) => replyChat(text, item.replyTo);\n      return (\n        <li key={item.key} className=\"MomentaryChat-listPart\">\n          <div className=\"MomentaryChat-listPart-header\">\n            <div className=\"MomentaryChat-iconButton-container\">\n              <div className=\"MomentaryChat-iconButton\">\n                {reactions.map((text) => (\n                  <ReactionButton key={text} text={text} onClick={reply} />\n                ))}\n              </div>\n            </div>\n            <div className=\"MomentaryChat-nickname\">\n              {item.nickname || \"No Name\"}\n            </div>\n          </div>\n          <div>{item.text}</div>\n          {item.replies.map(([text, count]) => (\n            <div className=\"Momentary-icon\">\n              {text} {count}\n            </div>\n          ))}\n        </li>\n      );\n    })}\n  </ul>\n));\n\ntype Props = {\n  roomId: string;\n  userId: string;\n  nickname: string;\n};\n\nconst MomentaryChat: React.FC<Props> = ({ roomId, userId, nickname }) => {\n  const { chatList, sendChat, replyChat } = useMomentaryChat(\n    roomId,\n    userId,\n    nickname\n  );\n\n  const [text, setText] = useState(\"\");\n  const onSubmit = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    if (text) {\n      sendChat(text);\n      setText(\"\");\n    }\n  };\n\n  return (\n    <div className=\"MomentaryChat-container\">\n      <form onSubmit={onSubmit}>\n        <input\n          value={text}\n          onChange={(e) => setText(e.target.value)}\n          placeholder=\"Enter chat message\"\n        />\n        <button type=\"submit\" disabled={!text}>\n          Send\n        </button>\n      </form>\n      <MomentaryChatContent chatList={chatList} replyChat={replyChat} />\n    </div>\n  );\n};\n\nexport default React.memo(MomentaryChat);\n","import React, { useEffect, useState } from \"react\";\n\nimport \"./SingleRoom.css\";\nimport { setRoomIdToUrl } from \"../utils/url\";\nimport { setStringItem, getStringItem } from \"../utils/storage\";\nimport { useRoomNetworkStatus } from \"../hooks/useRoom\";\nimport { useVideoDevices, useAudioDevices } from \"../hooks/useAvailableDevices\";\nimport FaceImages from \"./FaceImages\";\nimport MomentaryChat from \"./MomentaryChat\";\n\ntype LiveType = \"off\" | \"video\" | \"video+audio\";\n\ntype Props = {\n  roomId: string;\n  userId: string;\n};\n\nconst initialNickname = getStringItem(\"nickname\");\n\nconst SingleRoom: React.FC<Props> = ({ roomId, userId }) => {\n  const [nickname, setNickname] = useState(initialNickname);\n  const [statusMesg, setStatusMesg] = useState(\"\");\n  useEffect(() => {\n    setRoomIdToUrl(roomId);\n  }, [roomId]);\n\n  const videoDevices = useVideoDevices();\n  const audioDevices = useAudioDevices();\n  const [videoDeviceId, setVideoDeviceId] = useState<string>();\n  const [audioDeviceId, setAudioDeviceId] = useState<string>();\n  const [liveType, setLiveType] = useState<LiveType>(\"off\");\n  const [configOpen, setConfigOpen] = useState<boolean>(true);\n\n  const networkStatus = useRoomNetworkStatus(roomId, userId);\n\n  const appLink = `remote-faces://${window.location.href.replace(\n    /^https:\\/\\//,\n    \"\"\n  )}`;\n\n  return (\n    <>\n      <div className=\"SingleRoom-status\">{JSON.stringify(networkStatus)}</div>\n      <div className=\"SingleRoom-room-info\">\n        {configOpen ? (\n          <>\n            <button type=\"button\" onClick={() => setConfigOpen(false)}>\n              Hide config\n            </button>\n            <div>\n              Link to this room:\n              <input value={window.location.href} readOnly />\n              (Share this link with your colleagues)\n              <a href={appLink}>Open App</a>\n            </div>\n            <div className=\"SingleRoom-nickname\">\n              Your Name:{\" \"}\n              <input\n                defaultValue={initialNickname}\n                onChange={(e) => {\n                  setNickname(e.target.value);\n                  setStringItem(\"nickname\", e.target.value);\n                }}\n              />\n            </div>\n            <div className=\"SingleRoom-statusmesg\">\n              Your Status:{\" \"}\n              <input\n                onChange={(e) => {\n                  setStatusMesg(e.target.value);\n                }}\n                placeholder=\"Enter status message\"\n              />\n            </div>\n            <div>\n              Select Camera:{\" \"}\n              <select onChange={(e) => setVideoDeviceId(e.target.value)}>\n                {videoDevices.map((videoDevice) => (\n                  <option\n                    key={videoDevice.deviceId}\n                    value={videoDevice.deviceId}\n                  >\n                    {videoDevice.label}\n                  </option>\n                ))}\n              </select>\n            </div>\n            <div>\n              Select Mic:{\" \"}\n              <select onChange={(e) => setAudioDeviceId(e.target.value)}>\n                {audioDevices.map((audioDevice) => (\n                  <option\n                    key={audioDevice.deviceId}\n                    value={audioDevice.deviceId}\n                  >\n                    {audioDevice.label}\n                  </option>\n                ))}\n              </select>\n            </div>\n            <div>\n              Live Type:{\" \"}\n              <select onChange={(e) => setLiveType(e.target.value as LiveType)}>\n                <option value=\"off\">Off</option>\n                <option value=\"video\">Video Only</option>\n                <option value=\"video+audio\">Video and Audio</option>\n              </select>\n            </div>\n          </>\n        ) : (\n          <button type=\"button\" onClick={() => setConfigOpen(true)}>\n            Show config\n          </button>\n        )}\n      </div>\n      <FaceImages\n        roomId={roomId}\n        userId={userId}\n        videoDeviceId={videoDeviceId}\n        audioDeviceId={audioDeviceId}\n        nickname={nickname}\n        statusMesg={statusMesg}\n        liveType={liveType}\n      />\n      <MomentaryChat roomId={roomId} userId={userId} nickname={nickname} />\n    </>\n  );\n};\n\nexport default SingleRoom;\n","type StringItemName = \"nickname\" | \"TODO1\";\n\ntype JsonItemName = \"TODO2\" | \"TODO3\";\n\nexport const setStringItem = (name: StringItemName, value: string) => {\n  try {\n    window.localStorage.setItem(name, value);\n  } catch (e) {\n    console.log(\"Failed to save string to localStorage\", e);\n  }\n};\n\nexport const getStringItem = (name: StringItemName) => {\n  try {\n    return window.localStorage.getItem(name) || \"\";\n  } catch (e) {\n    // ignore\n    return \"\";\n  }\n};\n\nexport const setJsonItem = (name: JsonItemName, value: unknown) => {\n  try {\n    window.localStorage.setItem(name, JSON.stringify(value));\n  } catch (e) {\n    console.log(\"Failed to save json to localStorage\", e);\n  }\n};\n\nexport const getJsonItem = (name: JsonItemName): unknown | null => {\n  try {\n    return JSON.parse(window.localStorage.getItem(name) || \"\");\n  } catch (e) {\n    // ignore\n    return null;\n  }\n};\n\nexport const removeItem = (name: StringItemName | JsonItemName) => {\n  try {\n    window.localStorage.removeItem(name);\n  } catch (e) {\n    // ignore\n  }\n};\n","import { useEffect, useState } from \"react\";\n\nimport {\n  getVideoDeviceInfoList,\n  getAudioDeviceInfoList,\n} from \"../media/devices\";\n\ntype VideoDeviceInfoList = ReturnType<\n  typeof getVideoDeviceInfoList\n> extends Promise<infer T>\n  ? T\n  : never;\n\nexport const useVideoDevices = () => {\n  const [devices, setDevices] = useState<VideoDeviceInfoList>([]);\n  useEffect(() => {\n    (async () => {\n      const deviceInfoList = await getVideoDeviceInfoList();\n      setDevices(deviceInfoList);\n    })();\n  }, []);\n  return devices;\n};\n\ntype AudioDeviceInfoList = ReturnType<\n  typeof getAudioDeviceInfoList\n> extends Promise<infer T>\n  ? T\n  : never;\n\nexport const useAudioDevices = () => {\n  const [devices, setDevices] = useState<AudioDeviceInfoList>([]);\n  useEffect(() => {\n    (async () => {\n      const deviceInfoList = await getAudioDeviceInfoList();\n      setDevices(deviceInfoList);\n    })();\n  }, []);\n  return devices;\n};\n","import React, { useState } from \"react\";\n\nimport \"./SingleRoomEntrance.css\";\nimport { secureRandomId } from \"../utils/crypto\";\nimport { getRoomIdFromUrl, extractRoomIdFromLink } from \"../utils/url\";\nimport SingleRoom from \"./SingleRoom\";\n\nconst roomIdFromUrl = getRoomIdFromUrl();\nconst userId = secureRandomId();\n\nconst SingleRoomEntrance: React.FC = () => {\n  const [roomId, setRoomId] = useState<string | null>(roomIdFromUrl);\n  const [linkText, setLinkText] = useState(\"\");\n\n  const onCreateNew = () => {\n    setRoomId(secureRandomId());\n  };\n\n  const onEnter = () => {\n    setRoomId(extractRoomIdFromLink(linkText));\n  };\n\n  if (roomId) {\n    return <SingleRoom roomId={roomId} userId={userId} />;\n  }\n\n  return (\n    <div className=\"SingleRoomEntrance-init\">\n      <button type=\"button\" onClick={onCreateNew}>\n        Create a new room\n      </button>\n      OR\n      <input\n        value={linkText}\n        onChange={(e) => setLinkText(e.target.value)}\n        placeholder=\"Enter room link...\"\n      />\n      <button\n        type=\"button\"\n        onClick={onEnter}\n        disabled={!extractRoomIdFromLink(linkText)}\n      >\n        Enter room\n      </button>\n    </div>\n  );\n};\n\nexport default SingleRoomEntrance;\n","import React from \"react\";\n\nimport ErrorFallback from \"./ErrorFallback\";\nimport SingleRoomEntrance from \"./SingleRoomEntrance\";\nimport \"./App.css\";\n\nclass ErrorBoundary extends React.Component {\n  state = { hasError: false };\n\n  static getDerivedStateFromError() {\n    return { hasError: true };\n  }\n\n  render() {\n    const { children } = this.props;\n    const { hasError } = this.state;\n    if (hasError) return <ErrorFallback />;\n    return children;\n  }\n}\n\nconst App: React.FC = () => (\n  <div className=\"App\">\n    <ErrorBoundary>\n      <SingleRoomEntrance />\n    </ErrorBoundary>\n  </div>\n);\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./components/App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}