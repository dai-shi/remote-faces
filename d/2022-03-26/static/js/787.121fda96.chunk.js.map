{"version":3,"file":"static/js/787.121fda96.chunk.js","mappings":"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","sources":["network/pubsubUtils.ts","network/pubsubRoom.ts","network/trackUtils.ts"],"sourcesContent":["let peerIndexCounter = 0;\n\nconst getNextPeerIndex = () => {\n  peerIndexCounter += 1;\n  return peerIndexCounter;\n};\n\n// XXX It would be nice to reuse audio worker for all connections\nexport type Connection = {\n  peerIndex: number;\n  peer: string; // ipfsId\n  userId: string;\n  audioWorkers: Map<string, Worker>; // <mediaType, audioDecoder>\n  vidoeSetImages: Map<string, (s: string) => void>; // <mediaType, setImage>\n};\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Connection;\n    acceptingMediaTypes: string[];\n  };\n  const map = new Map<string, Value>();\n\n  const setAcceptingMediaTypes = (conn: Connection, mediaTypes: string[]) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.acceptingMediaTypes = mediaTypes;\n    }\n  };\n\n  const getAcceptingMediaTypes = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (!value) return [];\n    return value.acceptingMediaTypes;\n  };\n\n  const addConn = (peerId: string, userId: string) => {\n    const value = map.get(peerId);\n    if (value) {\n      throw new Error(\"addConn: already exists\");\n    }\n    const conn: Connection = {\n      peerIndex: getNextPeerIndex(),\n      peer: peerId,\n      userId,\n      audioWorkers: new Map(),\n      vidoeSetImages: new Map(),\n    };\n    map.set(conn.peer, {\n      conn,\n      acceptingMediaTypes: [],\n    });\n    return conn;\n  };\n\n  const getConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return null;\n    return value.conn;\n  };\n\n  const findConn = (peerIndex: number) => {\n    const value = Array.from(map.values()).find(\n      (v) => v.conn.peerIndex === peerIndex\n    );\n    if (value) return value.conn;\n    return null;\n  };\n\n  const delConn = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n    } else {\n      throw new Error(\"delConn: does not exist\");\n    }\n  };\n\n  const getPeerIndexList = () =>\n    Array.from(map.values()).map((v) => v.conn.peerIndex);\n\n  const forEachConns = (callback: (conn: Connection) => void) => {\n    Array.from(map.values()).forEach((value) => {\n      callback(value.conn);\n    });\n  };\n\n  const size = () => map.size;\n\n  return {\n    setAcceptingMediaTypes,\n    getAcceptingMediaTypes,\n    addConn,\n    getConn,\n    findConn,\n    delConn,\n    getPeerIndexList,\n    forEachConns,\n    size,\n  };\n};\n","import { create as createUntyped } from \"ipfs\";\nimport type { create as createFn } from \"ipfs-core/types/src/components/index\";\nimport type { Message } from \"ipfs-core-types/types/src/pubsub/index\";\n\nimport { sleep } from \"../utils/sleep\";\nimport {\n  sha256,\n  secureRandomId,\n  importCryptoKey,\n  encryptStringToChunks,\n  decryptStringFromChunks,\n  encryptBufferFromChunks,\n  decryptBufferToChunks,\n} from \"../utils/crypto\";\nimport { getWebrtcStarFromUrl } from \"../utils/url\";\nimport { isObject } from \"../utils/types\";\nimport { ROOM_ID_PREFIX_LEN, PeerInfo, CreateRoom } from \"./common\";\nimport { Connection, createConnectionMap } from \"./pubsubUtils\";\nimport {\n  loopbackPeerConnection,\n  videoTrackToImageConverter,\n  imageToVideoTrackConverter,\n} from \"./trackUtils\";\n\nconst create = createUntyped as typeof createFn;\n\nconst topicsForMediaTypes = new Map<string, string>();\n\nconst getTopicForMediaType = async (roomId: string, mediaType: string) => {\n  const key = `${roomId} ${mediaType}`;\n  let topic = topicsForMediaTypes.get(key);\n  if (!topic) {\n    topic = (await sha256(key)).slice(0, ROOM_ID_PREFIX_LEN);\n    topicsForMediaTypes.set(key, topic);\n  }\n  return topic;\n};\n\nexport const createRoom: CreateRoom = async (\n  roomId,\n  userId,\n  updateNetworkStatus,\n  notifyNewPeer,\n  receiveData,\n  receiveTrack\n) => {\n  let disposed = false;\n  const connMap = createConnectionMap();\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myConnMap = connMap;\n  }\n  let mediaTypes: readonly string[] = [];\n\n  const roomTopic = roomId.slice(0, ROOM_ID_PREFIX_LEN);\n  const cryptoKey = await importCryptoKey(roomId.slice(ROOM_ID_PREFIX_LEN));\n\n  updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex: 0 });\n  const myIpfs = await create({\n    repo: secureRandomId(),\n    config: {\n      Addresses: {\n        Swarm: [\n          getWebrtcStarFromUrl() ||\n            \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\n        ],\n      },\n      Bootstrap: [], // not sure why this helps\n    },\n  });\n  const myPeerId = (await myIpfs.id()).id;\n  await myIpfs.pubsub.subscribe(roomTopic, (msg) => pubsubHandler(msg));\n  await myIpfs.pubsub.subscribe(`${roomTopic} ${myPeerId}`, (msg) =>\n    pubsubHandler(msg)\n  );\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myIpfs = myIpfs;\n  }\n\n  const parsePayload = async (encrypted: ArrayBuffer): Promise<unknown> => {\n    try {\n      const str = await decryptStringFromChunks(encrypted, cryptoKey);\n      if (str === null) return undefined;\n      const payload = JSON.parse(str);\n      console.log(\"decrypted payload\", payload);\n      return payload;\n    } catch (e) {\n      console.info(\"Error in parsePayload\", e, encrypted);\n      return undefined;\n    }\n  };\n\n  const sendPayload = async (topic: string, payload: unknown) => {\n    try {\n      console.log(\"payload to encrypt\", topic, payload);\n      for await (const encrypted of encryptStringToChunks(\n        JSON.stringify(payload),\n        cryptoKey\n      )) {\n        await myIpfs.pubsub.publish(topic, Buffer.from(encrypted), {});\n      }\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const sendPayloadDirectly = async (conn: Connection, payload: unknown) => {\n    const topic = `${roomTopic} ${conn.peer}`;\n    // XXX this doesn't seem to work in ipfs v0.48.0\n    await sendPayload(topic, payload);\n  };\n\n  const broadcastData = async (data: unknown) => {\n    if (disposed) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayload(roomTopic, payload);\n  };\n\n  const sendData = async (data: unknown, peerIndex: number) => {\n    if (disposed) return;\n    const conn = connMap.findConn(peerIndex);\n    if (!conn) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayloadDirectly(conn, payload);\n  };\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).sendData = sendData;\n  }\n\n  const mediaTypeDisposeMap = new Map<string, (() => void)[]>();\n\n  const acceptAudioMedia = async (mediaType: string) => {\n    const disposeList: (() => void)[] = [];\n    mediaTypeDisposeMap.set(mediaType, disposeList);\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const audioHandler = async (msg: Message) => {\n      if (msg.from === myPeerId) return;\n      const conn = connMap.getConn(msg.from);\n      if (!conn) {\n        console.warn(\"conn not ready\");\n        return;\n      }\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      if (!conn.audioWorkers.has(mediaType)) {\n        const audioCtx = new AudioContext();\n        const destination = audioCtx.createMediaStreamDestination();\n        let currTime = 0;\n        let pending = 0;\n        const worker = new Worker(\"audio-decoder.js\", { type: \"module\" });\n        worker.onmessage = (e) => {\n          const buffer = new Float32Array(e.data);\n          if (!pending) {\n            currTime = audioCtx.currentTime;\n          }\n          currTime += 0.06; // 60ms\n          pending += 1;\n          const audioBuffer = audioCtx.createBuffer(1, 2880, 48000);\n          audioBuffer.copyToChannel(buffer, 0);\n          const audioBufferSource = audioCtx.createBufferSource();\n          audioBufferSource.buffer = audioBuffer;\n          audioBufferSource.connect(destination);\n          audioBufferSource.onended = () => {\n            pending -= 1;\n          };\n          audioBufferSource.start(currTime);\n        };\n        conn.audioWorkers.set(mediaType, worker);\n        const audioTrack = destination.stream.getAudioTracks()[0];\n        receiveTrack(mediaType, await loopbackPeerConnection(audioTrack), info);\n        // XXX currently no way to detect track stop\n        disposeList.push(() => {\n          audioCtx.close();\n          audioTrack.dispatchEvent(new Event(\"ended\"));\n          worker.terminate();\n          conn.audioWorkers.delete(mediaType);\n        });\n      }\n      const bufList = await decryptBufferToChunks(\n        msg.data.buffer,\n        msg.data.byteOffset,\n        msg.data.byteLength,\n        cryptoKey\n      );\n      const worker = conn.audioWorkers.get(mediaType);\n      if (worker) {\n        bufList.forEach((buf) => {\n          worker.postMessage([buf], [buf]);\n        });\n      }\n    };\n    myIpfs.pubsub.subscribe(topic, audioHandler);\n    disposeList.unshift(() => {\n      myIpfs.pubsub.unsubscribe(topic, audioHandler);\n    });\n  };\n\n  const acceptVideoMedia = async (mediaType: string) => {\n    const disposeList: (() => void)[] = [];\n    mediaTypeDisposeMap.set(mediaType, disposeList);\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const videoHandler = async (msg: Message) => {\n      if (msg.from === myPeerId) return;\n      const conn = connMap.getConn(msg.from);\n      if (!conn) {\n        console.warn(\"conn not ready\");\n        return;\n      }\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      if (!conn.vidoeSetImages.has(mediaType)) {\n        const { videoTrack, setImage } = imageToVideoTrackConverter();\n        conn.vidoeSetImages.set(mediaType, setImage);\n        receiveTrack(mediaType, videoTrack, info);\n        // XXX currently no way to detect track stop\n        disposeList.push(() => {\n          videoTrack.dispatchEvent(new Event(\"ended\"));\n          conn.vidoeSetImages.delete(mediaType);\n        });\n      }\n      const setImage = conn.vidoeSetImages.get(mediaType);\n      try {\n        const dataURL = await decryptStringFromChunks(msg.data, cryptoKey);\n        if (setImage && dataURL) {\n          setImage(dataURL);\n        }\n      } catch (e) {\n        console.info(\"Error in parse for video media\", e);\n      }\n    };\n    myIpfs.pubsub.subscribe(topic, videoHandler);\n    disposeList.unshift(() => {\n      myIpfs.pubsub.unsubscribe(topic, videoHandler);\n    });\n  };\n\n  const acceptMediaTypes = (mTypes: readonly string[]) => {\n    if (disposed) return;\n    mediaTypeDisposeMap.forEach((disposeList, existingMediaType) => {\n      if (!mTypes.includes(existingMediaType)) {\n        disposeList.forEach((dispose) => dispose());\n        mediaTypeDisposeMap.delete(existingMediaType);\n      }\n    });\n    mTypes.forEach((mediaType) => {\n      if (mediaTypeDisposeMap.has(mediaType)) return;\n      if (mediaType.endsWith(\"Audio\")) {\n        acceptAudioMedia(mediaType);\n      } else if (mediaType.endsWith(\"Video\")) {\n        acceptVideoMedia(mediaType);\n      } else {\n        throw new Error(\"pubsubRoom: cannot guess mediaType (Audio/Video)\");\n      }\n    });\n    mediaTypes = mTypes;\n    broadcastData(null);\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Connection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setAcceptingMediaTypes(conn, payloadMediaTypes as string[]);\n    }\n  };\n\n  const handlePayloadData = (conn: Connection, data: unknown) => {\n    const info: PeerInfo = {\n      userId: conn.userId,\n      peerIndex: conn.peerIndex,\n      mediaTypes: connMap.getAcceptingMediaTypes(conn),\n    };\n    try {\n      receiveData(data, info);\n    } catch (e) {\n      console.warn(\"receiveData\", e);\n    }\n  };\n\n  const handlePayload = async (conn: Connection, payload: unknown) => {\n    try {\n      if (!isObject(payload)) return;\n\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, payload);\n    }\n  };\n\n  const initConnection = (peerId: string, payloadUserId: string) => {\n    const conn = connMap.addConn(peerId, payloadUserId);\n    notifyNewPeer(conn.peerIndex);\n    updateNetworkStatus({\n      type: \"NEW_CONNECTION\",\n      peerIndex: conn.peerIndex,\n    });\n    return conn;\n  };\n\n  const getUserIdFromPayload = (payload: unknown) => {\n    if (!isObject(payload)) return null;\n    const payloadUserId = (payload as { userId: unknown }).userId;\n    if (typeof payloadUserId !== \"string\") return null;\n    return payloadUserId;\n  };\n\n  const pubsubHandler = async (msg: Message) => {\n    if (disposed) return;\n    if (msg.from === myPeerId) return;\n    const payload = await parsePayload(msg.data);\n    if (payload === undefined) return;\n    const payloadUserId = getUserIdFromPayload(payload);\n    let conn = connMap.getConn(msg.from);\n    if (!conn) {\n      if (payloadUserId) {\n        conn = initConnection(msg.from, payloadUserId);\n      } else {\n        console.warn(\"cannot initialize conn without user id\");\n      }\n    }\n    if (conn) {\n      await handlePayload(conn, payload);\n    }\n    const peerIndexList = connMap.getPeerIndexList();\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const checkPeers = async () => {\n    if (disposed) return;\n    const peers = await myIpfs.pubsub.peers(roomTopic);\n    connMap.forEachConns((conn) => {\n      if (!peers.includes(conn.peer)) {\n        connMap.delConn(conn);\n        updateNetworkStatus({\n          type: \"CONNECTION_CLOSED\",\n          peerIndex: conn.peerIndex,\n        });\n      }\n    });\n    if (!peers.length) {\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      await sleep(1000);\n      checkPeers();\n      return;\n    }\n    if (!connMap.size()) {\n      await broadcastData(null);\n    }\n    await sleep(5000);\n    checkPeers();\n  };\n  checkPeers();\n\n  const trackDisposeMap = new WeakMap<MediaStreamTrack, () => void>();\n  const runDispose = (dispose?: () => void) => {\n    if (dispose) {\n      dispose();\n    }\n  };\n\n  const addAudioTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    runDispose(trackDisposeMap.get(track));\n    const stream = new MediaStream([track]);\n    const audioCtx = new AudioContext();\n    const trackSource = audioCtx.createMediaStreamSource(stream);\n    await audioCtx.audioWorklet.addModule(\"audio-encoder.js\");\n    const audioEncoder = new AudioWorkletNode(audioCtx, \"audio-encoder\");\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const bufList: ArrayBuffer[] = [];\n    audioEncoder.port.onmessage = async (event) => {\n      bufList.push(event.data);\n      if (bufList.length < 17) return;\n      const encrypted = await encryptBufferFromChunks(\n        bufList.splice(0, bufList.length),\n        cryptoKey\n      );\n      myIpfs.pubsub.publish(topic, Buffer.from(encrypted), {});\n    };\n    trackSource.connect(audioEncoder);\n    trackDisposeMap.set(track, () => {\n      audioCtx.close();\n    });\n  };\n\n  const addVideoTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    runDispose(trackDisposeMap.get(track));\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const { getImage } = await videoTrackToImageConverter(track);\n    let videoDisposed = false;\n    const loop = async () => {\n      if (videoDisposed) return;\n      const dataURL = await getImage();\n      if (dataURL) {\n        for await (const encrypted of encryptStringToChunks(\n          dataURL,\n          cryptoKey\n        )) {\n          if (videoDisposed) return;\n          await myIpfs.pubsub.publish(topic, Buffer.from(encrypted), {});\n          await sleep(1000);\n        }\n      } else {\n        await sleep(5000);\n      }\n      loop();\n    };\n    loop();\n    trackDisposeMap.set(track, () => {\n      videoDisposed = true;\n    });\n  };\n\n  const mediaTypeMap = new Map<string, MediaStreamTrack>();\n\n  const addTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    if (disposed) return;\n    if (mediaTypeMap.has(mediaType)) {\n      throw new Error(`track is already added for ${mediaType}`);\n    }\n    mediaTypeMap.set(mediaType, track);\n    if (mediaType.endsWith(\"Audio\")) {\n      addAudioTrack(mediaType, track);\n    } else if (mediaType.endsWith(\"Video\")) {\n      addVideoTrack(mediaType, track);\n    } else {\n      throw new Error(\"pubsubRoom: cannot guess mediaType (Audio/Video)\");\n    }\n  };\n\n  const removeTrack = (mediaType: string) => {\n    if (disposed) return;\n    const track = mediaTypeMap.get(mediaType);\n    if (!track) {\n      console.log(\"track is already removed for\", mediaType);\n      return;\n    }\n    mediaTypeMap.delete(mediaType);\n    runDispose(trackDisposeMap.get(track));\n  };\n\n  const dispose = async () => {\n    disposed = true;\n    await myIpfs.pubsub.unsubscribe(`${roomTopic} ${myPeerId}`, pubsubHandler);\n    await myIpfs.pubsub.unsubscribe(roomTopic, pubsubHandler);\n    await myIpfs.stop();\n  };\n\n  return {\n    broadcastData,\n    sendData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n","const setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = (timeout = 1000) => {\n    if (track.readyState === \"ended\") return;\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    } else if (timeout < 64000) {\n      setTimeout(() => {\n        onmute(timeout * 2);\n      }, timeout);\n    }\n  };\n  track.addEventListener(\"mute\", () => onmute());\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n\nexport const videoTrackToImageConverter = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") {\n    throw new Error(\"track kind is not video\");\n  }\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const imageCapture = new ImageCapture(track);\n  const getImage = async () => {\n    try {\n      const bitmap = await imageCapture.grabFrame();\n      canvas.width = bitmap.width;\n      canvas.height = bitmap.height;\n      ctx.drawImage(bitmap, 0, 0);\n      return canvas.toDataURL(\"image/jpeg\");\n    } catch (e) {\n      console.log(\"failed to grab frame from viedeo track\", e);\n      return null;\n    }\n  };\n  return { getImage };\n};\n\nconst createImage = (src: string): Promise<HTMLImageElement> =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n\nexport const imageToVideoTrackConverter = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const [videoTrack] = canvasStream.getVideoTracks();\n  const setImage = async (dataURL: string) => {\n    const img = await createImage(dataURL);\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n  };\n  return { videoTrack, setImage };\n};\n"],"names":["peerIndexCounter","create","createUntyped","topicsForMediaTypes","Map","getTopicForMediaType","async","roomId","mediaType","key","topic","get","sha256","slice","ROOM_ID_PREFIX_LEN","set","createRoom","userId","updateNetworkStatus","notifyNewPeer","receiveData","receiveTrack","disposed","connMap","map","setAcceptingMediaTypes","conn","mediaTypes","value","peer","acceptingMediaTypes","getAcceptingMediaTypes","addConn","peerId","Error","peerIndex","audioWorkers","vidoeSetImages","getConn","findConn","Array","from","values","find","v","delConn","delete","getPeerIndexList","forEachConns","callback","forEach","size","createConnectionMap","roomTopic","cryptoKey","importCryptoKey","type","myIpfs","repo","secureRandomId","config","Addresses","Swarm","getWebrtcStarFromUrl","Bootstrap","myPeerId","id","pubsub","subscribe","msg","pubsubHandler","sendPayload","payload","console","log","encrypted","encryptStringToChunks","JSON","stringify","publish","Buffer","e","error","broadcastData","data","mediaTypeDisposeMap","handlePayload","isObject","payloadMediaTypes","isArray","every","x","handlePayloadMediaTypes","info","warn","handlePayloadData","str","decryptStringFromChunks","parse","parsePayload","undefined","payloadUserId","getUserIdFromPayload","initConnection","peerIndexList","checkPeers","peers","includes","length","sleep","trackDisposeMap","WeakMap","runDispose","dispose","mediaTypeMap","sendData","sendPayloadDirectly","acceptMediaTypes","mTypes","disposeList","existingMediaType","has","endsWith","audioHandler","audioCtx","AudioContext","destination","createMediaStreamDestination","currTime","pending","worker","Worker","onmessage","buffer","Float32Array","currentTime","audioBuffer","createBuffer","copyToChannel","audioBufferSource","createBufferSource","connect","onended","start","audioTrack","stream","getAudioTracks","loopbackPeerConnection","push","close","dispatchEvent","Event","terminate","bufList","decryptBufferToChunks","byteOffset","byteLength","buf","postMessage","unshift","unsubscribe","acceptAudioMedia","videoHandler","videoTrack","setImage","imageToVideoTrackConverter","dataURL","acceptVideoMedia","addTrack","track","MediaStream","trackSource","createMediaStreamSource","audioWorklet","addModule","audioEncoder","AudioWorkletNode","port","event","encryptBufferFromChunks","splice","addAudioTrack","getImage","videoTrackToImageConverter","videoDisposed","loop","addVideoTrack","removeTrack","stop","setupMap","setupTrackStopOnLongMute","pc","onmute","timeout","readyState","transceiver","getTransceivers","t","receiver","currentDirection","setTimeout","addEventListener","Promise","resolve","reject","pcIn","RTCPeerConnection","pcOut","candidate","addIceCandidate","offer","createOffer","setLocalDescription","setRemoteDescription","answer","createAnswer","kind","canvas","document","createElement","ctx","getContext","imageCapture","ImageCapture","bitmap","grabFrame","width","height","drawImage","toDataURL","canvasStream","captureStream","getVideoTracks","img","src","Image","onload","onerror"],"sourceRoot":""}