{"version":3,"sources":["utils/types.ts","utils/sleep.ts","network/pubsubUtils.ts","network/trackUtils.ts","network/pubsubRoom.ts"],"names":["isObject","x","hasStringProp","prop","hasObjectProp","sleep","ms","Promise","resolve","setTimeout","peerIndexCounter","createConnectionMap","map","Map","setAcceptingMediaTypes","conn","mediaTypes","value","get","peer","acceptingMediaTypes","getAcceptingMediaTypes","addConn","peerId","userId","Error","peerIndex","audioWorkers","vidoeSetImages","set","getConn","findConn","Array","from","values","find","v","delConn","delete","getPeerIndexList","forEachConns","callback","forEach","size","setupMap","WeakMap","setupTrackStopOnLongMute","track","pc","has","onmute","a","transceiver","getTransceivers","t","receiver","currentDirection","stop","dispatchEvent","Event","addEventListener","loopbackPeerConnection","reject","pcIn","RTCPeerConnection","pcOut","candidate","addIceCandidate","event","close","addTrack","createOffer","offer","setLocalDescription","setRemoteDescription","createAnswer","answer","videoTrackToImageConverter","kind","canvas","document","createElement","ctx","getContext","imageCapture","ImageCapture","getImage","grabFrame","bitmap","width","height","drawImage","toDataURL","console","log","createImage","src","img","Image","onload","onerror","imageToVideoTrackConverter","captureStream","getVideoTracks","videoTrack","setImage","dataURL","topicsForMediaTypes","getTopicForMediaType","roomId","mediaType","key","topic","sha256","slice","ROOM_ID_PREFIX_LEN","createRoom","updateNetworkStatus","notifyNewPeer","receiveData","receiveTrack","disposed","connMap","roomTopic","importCryptoKey","cryptoKey","type","Ipfs","create","repo","secureRandomId","config","Addresses","Swarm","myIpfs","id","myPeerId","pubsub","subscribe","msg","pubsubHandler","parsePayload","encrypted","decryptStringFromChunks","str","undefined","payload","JSON","parse","info","sendPayload","encryptStringToChunks","stringify","publish","Buffer","error","sendPayloadDirectly","broadcastData","data","sendData","mediaTypeDisposeMap","acceptAudioMedia","disposeList","audioHandler","warn","audioCtx","AudioContext","destination","createMediaStreamDestination","currTime","pending","worker","Worker","onmessage","e","buffer","Float32Array","currentTime","audioBuffer","createBuffer","copyToChannel","audioBufferSource","createBufferSource","connect","onended","start","audioTrack","stream","getAudioTracks","push","terminate","decryptBufferToChunks","byteOffset","byteLength","bufList","buf","postMessage","unshift","unsubscribe","acceptVideoMedia","videoHandler","acceptMediaTypes","mTypes","existingMediaType","includes","dispose","endsWith","handlePayloadMediaTypes","payloadMediaTypes","isArray","every","handlePayloadData","handlePayload","initConnection","payloadUserId","getUserIdFromPayload","peerIndexList","checkPeers","peers","length","trackDisposeMap","runDispose","addAudioTrack","MediaStream","trackSource","createMediaStreamSource","audioWorklet","addModule","audioEncoder","AudioWorkletNode","port","encryptBufferFromChunks","splice","addVideoTrack","videoDisposed","loop","mediaTypeMap","removeTrack"],"mappings":"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","file":"static/js/6.5294b775.chunk.js","sourcesContent":["export const isObject = (x: unknown): x is Record<string, unknown> =>\n  typeof x === \"object\" && x !== null;\n\nexport const hasStringProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, string> =>\n  typeof (x as Record<Prop, unknown>)[prop] === \"string\";\n\nexport const hasObjectProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, Record<string, unknown>> =>\n  isObject((x as Record<Prop, unknown>)[prop]);\n\nexport type ReturnPromiseType<F extends (...args: any) => any> = ReturnType<\n  F\n> extends Promise<infer T>\n  ? T\n  : never;\n","export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","let peerIndexCounter = 0;\n\nconst getNextPeerIndex = () => {\n  peerIndexCounter += 1;\n  return peerIndexCounter;\n};\n\n// XXX It would be nice to reuse audio worker for all connections\nexport type Connection = {\n  peerIndex: number;\n  peer: string; // ipfsId\n  userId: string;\n  audioWorkers: Map<string, Worker>; // <mediaType, audioDecoder>\n  vidoeSetImages: Map<string, (s: string) => void>; // <mediaType, setImage>\n};\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Connection;\n    acceptingMediaTypes: string[];\n  };\n  const map = new Map<string, Value>();\n\n  const setAcceptingMediaTypes = (conn: Connection, mediaTypes: string[]) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.acceptingMediaTypes = mediaTypes;\n    }\n  };\n\n  const getAcceptingMediaTypes = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (!value) return [];\n    return value.acceptingMediaTypes;\n  };\n\n  const addConn = (peerId: string, userId: string) => {\n    const value = map.get(peerId);\n    if (value) {\n      throw new Error(\"addConn: already exists\");\n    }\n    const conn: Connection = {\n      peerIndex: getNextPeerIndex(),\n      peer: peerId,\n      userId,\n      audioWorkers: new Map(),\n      vidoeSetImages: new Map(),\n    };\n    map.set(conn.peer, {\n      conn,\n      acceptingMediaTypes: [],\n    });\n    return conn;\n  };\n\n  const getConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return null;\n    return value.conn;\n  };\n\n  const findConn = (peerIndex: number) => {\n    const value = Array.from(map.values()).find(\n      (v) => v.conn.peerIndex === peerIndex\n    );\n    if (value) return value.conn;\n    return null;\n  };\n\n  const delConn = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n    } else {\n      throw new Error(\"delConn: does not exist\");\n    }\n  };\n\n  const getPeerIndexList = () =>\n    Array.from(map.values()).map((v) => v.conn.peerIndex);\n\n  const forEachConns = (callback: (conn: Connection) => void) => {\n    Array.from(map.values()).forEach((value) => {\n      callback(value.conn);\n    });\n  };\n\n  const size = () => map.size;\n\n  return {\n    setAcceptingMediaTypes,\n    getAcceptingMediaTypes,\n    addConn,\n    getConn,\n    findConn,\n    delConn,\n    getPeerIndexList,\n    forEachConns,\n    size,\n  };\n};\n","import { sleep } from \"../utils/sleep\";\n\nconst setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = async () => {\n    await sleep(5000);\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    }\n  };\n  track.addEventListener(\"mute\", onmute);\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n\nexport const videoTrackToImageConverter = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") {\n    throw new Error(\"track kind is not video\");\n  }\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const imageCapture = new ImageCapture(track);\n  const getImage = async () => {\n    try {\n      const bitmap = await imageCapture.grabFrame();\n      canvas.width = bitmap.width;\n      canvas.height = bitmap.height;\n      ctx.drawImage(bitmap, 0, 0);\n      return canvas.toDataURL(\"image/jpeg\");\n    } catch (e) {\n      console.log(\"failed to grab frame from viedeo track\", e);\n      return null;\n    }\n  };\n  return { getImage };\n};\n\nconst createImage = (src: string): Promise<HTMLImageElement> =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n\nexport const imageToVideoTrackConverter = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const [videoTrack] = canvasStream.getVideoTracks();\n  const setImage = async (dataURL: string) => {\n    const img = await createImage(dataURL);\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n  };\n  return { videoTrack, setImage };\n};\n","import Ipfs, { PubsubHandler } from \"ipfs\";\n\nimport { sleep } from \"../utils/sleep\";\nimport {\n  sha256,\n  secureRandomId,\n  importCryptoKey,\n  encryptStringToChunks,\n  decryptStringFromChunks,\n  encryptBufferFromChunks,\n  decryptBufferToChunks,\n} from \"../utils/crypto\";\nimport { isObject } from \"../utils/types\";\nimport { ROOM_ID_PREFIX_LEN, PeerInfo, CreateRoom } from \"./common\";\nimport { Connection, createConnectionMap } from \"./pubsubUtils\";\nimport {\n  loopbackPeerConnection,\n  videoTrackToImageConverter,\n  imageToVideoTrackConverter,\n} from \"./trackUtils\";\n\nconst topicsForMediaTypes = new Map<string, string>();\n\nconst getTopicForMediaType = async (roomId: string, mediaType: string) => {\n  const key = `${roomId} ${mediaType}`;\n  let topic = topicsForMediaTypes.get(key);\n  if (!topic) {\n    topic = (await sha256(key)).slice(0, ROOM_ID_PREFIX_LEN);\n    topicsForMediaTypes.set(key, topic);\n  }\n  return topic;\n};\n\nexport const createRoom: CreateRoom = async (\n  roomId,\n  userId,\n  updateNetworkStatus,\n  notifyNewPeer,\n  receiveData,\n  receiveTrack\n) => {\n  let disposed = false;\n  const connMap = createConnectionMap();\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myConnMap = connMap;\n  }\n  let mediaTypes: string[] = [];\n\n  const roomTopic = roomId.slice(0, ROOM_ID_PREFIX_LEN);\n  const cryptoKey = await importCryptoKey(roomId.slice(ROOM_ID_PREFIX_LEN));\n\n  updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex: 0 });\n  const myIpfs = await Ipfs.create({\n    repo: secureRandomId(),\n    config: {\n      Addresses: {\n        Swarm: [\n          \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\n          \"/dns4/wrtc-star2.sjc.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\n        ],\n      },\n    },\n  });\n  const myPeerId = (await myIpfs.id()).id;\n  await myIpfs.pubsub.subscribe(roomTopic, (msg) => pubsubHandler(msg));\n  await myIpfs.pubsub.subscribe(`${roomTopic} ${myPeerId}`, (msg) =>\n    pubsubHandler(msg)\n  );\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myIpfs = myIpfs;\n  }\n\n  const parsePayload = async (encrypted: ArrayBuffer): Promise<unknown> => {\n    try {\n      const str = await decryptStringFromChunks(encrypted, cryptoKey);\n      if (str === null) return undefined;\n      const payload = JSON.parse(str);\n      console.log(\"decrypted payload\", payload);\n      return payload;\n    } catch (e) {\n      console.info(\"Error in parsePayload\", e, encrypted);\n      return undefined;\n    }\n  };\n\n  const sendPayload = async (topic: string, payload: unknown) => {\n    try {\n      console.log(\"payload to encrypt\", topic, payload);\n      for await (const encrypted of encryptStringToChunks(\n        JSON.stringify(payload),\n        cryptoKey\n      )) {\n        await myIpfs.pubsub.publish(topic, Buffer.from(encrypted));\n      }\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const sendPayloadDirectly = async (conn: Connection, payload: unknown) => {\n    const topic = `${roomTopic} ${conn.peer}`;\n    // XXX this doesn't seem to work in ipfs v0.48.0\n    await sendPayload(topic, payload);\n  };\n\n  const broadcastData = async (data: unknown) => {\n    if (disposed) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayload(roomTopic, payload);\n  };\n\n  const sendData = async (data: unknown, peerIndex: number) => {\n    if (disposed) return;\n    const conn = connMap.findConn(peerIndex);\n    if (!conn) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayloadDirectly(conn, payload);\n  };\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).sendData = sendData;\n  }\n\n  const mediaTypeDisposeMap = new Map<string, (() => void)[]>();\n\n  const acceptAudioMedia = async (mediaType: string) => {\n    const disposeList: (() => void)[] = [];\n    mediaTypeDisposeMap.set(mediaType, disposeList);\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const audioHandler: PubsubHandler = async (msg) => {\n      if (msg.from === myPeerId) return;\n      const conn = connMap.getConn(msg.from);\n      if (!conn) {\n        console.warn(\"conn not ready\");\n        return;\n      }\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      if (!conn.audioWorkers.has(mediaType)) {\n        const audioCtx = new AudioContext();\n        const destination = audioCtx.createMediaStreamDestination();\n        let currTime = 0;\n        let pending = 0;\n        const worker = new Worker(\"audio-decoder.js\", { type: \"module\" });\n        worker.onmessage = (e) => {\n          const buffer = new Float32Array(e.data);\n          if (!pending) {\n            currTime = audioCtx.currentTime;\n          }\n          currTime += 0.06; // 60ms\n          pending += 1;\n          const audioBuffer = audioCtx.createBuffer(1, 2880, 48000);\n          audioBuffer.copyToChannel(buffer, 0);\n          const audioBufferSource = audioCtx.createBufferSource();\n          audioBufferSource.buffer = audioBuffer;\n          audioBufferSource.connect(destination);\n          audioBufferSource.onended = () => {\n            pending -= 1;\n          };\n          audioBufferSource.start(currTime);\n        };\n        conn.audioWorkers.set(mediaType, worker);\n        const audioTrack = destination.stream.getAudioTracks()[0];\n        receiveTrack(mediaType, await loopbackPeerConnection(audioTrack), info);\n        // XXX currently no way to detect track stop\n        disposeList.push(() => {\n          audioCtx.close();\n          audioTrack.dispatchEvent(new Event(\"ended\"));\n          worker.terminate();\n          conn.audioWorkers.delete(mediaType);\n        });\n      }\n      const bufList = await decryptBufferToChunks(\n        msg.data.buffer,\n        msg.data.byteOffset,\n        msg.data.byteLength,\n        cryptoKey\n      );\n      const worker = conn.audioWorkers.get(mediaType);\n      if (worker) {\n        bufList.forEach((buf) => {\n          worker.postMessage([buf], [buf]);\n        });\n      }\n    };\n    myIpfs.pubsub.subscribe(topic, audioHandler);\n    disposeList.unshift(() => {\n      myIpfs.pubsub.unsubscribe(topic, audioHandler);\n    });\n  };\n\n  const acceptVideoMedia = async (mediaType: string) => {\n    const disposeList: (() => void)[] = [];\n    mediaTypeDisposeMap.set(mediaType, disposeList);\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const videoHandler: PubsubHandler = async (msg) => {\n      if (msg.from === myPeerId) return;\n      const conn = connMap.getConn(msg.from);\n      if (!conn) {\n        console.warn(\"conn not ready\");\n        return;\n      }\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      if (!conn.vidoeSetImages.has(mediaType)) {\n        const { videoTrack, setImage } = imageToVideoTrackConverter();\n        conn.vidoeSetImages.set(mediaType, setImage);\n        receiveTrack(mediaType, videoTrack, info);\n        // XXX currently no way to detect track stop\n        disposeList.push(() => {\n          videoTrack.dispatchEvent(new Event(\"ended\"));\n          conn.vidoeSetImages.delete(mediaType);\n        });\n      }\n      const setImage = conn.vidoeSetImages.get(mediaType);\n      try {\n        const dataURL = await decryptStringFromChunks(msg.data, cryptoKey);\n        if (setImage && dataURL) {\n          setImage(dataURL);\n        }\n      } catch (e) {\n        console.info(\"Error in parse for video media\", e);\n      }\n    };\n    myIpfs.pubsub.subscribe(topic, videoHandler);\n    disposeList.unshift(() => {\n      myIpfs.pubsub.unsubscribe(topic, videoHandler);\n    });\n  };\n\n  const acceptMediaTypes = (mTypes: string[]) => {\n    if (disposed) return;\n    mediaTypeDisposeMap.forEach((disposeList, existingMediaType) => {\n      if (!mTypes.includes(existingMediaType)) {\n        disposeList.forEach((dispose) => dispose());\n        mediaTypeDisposeMap.delete(existingMediaType);\n      }\n    });\n    mTypes.forEach((mediaType) => {\n      if (mediaTypeDisposeMap.has(mediaType)) return;\n      if (mediaType.endsWith(\"Audio\")) {\n        acceptAudioMedia(mediaType);\n      } else if (mediaType.endsWith(\"Video\")) {\n        acceptVideoMedia(mediaType);\n      } else {\n        throw new Error(\"pubsubRoom: cannot guess mediaType (Audio/Video)\");\n      }\n    });\n    mediaTypes = mTypes;\n    broadcastData(null);\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Connection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setAcceptingMediaTypes(conn, payloadMediaTypes as string[]);\n    }\n  };\n\n  const handlePayloadData = (conn: Connection, data: unknown) => {\n    const info: PeerInfo = {\n      userId: conn.userId,\n      peerIndex: conn.peerIndex,\n      mediaTypes: connMap.getAcceptingMediaTypes(conn),\n    };\n    try {\n      receiveData(data, info);\n    } catch (e) {\n      console.warn(\"receiveData\", e);\n    }\n  };\n\n  const handlePayload = async (conn: Connection, payload: unknown) => {\n    try {\n      if (!isObject(payload)) return;\n\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, payload);\n    }\n  };\n\n  const initConnection = (peerId: string, payloadUserId: string) => {\n    const conn = connMap.addConn(peerId, payloadUserId);\n    notifyNewPeer(conn.peerIndex);\n    updateNetworkStatus({\n      type: \"NEW_CONNECTION\",\n      peerIndex: conn.peerIndex,\n    });\n    return conn;\n  };\n\n  const getUserIdFromPayload = (payload: unknown) => {\n    if (!isObject(payload)) return null;\n    const payloadUserId = (payload as { userId: unknown }).userId;\n    if (typeof payloadUserId !== \"string\") return null;\n    return payloadUserId;\n  };\n\n  const pubsubHandler: PubsubHandler = async (msg) => {\n    if (disposed) return;\n    if (msg.from === myPeerId) return;\n    const payload = await parsePayload(msg.data);\n    if (payload === undefined) return;\n    const payloadUserId = getUserIdFromPayload(payload);\n    let conn = connMap.getConn(msg.from);\n    if (!conn) {\n      if (payloadUserId) {\n        conn = initConnection(msg.from, payloadUserId);\n      } else {\n        console.warn(\"cannot initialize conn without user id\");\n      }\n    }\n    if (conn) {\n      await handlePayload(conn, payload);\n    }\n    const peerIndexList = connMap.getPeerIndexList();\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const checkPeers = async () => {\n    if (disposed) return;\n    const peers = myIpfs.pubsub.peers(roomTopic);\n    connMap.forEachConns((conn) => {\n      if (!peers.includes(conn.peer)) {\n        connMap.delConn(conn);\n        updateNetworkStatus({\n          type: \"CONNECTION_CLOSED\",\n          peerIndex: conn.peerIndex,\n        });\n      }\n    });\n    if (!peers.length) {\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      await sleep(1000);\n      checkPeers();\n      return;\n    }\n    if (!connMap.size()) {\n      await broadcastData(null);\n    }\n    await sleep(5000);\n    checkPeers();\n  };\n  checkPeers();\n\n  const trackDisposeMap = new WeakMap<MediaStreamTrack, () => void>();\n  const runDispose = (dispose?: () => void) => {\n    if (dispose) {\n      dispose();\n    }\n  };\n\n  const addAudioTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    runDispose(trackDisposeMap.get(track));\n    const stream = new MediaStream([track]);\n    const audioCtx = new AudioContext();\n    const trackSource = audioCtx.createMediaStreamSource(stream);\n    await audioCtx.audioWorklet.addModule(\"audio-encoder.js\");\n    const audioEncoder = new AudioWorkletNode(audioCtx, \"audio-encoder\");\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const bufList: ArrayBuffer[] = [];\n    audioEncoder.port.onmessage = async (event) => {\n      bufList.push(event.data);\n      if (bufList.length < 17) return;\n      const encrypted = await encryptBufferFromChunks(\n        bufList.splice(0, bufList.length),\n        cryptoKey\n      );\n      myIpfs.pubsub.publish(topic, Buffer.from(encrypted));\n    };\n    trackSource.connect(audioEncoder);\n    trackDisposeMap.set(track, () => {\n      audioCtx.close();\n    });\n  };\n\n  const addVideoTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    runDispose(trackDisposeMap.get(track));\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const { getImage } = await videoTrackToImageConverter(track);\n    let videoDisposed = false;\n    const loop = async () => {\n      if (videoDisposed) return;\n      const dataURL = await getImage();\n      if (dataURL) {\n        for await (const encrypted of encryptStringToChunks(\n          dataURL,\n          cryptoKey\n        )) {\n          if (videoDisposed) return;\n          await myIpfs.pubsub.publish(topic, Buffer.from(encrypted));\n          await sleep(1000);\n        }\n      } else {\n        await sleep(5000);\n      }\n      loop();\n    };\n    loop();\n    trackDisposeMap.set(track, () => {\n      videoDisposed = true;\n    });\n  };\n\n  const mediaTypeMap = new Map<string, MediaStreamTrack>();\n\n  const addTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    if (disposed) return;\n    if (mediaTypeMap.has(mediaType)) {\n      throw new Error(`track is already added for ${mediaType}`);\n    }\n    mediaTypeMap.set(mediaType, track);\n    if (mediaType.endsWith(\"Audio\")) {\n      addAudioTrack(mediaType, track);\n    } else if (mediaType.endsWith(\"Video\")) {\n      addVideoTrack(mediaType, track);\n    } else {\n      throw new Error(\"pubsubRoom: cannot guess mediaType (Audio/Video)\");\n    }\n  };\n\n  const removeTrack = (mediaType: string) => {\n    if (disposed) return;\n    const track = mediaTypeMap.get(mediaType);\n    if (!track) {\n      console.log(\"track is already removed for\", mediaType);\n      return;\n    }\n    mediaTypeMap.delete(mediaType);\n    runDispose(trackDisposeMap.get(track));\n  };\n\n  const dispose = async () => {\n    disposed = true;\n    await myIpfs.pubsub.unsubscribe(`${roomTopic} ${myPeerId}`, pubsubHandler);\n    await myIpfs.pubsub.unsubscribe(roomTopic, pubsubHandler);\n    await myIpfs.stop();\n  };\n\n  return {\n    broadcastData,\n    sendData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n"],"sourceRoot":""}