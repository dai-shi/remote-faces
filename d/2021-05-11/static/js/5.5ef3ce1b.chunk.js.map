{"version":3,"sources":["../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js","../../node_modules/@babel/runtime/helpers/classCallCheck.js","../../node_modules/@babel/runtime/helpers/createClass.js","../../node_modules/prop-types/index.js","../../node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","../../node_modules/@babel/runtime/helpers/getPrototypeOf.js","../../node_modules/@babel/runtime/helpers/inherits.js","../../node_modules/lib0/math.js","../../node_modules/@babel/runtime/helpers/defineProperty.js","../../node_modules/@babel/runtime/helpers/assertThisInitialized.js","../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get.js","../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/superPropBase.js","../../node_modules/lib0/set.js","../../node_modules/lib0/array.js","../../node_modules/lib0/observable.js","../../node_modules/isomorphic.js/browser.mjs","../../node_modules/lib0/random.js","../../node_modules/lib0/error.js","../../node_modules/lib0/object.js","../../node_modules/lib0/function.js","../../node_modules/lib0/symbol.js","../../node_modules/lib0/pair.js","../../node_modules/lib0/dom.js","../../node_modules/lib0/eventloop.js","../../node_modules/lib0/json.js","../../node_modules/lib0/time.js","../../node_modules/lib0/logging.js","../../node_modules/lib0/iterator.js","../../src/utils/updates.js","../../src/utils/DeleteSet.js","../../src/utils/Doc.js","../../src/utils/UpdateDecoder.js","../../src/utils/UpdateEncoder.js","../../src/utils/encoding.js","../../src/utils/EventHandler.js","../../src/utils/ID.js","../../src/utils/Snapshot.js","../../src/utils/StructStore.js","../../src/utils/Transaction.js","../../src/utils/YEvent.js","../../src/types/AbstractType.js","../../src/types/YArray.js","../../src/types/YMap.js","../../src/types/YText.js","../../src/types/YXmlFragment.js","../../src/types/YXmlElement.js","../../src/types/YXmlEvent.js","../../src/types/YXmlHook.js","../../src/types/YXmlText.js","../../src/structs/AbstractStruct.js","../../src/structs/GC.js","../../src/structs/ContentBinary.js","../../src/structs/ContentDeleted.js","../../src/structs/ContentDoc.js","../../src/structs/ContentEmbed.js","../../src/structs/ContentFormat.js","../../src/structs/ContentJSON.js","../../src/structs/ContentAny.js","../../src/structs/ContentString.js","../../src/structs/ContentType.js","../../src/structs/Item.js","../../src/structs/Skip.js","../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js","../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js","../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","../../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toPrimitive.js","../../node_modules/lib0/map.js","../../node_modules/lib0/binary.js","../../node_modules/lib0/buffer.js","../../node_modules/@babel/runtime/helpers/extends.js","../../node_modules/emoji-mart/dist-es/utils/data.js","../../node_modules/emoji-mart/dist-es/polyfills/stringFromCodePoint.js","../../node_modules/emoji-mart/dist-es/utils/index.js","../../node_modules/emoji-mart/dist-es/utils/store.js","../../node_modules/emoji-mart/dist-es/utils/emoji-index/nimble-emoji-index.js","../../node_modules/emoji-mart/dist-es/utils/emoji-index/emoji-index.js","../../node_modules/emoji-mart/dist-es/utils/frequently.js","../../node_modules/emoji-mart/dist-es/svgs/index.js","../../node_modules/emoji-mart/dist-es/utils/shared-props.js","../../node_modules/emoji-mart/dist-es/components/anchors.js","../../node_modules/emoji-mart/dist-es/utils/shared-default-props.js","../../node_modules/emoji-mart/dist-es/components/emoji/nimble-emoji.js","../../node_modules/emoji-mart/dist-es/components/not-found.js","../../node_modules/emoji-mart/dist-es/components/category.js","../../node_modules/emoji-mart/dist-es/components/skins.js","../../node_modules/emoji-mart/dist-es/components/skins-emoji.js","../../node_modules/emoji-mart/dist-es/components/skins-dot.js","../../node_modules/emoji-mart/dist-es/components/preview.js","../../node_modules/emoji-mart/dist-es/components/search.js","../../node_modules/emoji-mart/dist-es/components/picker/nimble-picker.js","../../node_modules/emoji-mart/dist-es/components/picker/picker.js","../../node_modules/emoji-mart/dist-es/components/emoji/emoji.js","../../node_modules/lib0/string.js","../../node_modules/lib0/environment.js","../../node_modules/lib0/decoding.js","../../node_modules/@babel/runtime/helpers/typeof.js","../../node_modules/lib0/number.js","../../node_modules/lib0/encoding.js","../../node_modules/lib0/conditions.js","../../node_modules/lib0/storage.js","../../node_modules/@babel/runtime/helpers/setPrototypeOf.js","../../node_modules/prop-types/factoryWithThrowingShims.js","../../node_modules/prop-types/lib/ReactPropTypesSecret.js"],"names":["ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread2","target","i","arguments","length","source","forEach","key","getOwnPropertyDescriptors","defineProperties","defineProperty","module","exports","instance","Constructor","TypeError","_defineProperties","props","descriptor","configurable","writable","protoProps","staticProps","prototype","require","_typeof","assertThisInitialized","self","call","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","__proto__","subClass","superClass","create","constructor","value","floor","Math","abs","ceil","round","imul","log10","min","log2","log","sqrt","a","b","max","exp10","Number","isNaN","pow","exp","isNegativeZero","sign","n","obj","ReferenceError","property","receiver","Reflect","get","base","hasOwnProperty","desc","Set","last","arr","appendTo","dest","src","from","Array","Observable","this","_observers","map","name","f","set","add","on","_f","off","observers","undefined","delete","size","args","array","values","isoCrypto","window","performance","crypto","cryptoRandomBuffer","len","buf","ArrayBuffer","Uint8Array","getRandomValues","random","uint32","Uint32Array","uuidv4Template","uuidv4","replace","c","toString","s","Error","methodUnimplemented","unexpectedCase","assign","hasProperty","equalFlat","every","val","callAll","fs","Symbol","Pair","left","right","doc","document","mapToStyleString","DOMParser","m","join","createTimeoutClass","ELEMENT_NODE","TEXT_NODE","CDATA_SECTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","JSON","stringify","parse","clearFunction","timeoutId","_","getUnixTime","clearTimeout","clearInterval","arg","requestAnimationFrame","cancelAnimationFrame","cancelIdleCallback","Date","now","BOLD","symbol","UNBOLD","BLUE","GREY","GREEN","RED","PURPLE","ORANGE","UNCOLOR","_browserStyleMap","pair","_nodeStyleMap","computeLoggingArgs","env","strBuilder","logArgs","style","String","styles","currentStyle","dom","unshift","print","console","vconsoles","vc","createIterator","time","next","iterator","iteratorMap","fmap","done","lazyStructReaderGenerator","clock","clients","Map","iterateDeletedStructs","transaction","ds","deletes","clientid","structs","store","del","iterateStructs","isDeleted","id","dis","client","midindex","math.floor","mid","midclock","dels","j","sort","math.max","dss","merged","dssI","delsLeft","has","slice","array.appendTo","map.setIfUndefined","createDeleteSet","createDeleteSetFromStructStore","ss","dsitems","struct","deleted","encoder","encoding.writeVarUint","restEncoder","resetDsCurVal","item","writeDsClock","writeDsLen","decoder","numClients","decoding.readVarUint","restDecoder","numberOfDeletes","dsField","readDsClock","readDsLen","unappliedDS","state","getState","clockEnd","index","splice","splitItem","toUint8Array","generateNewClientId","random.uint32","guid","random.uuidv4","gc","gcFilter","meta","autoLoad","clientID","share","_transaction","_transactionCleanups","subdocs","_item","shouldLoad","parent","subdocsLoaded","origin","TypeConstructor","type","t","_integrate","Constr","_map","_start","_length","toJSON","array.from","subdoc","destroy","content","Doc","opts","subdocsAdded","subdocsRemoved","emit","eventName","createID","decoding.readUint8","decoding.readVarString","decoding.readAny","buffer.copyUint8Array","decoding.readVarUint8Array","dsCurrVal","diff","keyClockDecoder","decoding.IntDiffOptRleDecoder","clientDecoder","decoding.UintOptRleDecoder","leftClockDecoder","rightClockDecoder","infoDecoder","decoding.RleDecoder","stringDecoder","decoding.StringDecoder","parentInfoDecoder","typeRefDecoder","lenDecoder","read","keyClock","encoding.createEncoder","encoding.toUint8Array","info","encoding.writeUint8","encoding.writeVarString","isYKey","any","encoding.writeAny","encoding.writeVarUint8Array","embed","error.unexpectedCase","keyMap","keyClockEncoder","encoding.IntDiffOptRleEncoder","clientEncoder","encoding.UintOptRleEncoder","leftClockEncoder","rightClockEncoder","infoEncoder","encoding.RleEncoder","stringEncoder","encoding.StringEncoder","parentInfoEncoder","typeRefEncoder","lenEncoder","encoding.writeUint8Array","write","_sm","sm","getStateVector","entries","startNewStructs","writeClient","firstStruct","clientRefs","map.create","numOfStateUpdates","numberOfStructs","refs","readClient","readInfo","binary.BITS5","readLen","cantCopyParentInfo","binary.BIT7","binary.BIT8","readLeftID","readRightID","readParentInfo","readString","binary.BIT6","clientsStructRefs","stack","clientsStructRefsIds","getNextStructTarget","nextStructsTarget","pop","curStructsTarget","restStructs","missingSV","updateMissingSv","mclock","stackHead","addStackToRestSS","unapplicableItems","offset","missing","getMissing","structRefs","integrate","update","ydoc","transactionOrigin","structDecoder","retry","pending","pendingStructs","dsRest","pendingDs","pendingDSUpdate","decoding.createDecoder","dsRest2","YDecoder","applyUpdate","writeStateAsUpdate","targetStateVector","encodeStateAsUpdate","encodedTargetStateVector","updates","encodeStateAsUpdateV2","ssLength","decodedState","l","createEventHandler","addEventHandlerListener","eventHandler","removeEventHandlerListener","g","error","arg0","arg1","f.callAll","compareIDs","sv","createSnapshot","isVisible","snapshot","splitSnapshotAffectedStructs","set.create","getItemCleanStart","lastStruct","getItem","findIndexCleanStart","getItemCleanEnd","clockStart","local","deleteSet","beforeState","afterState","changed","changedParentTypes","_mergeStructs","map.any","writeStructsFromTransaction","parentSub","tryToMergeWithLeft","pos","mergeWith","deleteItems","di","deleteItem","endDeleteItemClock","si","keep","math.min","cleanupTransactions","transactionCleanups","mergeStructs","subs","itemtype","_callObserver","events","event","currentTarget","event1","event2","path","_dEH","beforeClock","firstChangePos","replacedStructPos","logging.print","logging.ORANGE","logging.BOLD","logging.UNBOLD","logging.RED","loaded","added","removed","initialCall","filterSkips","gen","curr","currClient","startClock","written","clientStructs","sliceStruct","leftItem","rightOrigin","YEncoder","updateDecoders","lazyStructDecoders","currWrite","updateEncoder","lazyStructEncoder","dec","dec1","dec2","clockDiff","currDecoder","firstClient","lazyStructWriter","reader","svClock","lazyWriter","partStructs","_changes","_keys","_delta","getPathTo","action","oldValue","adds","prev","array.last","getContent","changes","delta","lastOp","packOp","insert","concat","retain","child","globalSearchMarkerTimestamp","p","marker","timestamp","overwriteMarker","yarray","_searchMarker","reduce","math.abs","pindex","refreshMarkerTimestamp","countable","searchMarker","pm","markPosition","changedType","_eH","y","error.methodUnimplemented","parentSubs","typeListSlice","start","end","cs","typeListToArray","typeListForEach","typeListMap","result","typeListGet","typeListInsertGenericsAfter","referenceItem","ownClientId","jsonContent","packJsonContent","lastId","Boolean","typeListInsertGenerics","startIndex","startLength","error.create","typeMapDelete","typeMapSet","typeMapGet","typeMapGetAll","res","entry","_prelimContent","YArray","toArray","el","clone","currentContent","currentContentIndex","writeTypeRef","YArrayRefID","items","ymap","keysChanged","YMap","v","iterator.iteratorMap","typeMapHas","YMapRefID","object.equalFlat","currentAttributes","updateCurrentAttributes","findNextPosition","count","findPosition","insertNegatedAttributes","currPos","negatedAttributes","forward","nextFormat","format","minimizeAttributeChanges","attributes","insertAttributes","currentVal","insertText","text","getLength","formatText","attr","newlines","cleanupFormattingGap","startAttributes","endAttributes","cleanups","startAttrs","map.copy","ytext","childListChanged","sub","oldAttributes","deleteLen","addOp","op","str","curVal","string","_pending","e","YText","applyDelta","toDelta","foundFormattingItem","afterClock","attrs","cleanupContextlessFormattingGap","sanitize","ins","prevSnapshot","computeYChange","ops","packStr","addAttributes","cur","user","k","insertEmbed","attributeName","removeAttribute","attributeValue","setAttribute","YTextRefID","root","_filter","_root","_currentNode","_firstCall","YXmlFragment","query","toUpperCase","element","nodeName","xml","_document","hooks","binding","fragment","createDocumentFragment","_createAssociation","xmlType","insertBefore","toDOM","ref","refItem","pc","findIndex","YXmlFragmentRefID","first","_first","_prelimAttrs","YXmlElement","getAttributes","stringBuilder","keysLen","toLocaleLowerCase","attrsString","createElement","yxml","appendChild","YXmlElementRefID","writeKey","attributesChanged","hookName","YXmlHook","hook","createDom","YXmlHookRefID","YXmlText","createTextNode","nestedNodes","node","YXmlTextRefID","encodingRef","writeInfo","writeLen","ContentBinary","writeBuf","ContentDeleted","markDeleted","ContentDoc","writeString","writeAny","ContentEmbed","writeJSON","ContentFormat","ContentJSON","ContentAny","split","ContentString","firstCharCode","charCodeAt","typeRefs","readKey","ContentType","_copy","_write","rightItem","redone","isCountable","binary.BIT2","binary.BIT3","parentItem","Item","conflictingItems","itemsBeforeOrigin","clear","r","parentGCd","newStruct","replaceStruct","getRef","writeLeftID","writeRightID","ykey","writeParentInfo","isMarked","binary.BIT4","binary.BIT1","doKeep","doDelete","contentRefs","readBuf","readJSON","readTypeRef","readAny","_objectWithoutProperties","excluded","sourceKeys","indexOf","sourceSymbolKeys","propertyIsEnumerable","_toPropertyKey","input","hint","prim","toPrimitive","copy","setIfUndefined","createT","BIT1","BIT2","BIT3","BIT4","BIT6","BIT7","BIT8","BITS5","BITS6","BITS7","BITS8","BITS31","createUint8ArrayFromLen","createUint8ArrayViewFromArrayBuffer","buffer","byteOffset","copyUint8Array","uint8Array","newBuf","byteLength","_extends","mapping","unified","non_qualified","has_img_apple","has_img_google","has_img_twitter","has_img_facebook","keywords","sheet","emoticons","short_names","added_in","buildSearch","emoji","search","addToSearch","strings","isArray","toLowerCase","uncompress","data","compressed","emojis","sheet_x","sheet_y","toFixed","_String","fromCodePoint","highSurrogate","lowSurrogate","MAX_SIZE","codeUnits","codePoint","isFinite","RangeError","fromCharCode","COLONS_REGEX","SKINS","unifiedToNative","codePoints","u","stringFromCodePoint","skin_tone","skin_variations","custom","customCategory","imageUrl","colons","skin","getSanitizedData","getData","emojiData","matches","match","parseInt","aliases","variations","skinKey","variationData","shift","getEmojiDataFromNative","nativeString","skinCode","skinCodes","baseNativeString","skinTone","skinToneIndex","emojiUnified","uniq","acc","intersect","uniqA","uniqB","deepMerge","originalValue","getter","setter","NAMESPACE","isLocalStorageSupported","localStorage","setNamespace","namespace","setHandlers","handlers","NimbleEmojiIndex","_classCallCheck","originalPool","customEmojisList","buildIndex","_createClass","_this","_loop","emoticon","pool","_this2","emojiId","_this3","clearCustomEmojis","_this4","_ref","emojisToShowFilter","maxResults","include","exclude","_ref$custom","addCustomToPool","results","allResults","categories","category","isIncluded","isExcluded","customIsIncluded","customIsExcluded","aPool","aIndex","charIndex","_char","scores","substr","subIndex","score","aScore","bScore","localeCompare","emojiIndex","frequently","initialized","DEFAULTS","defaults","init","perLine","quantity","frequentlyKeys","sliced","reverse","activity","React","xmlns","viewBox","width","height","d","transform","x","rx","flags","foods","nature","objects","people","places","recent","opacity","EmojiPropTypes","PropTypes","isRequired","onOver","func","onLeave","onClick","fallback","backgroundImageFn","bool","forceSize","tooltip","useButton","oneOf","sheetSize","sheetColumns","number","sheetRows","oneOfType","PickerPropTypes","onSelect","onSkinChange","emojiSize","i18n","title","color","showPreview","showSkinTones","emojiTooltip","theme","arrayOf","autoFocus","enableFrequentEmojiSort","shape","spriteUrl","skinEmoji","notFound","notFoundEmoji","icons","Anchors","_React$PureComponent","_possibleConstructorReturn","defaultCategory","selected","handleClick","bind","_assertThisInitialized","_inherits","getAttribute","_this$props","onAnchorClick","_this$props2","className","categorieslabel","anchor","isSelected","iconId","startsWith","backgroundColor","PureComponent","propTypes","defaultProps","EmojiDefaultProps","PickerDefaultProps","defaultSkin","_objectSpread","_defineProperty","_getData","_getPosition","_getData2","multiplyX","multiplyY","_getSanitizedData","_isNumeric","parseFloat","NimbleEmoji","children","nativeEmoji","label","fontSize","display","wordBreak","backgroundImage","backgroundSize","backgroundPosition","backgroundRepeat","Tag","html","div","_convertStyleToCSS","_handleClick","onMouseEnter","_handleOver","onMouseLeave","_handleLeave","NotFound","emojiProps","notfound","Category","_React$Component","setContainerRef","setLabelRef","margin","minMargin","memoizeSize","nextProps","nextState","_native","hasStickyPosition","nextPerLine","nextNative","nextHasStickyPosition","nextEmojis","nextEmojiProps","nextSkin","nextSize","nextSet","shouldUpdate","container","top","maxMargin","parentElement","_this$container$getBo","getBoundingClientRect","parentTop","labelHeight","scrollTop","frequentlyUsed","getEmojis","_this$props3","labelStyles","labelSpanStyles","containerStyles","position","Component","Skins","opened","onChange","setState","SkinsEmoji","_Skins","skinToneNodes","skintext","SkinsDot","handleKeyDown","keyCode","preventDefault","visible","skintones","role","onKeyDown","tabIndex","Preview","skinsProps","idleEmoji","_emojiData$emoticons","knownEmoticons","listedEmoticons","short_name","Search","icon","isSearching","setRef","handleKeyUp","handleChange","doIdleTask","requestIdleCallback","setTimeout","running","throttleIdleTask","onSearch","focus","_this$state","inputId","placeholder","htmlFor","onKeyUp","disabled","I18N","1","2","3","4","5","6","NimblePicker","CUSTOM","RECENT_CATEGORY","SEARCH_CATEGORY","firstRender","allCategories","customCategories","customCategoriesCreated","customEmoji","hideRecent","categoryIndex","newEmojis","newCategory","includeRecent","excludeRecent","setAnchorsRef","handleAnchorClick","setSearchRef","handleSearch","setScrollRef","handleScroll","handleScrollPaint","handleEmojiOver","handleEmojiLeave","handleEmojiClick","handleEmojiSelect","setPreviewRef","handleSkinChange","handleDarkMatchMediaChange","testStickyPosition","firstRenderTimeout","updateCategoriesSize","leaveTimeout","darkMatchMedia","removeListener","stickyTestElement","prefix","matchMedia","addListener","media","preview","component","categoryRefs","forceUpdate","scroll","updateDisplay","waitingForPaint","activeCategory","scrollingDown","minTop","ii","active","clientHeight","scrollHeight","anchors","categoryName","scrollToComponent","newState","handled","overflow","body","scrollbarWidth","offsetWidth","clientWidth","removeChild","measureScrollbar","getPreferredTheme","onScroll","getCategories","setCategoryRef","Picker","Emoji","trimLeftRegex","fromCamelCaseRegex","fromCamelCase","separator","trimLeft","utf8TextDecoder","TextEncoder","TextDecoder","fatal","ignoreBOM","decode","params","isNode","process","release","test","isBrowser","navigator","platform","computeParams","pargs","argv","currParamName","parg","location","kv","getVariable","conditions","storage","hasParam","Decoder","createDecoder","hasContent","readUint8Array","view","readVarUint8Array","readVarUint","readUint8","num","binary","readVarInt","readVarString","remainingLen","encodedString","nextLen","bytes","subarray","decodeURIComponent","escape","readFromDataView","dv","DataView","readAnyLookupTable","getFloat32","getFloat64","getBigInt64","RleDecoder","UintOptRleDecoder","isNegative","math","IntDiffOptRleDecoder","hasCount","StringDecoder","spos","isInteger","MAX_SAFE_INTEGER","MIN_SAFE_INTEGER","Encoder","cpos","cbuf","bufs","createEncoder","uint8arr","curPos","bufferLen","writeUint8","writeVarUint","writeVarInt","writeVarString","unescape","encodeURIComponent","codePointAt","writeBinaryEncoder","append","writeUint8Array","leftCopyLen","rightCopyLen","writeVarUint8Array","writeOnDataView","verifyLen","dview","floatTestBed","setFloat32","writeFloat32","setFloat64","writeFloat64","setBigInt64","writeBigInt64","RleEncoder","writer","w","flushUintOptRleEncoder","UintOptRleEncoder","flushIntDiffOptRleEncoder","encodedDiff","IntDiffOptRleEncoder","StringEncoder","sarr","lensE","undefinedToNull","_localStorage","varStorage","_setPrototypeOf","ReactPropTypesSecret","emptyFunction","emptyFunctionWithReset","resetWarningCache","shim","propName","componentName","propFullName","secret","err","getShim","ReactPropTypes","elementType","instanceOf","objectOf","exact","checkPropTypes"],"mappings":"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","file":"static/js/5.5ef3ce1b.chunk.js","sourcesContent":["import defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nexport default function _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nif (process.env.NODE_ENV !== 'production') {\n  var ReactIs = require('react-is');\n\n  // By explicitly using `prop-types` you are opting into new development behavior.\n  // http://fb.me/prop-types-in-prod\n  var throwOnDirectAccess = true;\n  module.exports = require('./factoryWithTypeCheckers')(ReactIs.isElement, throwOnDirectAccess);\n} else {\n  // By explicitly using `prop-types` you are opting into new production behavior.\n  // http://fb.me/prop-types-in-prod\n  module.exports = require('./factoryWithThrowingShims')();\n}\n","var _typeof = require(\"@babel/runtime/helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","/**\n * Common Math expressions.\n *\n * @module math\n */\n\nexport const floor = Math.floor\nexport const ceil = Math.ceil\nexport const abs = Math.abs\nexport const imul = Math.imul\nexport const round = Math.round\nexport const log10 = Math.log10\nexport const log2 = Math.log2\nexport const log = Math.log\nexport const sqrt = Math.sqrt\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The sum of a and b\n */\nexport const add = (a, b) => a + b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The smaller element of a and b\n */\nexport const min = (a, b) => a < b ? a : b\n\n/**\n * @function\n * @param {number} a\n * @param {number} b\n * @return {number} The bigger element of a and b\n */\nexport const max = (a, b) => a > b ? a : b\n\nexport const isNaN = Number.isNaN\n\nexport const pow = Math.pow\n/**\n * Base 10 exponential function. Returns the value of 10 raised to the power of pow.\n *\n * @param {number} exp\n * @return {number}\n */\nexport const exp10 = exp => Math.pow(10, exp)\n\nexport const sign = Math.sign\n\n/**\n * @param {number} n\n * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0\n */\nexport const isNegativeZero = n => n !== 0 ? n < 0 : 1 / n < 0\n","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","import superPropBase from \"@babel/runtime/helpers/esm/superPropBase\";\nexport default function _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get;\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}","import getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nexport default function _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}","/**\n * Utility module to work with sets.\n *\n * @module set\n */\n\nexport const create = () => new Set()\n\n/**\n * @template T\n * @param {Set<T>} set\n * @return {Array<T>}\n */\nexport const toArray = set => Array.from(set)\n","/**\n * Utility module to work with Arrays.\n *\n * @module array\n */\n\n/**\n * Return the last element of an array. The element must exist\n *\n * @template L\n * @param {Array<L>} arr\n * @return {L}\n */\nexport const last = arr => arr[arr.length - 1]\n\n/**\n * @template C\n * @return {Array<C>}\n */\nexport const create = () => /** @type {Array<C>} */ ([])\n\n/**\n * @template D\n * @param {Array<D>} a\n * @return {Array<D>}\n */\nexport const copy = a => /** @type {Array<D>} */ (a.slice())\n\n/**\n * Append elements from src to dest\n *\n * @template M\n * @param {Array<M>} dest\n * @param {Array<M>} src\n */\nexport const appendTo = (dest, src) => {\n  for (let i = 0; i < src.length; i++) {\n    dest.push(src[i])\n  }\n}\n\n/**\n * Transforms something array-like to an actual Array.\n *\n * @function\n * @template T\n * @param {ArrayLike<T>|Iterable<T>} arraylike\n * @return {T}\n */\nexport const from = Array.from\n\n/**\n * True iff condition holds on every element in the Array.\n *\n * @function\n * @template ITEM\n *\n * @param {Array<ITEM>} arr\n * @param {function(ITEM, number, Array<ITEM>):boolean} f\n * @return {boolean}\n */\nexport const every = (arr, f) => arr.every(f)\n\n/**\n * True iff condition holds on some element in the Array.\n *\n * @function\n * @template S\n * @param {Array<S>} arr\n * @param {function(S, number, Array<S>):boolean} f\n * @return {boolean}\n */\nexport const some = (arr, f) => arr.some(f)\n\n/**\n * @template ELEM\n *\n * @param {Array<ELEM>} a\n * @param {Array<ELEM>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a.length === b.length && every(a, (item, index) => item === b[index])\n\n/**\n * @template ELEM\n * @param {Array<Array<ELEM>>} arr\n * @return {Array<ELEM>}\n */\nexport const flatten = arr => arr.reduce((acc, val) => acc.concat(val), [])\n","/**\n * Observable class prototype.\n *\n * @module observable\n */\n\nimport * as map from './map.js'\nimport * as set from './set.js'\nimport * as array from './array.js'\n\n/**\n * Handles named events.\n *\n * @template N\n */\nexport class Observable {\n  constructor () {\n    /**\n     * Some desc.\n     * @type {Map<N, any>}\n     */\n    this._observers = map.create()\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  on (name, f) {\n    map.setIfUndefined(this._observers, name, set.create).add(f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  once (name, f) {\n    /**\n     * @param  {...any} args\n     */\n    const _f = (...args) => {\n      this.off(name, _f)\n      f(...args)\n    }\n    this.on(name, _f)\n  }\n\n  /**\n   * @param {N} name\n   * @param {function} f\n   */\n  off (name, f) {\n    const observers = this._observers.get(name)\n    if (observers !== undefined) {\n      observers.delete(f)\n      if (observers.size === 0) {\n        this._observers.delete(name)\n      }\n    }\n  }\n\n  /**\n   * Emit a named event. All registered event listeners that listen to the\n   * specified name will receive the event.\n   *\n   * @todo This should catch exceptions\n   *\n   * @param {N} name The event name.\n   * @param {Array<any>} args The arguments that are applied to the event listener.\n   */\n  emit (name, args) {\n    // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.\n    return array.from((this._observers.get(name) || map.create()).values()).forEach(f => f(...args))\n  }\n\n  destroy () {\n    this._observers = map.create()\n  }\n}\n","/* eslint-env browser */\nexport const performance = typeof window === 'undefined' ? null : (typeof window.performance !== 'undefined' && window.performance) || null\n\nconst isoCrypto = typeof crypto === 'undefined' ? null : crypto\n\n/**\n * @type {function(number):ArrayBuffer}\n */\nexport const cryptoRandomBuffer = isoCrypto !== null\n  ? len => {\n    // browser\n    const buf = new ArrayBuffer(len)\n    const arr = new Uint8Array(buf)\n    isoCrypto.getRandomValues(arr)\n    return buf\n  }\n  : len => {\n    // polyfill\n    const buf = new ArrayBuffer(len)\n    const arr = new Uint8Array(buf)\n    for (let i = 0; i < len; i++) {\n      arr[i] = Math.ceil((Math.random() * 0xFFFFFFFF) >>> 0)\n    }\n    return buf\n  }\n","\n/**\n * Isomorphic module for true random numbers / buffers / uuids.\n *\n * Attention: falls back to Math.random if the browser does not support crypto.\n *\n * @module random\n */\n\nimport * as math from './math.js'\nimport { cryptoRandomBuffer } from './isomorphic.js'\n\nexport const rand = Math.random\n\n/* istanbul ignore next */\nexport const uint32 = () => new Uint32Array(cryptoRandomBuffer(4))[0]\n\n/**\n * @template T\n * @param {Array<T>} arr\n * @return {T}\n */\nexport const oneOf = arr => arr[math.floor(rand() * arr.length)]\n\n// @ts-ignore\nconst uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11\nexport const uuidv4 = () => uuidv4Template.replace(/[018]/g, /** @param {number} c */ c =>\n  (c ^ uint32() & 15 >> c / 4).toString(16)\n)\n","/**\n * Error helpers.\n *\n * @module error\n */\n\n/**\n * @param {string} s\n * @return {Error}\n */\n/* istanbul ignore next */\nexport const create = s => new Error(s)\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* istanbul ignore next */\nexport const methodUnimplemented = () => {\n  throw create('Method unimplemented')\n}\n\n/**\n * @throws {Error}\n * @return {never}\n */\n/* istanbul ignore next */\nexport const unexpectedCase = () => {\n  throw create('Unexpected case')\n}\n","/**\n * Utility functions for working with EcmaScript objects.\n *\n * @module object\n */\n\n/**\n * @return {Object<string,any>} obj\n */\nexport const create = () => Object.create(null)\n\n/**\n * Object.assign\n */\nexport const assign = Object.assign\n\n/**\n * @param {Object<string,any>} obj\n */\nexport const keys = Object.keys\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):any} f\n */\nexport const forEach = (obj, f) => {\n  for (const key in obj) {\n    f(obj[key], key)\n  }\n}\n\n/**\n * @template R\n * @param {Object<string,any>} obj\n * @param {function(any,string):R} f\n * @return {Array<R>}\n */\nexport const map = (obj, f) => {\n  const results = []\n  for (const key in obj) {\n    results.push(f(obj[key], key))\n  }\n  return results\n}\n\n/**\n * @param {Object<string,any>} obj\n * @return {number}\n */\nexport const length = obj => keys(obj).length\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nexport const some = (obj, f) => {\n  for (const key in obj) {\n    if (f(obj[key], key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * @param {Object<string,any>} obj\n * @param {function(any,string):boolean} f\n * @return {boolean}\n */\nexport const every = (obj, f) => {\n  for (const key in obj) {\n    if (!f(obj[key], key)) {\n      return false\n    }\n  }\n  return true\n}\n\n/**\n * Calls `Object.prototype.hasOwnProperty`.\n *\n * @param {any} obj\n * @param {string|symbol} key\n * @return {boolean}\n */\nexport const hasProperty = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key)\n\n/**\n * @param {Object<string,any>} a\n * @param {Object<string,any>} b\n * @return {boolean}\n */\nexport const equalFlat = (a, b) => a === b || (length(a) === length(b) && every(a, (val, key) => (val !== undefined || hasProperty(b, key)) && b[key] === val))\n","/**\n * Common functions and function call helpers.\n *\n * @module function\n */\n\nimport * as array from './array.js'\nimport * as object from './object.js'\n\n/**\n * Calls all functions in `fs` with args. Only throws after all functions were called.\n *\n * @param {Array<function>} fs\n * @param {Array<any>} args\n */\nexport const callAll = (fs, args, i = 0) => {\n  try {\n    for (; i < fs.length; i++) {\n      fs[i](...args)\n    }\n  } finally {\n    if (i < fs.length) {\n      callAll(fs, args, i + 1)\n    }\n  }\n}\n\nexport const nop = () => {}\n\n/**\n * @template T\n * @param {function():T} f\n * @return {T}\n */\nexport const apply = f => f()\n\n/**\n * @template A\n *\n * @param {A} a\n * @return {A}\n */\nexport const id = a => a\n\n/**\n * @template T\n *\n * @param {T} a\n * @param {T} b\n * @return {boolean}\n */\nexport const equalityStrict = (a, b) => a === b\n\n/**\n * @template T\n *\n * @param {Array<T>|object} a\n * @param {Array<T>|object} b\n * @return {boolean}\n */\nexport const equalityFlat = (a, b) => a === b || (a != null && b != null && a.constructor === b.constructor && ((a instanceof Array && array.equalFlat(a, /** @type {Array<T>} */ (b))) || (typeof a === 'object' && object.equalFlat(a, b))))\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nexport const equalityDeep = (a, b) => {\n  if (a == null || b == null) {\n    return equalityStrict(a, b)\n  }\n  if (a.constructor !== b.constructor) {\n    return false\n  }\n  if (a === b) {\n    return true\n  }\n  switch (a.constructor) {\n    case ArrayBuffer:\n      a = new Uint8Array(a)\n      b = new Uint8Array(b)\n    // eslint-disable-next-line no-fallthrough\n    case Uint8Array: {\n      if (a.byteLength !== b.byteLength) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n          return false\n        }\n      }\n      break\n    }\n    case Set: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const value of a) {\n        if (!b.has(value)) {\n          return false\n        }\n      }\n      break\n    }\n    case Map: {\n      if (a.size !== b.size) {\n        return false\n      }\n      for (const key of a.keys()) {\n        if (!b.has(key) || !equalityDeep(a.get(key), b.get(key))) {\n          return false\n        }\n      }\n      break\n    }\n    case Object:\n      if (object.length(a) !== object.length(b)) {\n        return false\n      }\n      for (const key in a) {\n        if (!object.hasProperty(a, key) || !equalityDeep(a[key], b[key])) {\n          return false\n        }\n      }\n      break\n    case Array:\n      if (a.length !== b.length) {\n        return false\n      }\n      for (let i = 0; i < a.length; i++) {\n        if (!equalityDeep(a[i], b[i])) {\n          return false\n        }\n      }\n      break\n    default:\n      return false\n  }\n  return true\n}\n","/**\n * Utility module to work with EcmaScript Symbols.\n *\n * @module symbol\n */\n\n/**\n * Return fresh symbol.\n *\n * @return {Symbol}\n */\nexport const create = Symbol\n\n/**\n * @param {any} s\n * @return {boolean}\n */\nexport const isSymbol = s => typeof s === 'symbol'\n","/**\n * Working with value pairs.\n *\n * @module pair\n */\n\n/**\n * @template L,R\n */\nexport class Pair {\n  /**\n   * @param {L} left\n   * @param {R} right\n   */\n  constructor (left, right) {\n    this.left = left\n    this.right = right\n  }\n}\n\n/**\n * @template L,R\n * @param {L} left\n * @param {R} right\n * @return {Pair<L,R>}\n */\nexport const create = (left, right) => new Pair(left, right)\n\n/**\n * @template L,R\n * @param {R} right\n * @param {L} left\n * @return {Pair<L,R>}\n */\nexport const createReversed = (right, left) => new Pair(left, right)\n\n/**\n * @template L,R\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):any} f\n */\nexport const forEach = (arr, f) => arr.forEach(p => f(p.left, p.right))\n\n/**\n * @template L,R,X\n * @param {Array<Pair<L,R>>} arr\n * @param {function(L, R):X} f\n * @return {Array<X>}\n */\nexport const map = (arr, f) => arr.map(p => f(p.left, p.right))\n","/* eslint-env browser */\n\n/**\n * Utility module to work with the DOM.\n *\n * @module dom\n */\n\nimport * as pair from './pair.js'\nimport * as map from './map.js'\n\n/* istanbul ignore next */\n/**\n * @type {Document}\n */\nexport const doc = /** @type {Document} */ (typeof document !== 'undefined' ? document : {})\n\n/**\n * @param {string} name\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nexport const createElement = name => doc.createElement(name)\n\n/**\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nexport const createDocumentFragment = () => doc.createDocumentFragment()\n\n/**\n * @param {string} text\n * @return {Text}\n */\n/* istanbul ignore next */\nexport const createTextNode = text => doc.createTextNode(text)\n\n/* istanbul ignore next */\nexport const domParser = /** @type {DOMParser} */ (typeof DOMParser !== 'undefined' ? new DOMParser() : null)\n\n/**\n * @param {HTMLElement} el\n * @param {string} name\n * @param {Object} opts\n */\n/* istanbul ignore next */\nexport const emitCustomEvent = (el, name, opts) => el.dispatchEvent(new CustomEvent(name, opts))\n\n/**\n * @param {Element} el\n * @param {Array<pair.Pair<string,string|boolean>>} attrs Array of key-value pairs\n * @return {Element}\n */\n/* istanbul ignore next */\nexport const setAttributes = (el, attrs) => {\n  pair.forEach(attrs, (key, value) => {\n    if (value === false) {\n      el.removeAttribute(key)\n    } else if (value === true) {\n      el.setAttribute(key, '')\n    } else {\n      // @ts-ignore\n      el.setAttribute(key, value)\n    }\n  })\n  return el\n}\n\n/**\n * @param {Element} el\n * @param {Map<string, string>} attrs Array of key-value pairs\n * @return {Element}\n */\n/* istanbul ignore next */\nexport const setAttributesMap = (el, attrs) => {\n  attrs.forEach((value, key) => { el.setAttribute(key, value) })\n  return el\n}\n\n/**\n * @param {Array<Node>|HTMLCollection} children\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nexport const fragment = children => {\n  const fragment = createDocumentFragment()\n  for (let i = 0; i < children.length; i++) {\n    appendChild(fragment, children[i])\n  }\n  return fragment\n}\n\n/**\n * @param {Element} parent\n * @param {Array<Node>} nodes\n * @return {Element}\n */\n/* istanbul ignore next */\nexport const append = (parent, nodes) => {\n  appendChild(parent, fragment(nodes))\n  return parent\n}\n\n/**\n * @param {HTMLElement} el\n */\n/* istanbul ignore next */\nexport const remove = el => el.remove()\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n/* istanbul ignore next */\nexport const addEventListener = (el, name, f) => el.addEventListener(name, f)\n\n/**\n * @param {EventTarget} el\n * @param {string} name\n * @param {EventListener} f\n */\n/* istanbul ignore next */\nexport const removeEventListener = (el, name, f) => el.removeEventListener(name, f)\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n/* istanbul ignore next */\nexport const addEventListeners = (node, listeners) => {\n  pair.forEach(listeners, (name, f) => addEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {Node} node\n * @param {Array<pair.Pair<string,EventListener>>} listeners\n * @return {Node}\n */\n/* istanbul ignore next */\nexport const removeEventListeners = (node, listeners) => {\n  pair.forEach(listeners, (name, f) => removeEventListener(node, name, f))\n  return node\n}\n\n/**\n * @param {string} name\n * @param {Array<pair.Pair<string,string>|pair.Pair<string,boolean>>} attrs Array of key-value pairs\n * @param {Array<Node>} children\n * @return {Element}\n */\n/* istanbul ignore next */\nexport const element = (name, attrs = [], children = []) =>\n  append(setAttributes(createElement(name), attrs), children)\n\n/**\n * @param {number} width\n * @param {number} height\n */\n/* istanbul ignore next */\nexport const canvas = (width, height) => {\n  const c = /** @type {HTMLCanvasElement} */ (createElement('canvas'))\n  c.height = height\n  c.width = width\n  return c\n}\n\n/**\n * @param {string} t\n * @return {Text}\n */\n/* istanbul ignore next */\nexport const text = createTextNode\n\n/**\n * @param {pair.Pair<string,string>} pair\n */\n/* istanbul ignore next */\nexport const pairToStyleString = pair => `${pair.left}:${pair.right};`\n\n/**\n * @param {Array<pair.Pair<string,string>>} pairs\n * @return {string}\n */\n/* istanbul ignore next */\nexport const pairsToStyleString = pairs => pairs.map(pairToStyleString).join('')\n\n/**\n * @param {Map<string,string>} m\n * @return {string}\n */\n/* istanbul ignore next */\nexport const mapToStyleString = m => map.map(m, (value, key) => `${key}:${value};`).join('')\n\n/**\n * @todo should always query on a dom element\n *\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {HTMLElement | null}\n */\n/* istanbul ignore next */\nexport const querySelector = (el, query) => el.querySelector(query)\n\n/**\n * @param {HTMLElement|ShadowRoot} el\n * @param {string} query\n * @return {NodeListOf<HTMLElement>}\n */\n/* istanbul ignore next */\nexport const querySelectorAll = (el, query) => el.querySelectorAll(query)\n\n/**\n * @param {string} id\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nexport const getElementById = id => /** @type {HTMLElement} */ (doc.getElementById(id))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nconst _parse = html => domParser.parseFromString(`<html><body>${html}</body></html>`, 'text/html').body\n\n/**\n * @param {string} html\n * @return {DocumentFragment}\n */\n/* istanbul ignore next */\nexport const parseFragment = html => fragment(/** @type {any} */ (_parse(html).childNodes))\n\n/**\n * @param {string} html\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nexport const parseElement = html => /** @type HTMLElement */ (_parse(html).firstElementChild)\n\n/**\n * @param {HTMLElement} oldEl\n * @param {HTMLElement|DocumentFragment} newEl\n */\n/* istanbul ignore next */\nexport const replaceWith = (oldEl, newEl) => oldEl.replaceWith(newEl)\n\n/**\n * @param {HTMLElement} parent\n * @param {HTMLElement} el\n * @param {Node|null} ref\n * @return {HTMLElement}\n */\n/* istanbul ignore next */\nexport const insertBefore = (parent, el, ref) => parent.insertBefore(el, ref)\n\n/**\n * @param {Node} parent\n * @param {Node} child\n * @return {Node}\n */\n/* istanbul ignore next */\nexport const appendChild = (parent, child) => parent.appendChild(child)\n\nexport const ELEMENT_NODE = doc.ELEMENT_NODE\nexport const TEXT_NODE = doc.TEXT_NODE\nexport const CDATA_SECTION_NODE = doc.CDATA_SECTION_NODE\nexport const COMMENT_NODE = doc.COMMENT_NODE\nexport const DOCUMENT_NODE = doc.DOCUMENT_NODE\nexport const DOCUMENT_TYPE_NODE = doc.DOCUMENT_TYPE_NODE\nexport const DOCUMENT_FRAGMENT_NODE = doc.DOCUMENT_FRAGMENT_NODE\n\n/**\n * @param {any} node\n * @param {number} type\n */\nexport const checkNodeType = (node, type) => node.nodeType === type\n\n/**\n * @param {Node} parent\n * @param {HTMLElement} child\n */\nexport const isParentOf = (parent, child) => {\n  let p = child.parentNode\n  while (p && p !== parent) {\n    p = p.parentNode\n  }\n  return p === parent\n}\n","/* global requestIdleCallback, requestAnimationFrame, cancelIdleCallback, cancelAnimationFrame */\n\n/**\n * Utility module to work with EcmaScript's event loop.\n *\n * @module eventloop\n */\n\n/**\n * @type {Array<function>}\n */\nlet queue = []\n\nconst _runQueue = () => {\n  for (let i = 0; i < queue.length; i++) {\n    queue[i]()\n  }\n  queue = []\n}\n\n/**\n * @param {function():void} f\n */\nexport const enqueue = f => {\n  queue.push(f)\n  if (queue.length === 1) {\n    setTimeout(_runQueue, 0)\n  }\n}\n\n/**\n * @typedef {Object} TimeoutObject\n * @property {function} TimeoutObject.destroy\n */\n\n/**\n * @param {function(number):void} clearFunction\n */\nconst createTimeoutClass = clearFunction => class TT {\n  /**\n   * @param {number} timeoutId\n   */\n  constructor (timeoutId) {\n    this._ = timeoutId\n  }\n\n  destroy () {\n    clearFunction(this._)\n  }\n}\n\nconst Timeout = createTimeoutClass(clearTimeout)\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nexport const timeout = (timeout, callback) => new Timeout(setTimeout(callback, timeout))\n\nconst Interval = createTimeoutClass(clearInterval)\n\n/**\n * @param {number} timeout\n * @param {function} callback\n * @return {TimeoutObject}\n */\nexport const interval = (timeout, callback) => new Interval(setInterval(callback, timeout))\n\n/* istanbul ignore next */\nexport const Animation = createTimeoutClass(arg => typeof requestAnimationFrame !== 'undefined' && cancelAnimationFrame(arg))\n\n/* istanbul ignore next */\n/**\n * @param {function(number):void} cb\n * @return {TimeoutObject}\n */\nexport const animationFrame = cb => typeof requestAnimationFrame === 'undefined' ? timeout(0, cb) : new Animation(requestAnimationFrame(cb))\n\n/* istanbul ignore next */\n// @ts-ignore\nconst Idle = createTimeoutClass(arg => typeof cancelIdleCallback !== 'undefined' && cancelIdleCallback(arg))\n\n/* istanbul ignore next */\n/**\n * Note: this is experimental and is probably only useful in browsers.\n *\n * @param {function} cb\n * @return {TimeoutObject}\n */\n// @ts-ignore\nexport const idleCallback = cb => typeof requestIdleCallback !== 'undefined' ? new Idle(requestIdleCallback(cb)) : timeout(1000, cb)\n\n/**\n * @param {number} timeout Timeout of the debounce action\n * @return {function(function():void):void}\n */\nexport const createDebouncer = timeout => {\n  let timer = -1\n  return f => {\n    clearTimeout(timer)\n    if (f) {\n      timer = /** @type {any} */ (setTimeout(f, timeout))\n    }\n  }\n}\n","/**\n * JSON utility functions.\n *\n * @module json\n */\n\n/**\n * Transform JavaScript object to JSON.\n *\n * @param {any} object\n * @return {string}\n */\nexport const stringify = JSON.stringify\n\n/**\n * Parse JSON object.\n *\n * @param {string} json\n * @return {any}\n */\nexport const parse = JSON.parse\n","/**\n * Utility module to work with time.\n *\n * @module time\n */\n\nimport * as metric from './metric.js'\nimport * as math from './math.js'\n\n/**\n * Return current time.\n *\n * @return {Date}\n */\nexport const getDate = () => new Date()\n\n/**\n * Return current unix time.\n *\n * @return {number}\n */\nexport const getUnixTime = Date.now\n\n/**\n * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10s.\n *\n * @param {number} d duration in milliseconds\n * @return {string} humanized approximation of time\n */\nexport const humanizeDuration = d => {\n  if (d < 60000) {\n    const p = metric.prefix(d, -1)\n    return math.round(p.n * 100) / 100 + p.prefix + 's'\n  }\n  d = math.floor(d / 1000)\n  const seconds = d % 60\n  const minutes = math.floor(d / 60) % 60\n  const hours = math.floor(d / 3600) % 24\n  const days = math.floor(d / 86400)\n  if (days > 0) {\n    return days + 'd' + ((hours > 0 || minutes > 30) ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '')\n  }\n  if (hours > 0) {\n    /* istanbul ignore next */\n    return hours + 'h' + ((minutes > 0 || seconds > 30) ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '')\n  }\n  return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '')\n}\n","/**\n * Isomorphic logging module with support for colors!\n *\n * @module logging\n */\n\nimport * as env from './environment.js'\nimport * as symbol from './symbol.js'\nimport * as pair from './pair.js'\nimport * as dom from './dom.js'\nimport * as json from './json.js'\nimport * as map from './map.js'\nimport * as eventloop from './eventloop.js'\nimport * as math from './math.js'\nimport * as time from './time.js'\nimport * as func from './function.js'\n\nexport const BOLD = symbol.create()\nexport const UNBOLD = symbol.create()\nexport const BLUE = symbol.create()\nexport const GREY = symbol.create()\nexport const GREEN = symbol.create()\nexport const RED = symbol.create()\nexport const PURPLE = symbol.create()\nexport const ORANGE = symbol.create()\nexport const UNCOLOR = symbol.create()\n\n/**\n * @type {Object<Symbol,pair.Pair<string,string>>}\n */\nconst _browserStyleMap = {\n  [BOLD]: pair.create('font-weight', 'bold'),\n  [UNBOLD]: pair.create('font-weight', 'normal'),\n  [BLUE]: pair.create('color', 'blue'),\n  [GREEN]: pair.create('color', 'green'),\n  [GREY]: pair.create('color', 'grey'),\n  [RED]: pair.create('color', 'red'),\n  [PURPLE]: pair.create('color', 'purple'),\n  [ORANGE]: pair.create('color', 'orange'), // not well supported in chrome when debugging node with inspector - TODO: deprecate\n  [UNCOLOR]: pair.create('color', 'black')\n}\n\nconst _nodeStyleMap = {\n  [BOLD]: '\\u001b[1m',\n  [UNBOLD]: '\\u001b[2m',\n  [BLUE]: '\\x1b[34m',\n  [GREEN]: '\\x1b[32m',\n  [GREY]: '\\u001b[37m',\n  [RED]: '\\x1b[31m',\n  [PURPLE]: '\\x1b[35m',\n  [ORANGE]: '\\x1b[38;5;208m',\n  [UNCOLOR]: '\\x1b[0m'\n}\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<string|object|number>}\n */\nconst computeBrowserLoggingArgs = args => {\n  const strBuilder = []\n  const styles = []\n  const currentStyle = map.create()\n  /**\n   * @type {Array<string|Object|number>}\n   */\n  let logArgs = []\n  // try with formatting until we find something unsupported\n  let i = 0\n\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _browserStyleMap[arg]\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right)\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        const style = dom.mapToStyleString(currentStyle)\n        if (i > 0 || style.length > 0) {\n          strBuilder.push('%c' + arg)\n          styles.push(style)\n        } else {\n          strBuilder.push(arg)\n        }\n      } else {\n        break\n      }\n    }\n  }\n\n  if (i > 0) {\n    // create logArgs with what we have so far\n    logArgs = styles\n    logArgs.unshift(strBuilder.join(''))\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg)\n    }\n  }\n  return logArgs\n}\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<string|object|number>}\n */\nconst computeNodeLoggingArgs = args => {\n  const strBuilder = []\n  const logArgs = []\n\n  // try with formatting until we find something unsupported\n  let i = 0\n\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _nodeStyleMap[arg]\n    if (style !== undefined) {\n      strBuilder.push(style)\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        strBuilder.push(arg)\n      } else {\n        break\n      }\n    }\n  }\n  if (i > 0) {\n    // create logArgs with what we have so far\n    strBuilder.push('\\x1b[0m')\n    logArgs.push(strBuilder.join(''))\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    /* istanbul ignore else */\n    if (!(arg instanceof Symbol)) {\n      logArgs.push(arg)\n    }\n  }\n  return logArgs\n}\n\n/* istanbul ignore next */\nconst computeLoggingArgs = env.isNode ? computeNodeLoggingArgs : computeBrowserLoggingArgs\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nexport const print = (...args) => {\n  console.log(...computeLoggingArgs(args))\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.print(args))\n}\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nexport const warn = (...args) => {\n  console.warn(...computeLoggingArgs(args))\n  args.unshift(ORANGE)\n  vconsoles.forEach(vc => vc.print(args))\n}\n\n/* istanbul ignore next */\n/**\n * @param {Error} err\n */\nexport const printError = err => {\n  console.error(err)\n  vconsoles.forEach(vc => vc.printError(err))\n}\n\n/* istanbul ignore next */\n/**\n * @param {string} url image location\n * @param {number} height height of the image in pixel\n */\nexport const printImg = (url, height) => {\n  if (env.isBrowser) {\n    console.log('%c                      ', `font-size: ${height}px; background-size: contain; background-repeat: no-repeat; background-image: url(${url})`)\n    // console.log('%c                ', `font-size: ${height}x; background: url(${url}) no-repeat;`)\n  }\n  vconsoles.forEach(vc => vc.printImg(url, height))\n}\n\n/* istanbul ignore next */\n/**\n * @param {string} base64\n * @param {number} height\n */\nexport const printImgBase64 = (base64, height) => printImg(`data:image/gif;base64,${base64}`, height)\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nexport const group = (...args) => {\n  console.group(...computeLoggingArgs(args))\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.group(args))\n}\n\n/**\n * @param {Array<string|Symbol|Object|number>} args\n */\nexport const groupCollapsed = (...args) => {\n  console.groupCollapsed(...computeLoggingArgs(args))\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.groupCollapsed(args))\n}\n\nexport const groupEnd = () => {\n  console.groupEnd()\n  /* istanbul ignore next */\n  vconsoles.forEach(vc => vc.groupEnd())\n}\n\n/* istanbul ignore next */\n/**\n * @param {function():Node} createNode\n */\nexport const printDom = createNode =>\n  vconsoles.forEach(vc => vc.printDom(createNode()))\n\n/* istanbul ignore next */\n/**\n * @param {HTMLCanvasElement} canvas\n * @param {number} height\n */\nexport const printCanvas = (canvas, height) => printImg(canvas.toDataURL(), height)\n\nexport const vconsoles = new Set()\n\n/* istanbul ignore next */\n/**\n * @param {Array<string|Symbol|Object|number>} args\n * @return {Array<Element>}\n */\nconst _computeLineSpans = args => {\n  const spans = []\n  const currentStyle = new Map()\n  // try with formatting until we find something unsupported\n  let i = 0\n  for (; i < args.length; i++) {\n    const arg = args[i]\n    // @ts-ignore\n    const style = _browserStyleMap[arg]\n    if (style !== undefined) {\n      currentStyle.set(style.left, style.right)\n    } else {\n      if (arg.constructor === String || arg.constructor === Number) {\n        // @ts-ignore\n        const span = dom.element('span', [pair.create('style', dom.mapToStyleString(currentStyle))], [dom.text(arg)])\n        if (span.innerHTML === '') {\n          span.innerHTML = '&nbsp;'\n        }\n        spans.push(span)\n      } else {\n        break\n      }\n    }\n  }\n  // append the rest\n  for (; i < args.length; i++) {\n    let content = args[i]\n    if (!(content instanceof Symbol)) {\n      if (content.constructor !== String && content.constructor !== Number) {\n        content = ' ' + json.stringify(content) + ' '\n      }\n      spans.push(dom.element('span', [], [dom.text(/** @type {string} */ (content))]))\n    }\n  }\n  return spans\n}\n\nconst lineStyle = 'font-family:monospace;border-bottom:1px solid #e2e2e2;padding:2px;'\n\n/* istanbul ignore next */\nexport class VConsole {\n  /**\n   * @param {Element} dom\n   */\n  constructor (dom) {\n    this.dom = dom\n    /**\n     * @type {Element}\n     */\n    this.ccontainer = this.dom\n    this.depth = 0\n    vconsoles.add(this)\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   * @param {boolean} collapsed\n   */\n  group (args, collapsed = false) {\n    eventloop.enqueue(() => {\n      const triangleDown = dom.element('span', [pair.create('hidden', collapsed), pair.create('style', 'color:grey;font-size:120%;')], [dom.text('')])\n      const triangleRight = dom.element('span', [pair.create('hidden', !collapsed), pair.create('style', 'color:grey;font-size:125%;')], [dom.text('')])\n      const content = dom.element('div', [pair.create('style', `${lineStyle};padding-left:${this.depth * 10}px`)], [triangleDown, triangleRight, dom.text(' ')].concat(_computeLineSpans(args)))\n      const nextContainer = dom.element('div', [pair.create('hidden', collapsed)])\n      const nextLine = dom.element('div', [], [content, nextContainer])\n      dom.append(this.ccontainer, [nextLine])\n      this.ccontainer = nextContainer\n      this.depth++\n      // when header is clicked, collapse/uncollapse container\n      dom.addEventListener(content, 'click', event => {\n        nextContainer.toggleAttribute('hidden')\n        triangleDown.toggleAttribute('hidden')\n        triangleRight.toggleAttribute('hidden')\n      })\n    })\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  groupCollapsed (args) {\n    this.group(args, true)\n  }\n\n  groupEnd () {\n    eventloop.enqueue(() => {\n      if (this.depth > 0) {\n        this.depth--\n        // @ts-ignore\n        this.ccontainer = this.ccontainer.parentElement.parentElement\n      }\n    })\n  }\n\n  /**\n   * @param {Array<string|Symbol|Object|number>} args\n   */\n  print (args) {\n    eventloop.enqueue(() => {\n      dom.append(this.ccontainer, [dom.element('div', [pair.create('style', `${lineStyle};padding-left:${this.depth * 10}px`)], _computeLineSpans(args))])\n    })\n  }\n\n  /**\n   * @param {Error} err\n   */\n  printError (err) {\n    this.print([RED, BOLD, err.toString()])\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} height\n   */\n  printImg (url, height) {\n    eventloop.enqueue(() => {\n      dom.append(this.ccontainer, [dom.element('img', [pair.create('src', url), pair.create('height', `${math.round(height * 1.5)}px`)])])\n    })\n  }\n\n  /**\n   * @param {Node} node\n   */\n  printDom (node) {\n    eventloop.enqueue(() => {\n      dom.append(this.ccontainer, [node])\n    })\n  }\n\n  destroy () {\n    eventloop.enqueue(() => {\n      vconsoles.delete(this)\n    })\n  }\n}\n\n/* istanbul ignore next */\n/**\n * @param {Element} dom\n */\nexport const createVConsole = dom => new VConsole(dom)\n\nconst loggingColors = [GREEN, PURPLE, ORANGE, BLUE]\nlet nextColor = 0\nlet lastLoggingTime = time.getUnixTime()\n\n/**\n * @param {string} moduleName\n * @return {function(...any):void}\n */\nexport const createModuleLogger = moduleName => {\n  const color = loggingColors[nextColor]\n  const debugRegexVar = env.getVariable('log')\n  const doLogging = debugRegexVar !== null && (debugRegexVar === '*' || debugRegexVar === 'true' || new RegExp(debugRegexVar, 'gi').test(moduleName))\n  nextColor = (nextColor + 1) % loggingColors.length\n  moduleName += ': '\n\n  return !doLogging ? func.nop : (...args) => {\n    const timeNow = time.getUnixTime()\n    const timeDiff = timeNow - lastLoggingTime\n    lastLoggingTime = timeNow\n    print(color, moduleName, UNCOLOR, ...args.map(arg => (typeof arg === 'string' || typeof arg === 'symbol') ? arg : JSON.stringify(arg)), color, ' +' + timeDiff + 'ms')\n  }\n}\n","/**\n * Utility module to create and manipulate Iterators.\n *\n * @module iterator\n */\n\n/**\n * @template T,R\n * @param {Iterator<T>} iterator\n * @param {function(T):R} f\n * @return {IterableIterator<R>}\n */\nexport const mapIterator = (iterator, f) => ({\n  /**\n   * @param {function(T):R} f\n   */\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next () {\n    const r = iterator.next()\n    return { value: r.done ? undefined : f(r.value), done: r.done }\n  }\n})\n\n/**\n * @template T\n * @param {function():IteratorResult<T>} next\n * @return {IterableIterator<T>}\n */\nexport const createIterator = next => ({\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return this\n  },\n  // @ts-ignore\n  next\n})\n\n/**\n * @template T\n * @param {Iterator<T>} iterator\n * @param {function(T):boolean} filter\n */\nexport const iteratorFilter = (iterator, filter) => createIterator(() => {\n  let res\n  do {\n    res = iterator.next()\n  } while (!res.done && !filter(res.value))\n  return res\n})\n\n/**\n * @template T,M\n * @param {Iterator<T>} iterator\n * @param {function(T):M} fmap\n */\nexport const iteratorMap = (iterator, fmap) => createIterator(() => {\n  const { done, value } = iterator.next()\n  return { done, value: done ? undefined : fmap(value) }\n})\n","\nimport * as binary from 'lib0/binary.js'\nimport * as decoding from 'lib0/decoding.js'\nimport * as encoding from 'lib0/encoding.js'\nimport * as logging from 'lib0/logging.js'\nimport * as math from 'lib0/math.js'\nimport {\n  createID,\n  readItemContent,\n  readDeleteSet,\n  writeDeleteSet,\n  Skip,\n  mergeDeleteSets,\n  DSEncoderV1,\n  DSEncoderV2,\n  decodeStateVector,\n  Item, GC, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2 // eslint-disable-line\n} from '../internals.js'\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n */\nfunction * lazyStructReaderGenerator (decoder) {\n  const numOfStateUpdates = decoding.readVarUint(decoder.restDecoder)\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = decoding.readVarUint(decoder.restDecoder)\n    const client = decoder.readClient()\n    let clock = decoding.readVarUint(decoder.restDecoder)\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo()\n      // @todo use switch instead of ifs\n      if (info === 10) {\n        const len = decoding.readVarUint(decoder.restDecoder)\n        yield new Skip(createID(client, clock), len)\n        clock += len\n      } else if ((binary.BITS5 & info) !== 0) {\n        const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0\n        // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n        // and we read the next string as parentYKey.\n        // It indicates how we store/retrieve parent from `y.share`\n        // @type {string|null}\n        const struct = new Item(\n          createID(client, clock),\n          null, // left\n          (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null, // origin\n          null, // right\n          (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null, // right origin\n          // @ts-ignore Force writing a string here.\n          cantCopyParentInfo ? (decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID()) : null, // parent\n          cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n          readItemContent(decoder, info) // item content\n        )\n        yield struct\n        clock += struct.length\n      } else {\n        const len = decoder.readLen()\n        yield new GC(createID(client, clock), len)\n        clock += len\n      }\n    }\n  }\n}\n\nexport class LazyStructReader {\n  /**\n   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n   * @param {boolean} filterSkips\n   */\n  constructor (decoder, filterSkips) {\n    this.gen = lazyStructReaderGenerator(decoder)\n    /**\n     * @type {null | Item | Skip | GC}\n     */\n    this.curr = null\n    this.done = false\n    this.filterSkips = filterSkips\n    this.next()\n  }\n\n  /**\n   * @return {Item | GC | Skip |null}\n   */\n  next () {\n    // ignore \"Skip\" structs\n    do {\n      this.curr = this.gen.next().value || null\n    } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip)\n    return this.curr\n  }\n}\n\n/**\n * @param {Uint8Array} update\n *\n */\nexport const logUpdate = update => logUpdateV2(update, UpdateDecoderV1)\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]\n *\n */\nexport const logUpdateV2 = (update, YDecoder = UpdateDecoderV2) => {\n  const structs = []\n  const updateDecoder = new YDecoder(decoding.createDecoder(update))\n  const lazyDecoder = new LazyStructReader(updateDecoder, false)\n  for (let curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {\n    structs.push(curr)\n  }\n  logging.print('Structs: ', structs)\n  const ds = readDeleteSet(updateDecoder)\n  logging.print('DeleteSet: ', ds)\n}\n\nexport class LazyStructWriter {\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  constructor (encoder) {\n    this.currClient = 0\n    this.startClock = 0\n    this.written = 0\n    this.encoder = encoder\n    /**\n     * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.\n     *\n     * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.\n     *\n     * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.\n     * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.\n     *\n     * @type {Array<{ written: number, restEncoder: Uint8Array }>}\n     */\n    this.clientStructs = []\n  }\n}\n\n/**\n * @param {Array<Uint8Array>} updates\n * @return {Uint8Array}\n */\nexport const mergeUpdates = updates => mergeUpdatesV2(updates, UpdateDecoderV1, UpdateEncoderV1)\n\n/**\n * @param {Uint8Array} update\n * @param {typeof DSEncoderV1 | typeof DSEncoderV2} YEncoder\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {Uint8Array}\n */\nexport const encodeStateVectorFromUpdateV2 = (update, YEncoder = DSEncoderV2, YDecoder = UpdateDecoderV2) => {\n  const encoder = new YEncoder()\n  const updateDecoder = new LazyStructReader(new YDecoder(decoding.createDecoder(update)), true)\n  let curr = updateDecoder.curr\n  if (curr !== null) {\n    let size = 1\n    let currClient = curr.id.client\n    let currClock = curr.id.clock\n    let stopCounting = false\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        size++\n        // We found a new client\n        // write what we have to the encoder\n        encoding.writeVarUint(encoder.restEncoder, currClient)\n        encoding.writeVarUint(encoder.restEncoder, currClock)\n        currClient = curr.id.client\n        stopCounting = false\n      }\n      if (curr.constructor === Skip) {\n        stopCounting = true\n      }\n      if (!stopCounting) {\n        currClock = curr.id.clock + curr.length\n      }\n    }\n    // write what we have\n    encoding.writeVarUint(encoder.restEncoder, currClient)\n    encoding.writeVarUint(encoder.restEncoder, currClock)\n    // prepend the size of the state vector\n    const enc = encoding.createEncoder()\n    encoding.writeVarUint(enc, size)\n    encoding.writeBinaryEncoder(enc, encoder.restEncoder)\n    encoder.restEncoder = enc\n    return encoder.toUint8Array()\n  } else {\n    encoding.writeVarUint(encoder.restEncoder, 0)\n    return encoder.toUint8Array()\n  }\n}\n\n/**\n * @param {Uint8Array} update\n * @return {Uint8Array}\n */\nexport const encodeStateVectorFromUpdate = update => encodeStateVectorFromUpdateV2(update, DSEncoderV1, UpdateDecoderV1)\n\n/**\n * @param {Uint8Array} update\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */\nexport const parseUpdateMetaV2 = (update, YDecoder = UpdateDecoderV2) => {\n  /**\n   * @type {Map<number, number>}\n   */\n  const from = new Map()\n  /**\n   * @type {Map<number, number>}\n   */\n  const to = new Map()\n  const updateDecoder = new LazyStructReader(new YDecoder(decoding.createDecoder(update)), false)\n  let curr = updateDecoder.curr\n  if (curr !== null) {\n    let currClient = curr.id.client\n    let currClock = curr.id.clock\n    // write the beginning to `from`\n    from.set(currClient, currClock)\n    for (; curr !== null; curr = updateDecoder.next()) {\n      if (currClient !== curr.id.client) {\n        // We found a new client\n        // write the end to `to`\n        to.set(currClient, currClock)\n        // write the beginning to `from`\n        from.set(curr.id.client, curr.id.clock)\n        // update currClient\n        currClient = curr.id.client\n      }\n      currClock = curr.id.clock + curr.length\n    }\n    // write the end to `to`\n    to.set(currClient, currClock)\n  }\n  return { from, to }\n}\n\n/**\n * @param {Uint8Array} update\n * @return {{ from: Map<number,number>, to: Map<number,number> }}\n */\nexport const parseUpdateMeta = update => parseUpdateMetaV2(update, UpdateDecoderV1)\n\n/**\n * This method is intended to slice any kind of struct and retrieve the right part.\n * It does not handle side-effects, so it should only be used by the lazy-encoder.\n *\n * @param {Item | GC | Skip} left\n * @param {number} diff\n * @return {Item | GC}\n */\nconst sliceStruct = (left, diff) => {\n  if (left.constructor === GC) {\n    const { client, clock } = left.id\n    return new GC(createID(client, clock + diff), left.length - diff)\n  } else if (left.constructor === Skip) {\n    const { client, clock } = left.id\n    return new Skip(createID(client, clock + diff), left.length - diff)\n  } else {\n    const leftItem = /** @type {Item} */ (left)\n    const { client, clock } = leftItem.id\n    return new Item(\n      createID(client, clock + diff),\n      null,\n      createID(client, clock + diff - 1),\n      null,\n      leftItem.rightOrigin,\n      leftItem.parent,\n      leftItem.parentSub,\n      leftItem.content.splice(diff)\n    )\n  }\n}\n\n/**\n *\n * This function works similarly to `readUpdateV2`.\n *\n * @param {Array<Uint8Array>} updates\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n * @return {Uint8Array}\n */\nexport const mergeUpdatesV2 = (updates, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  const updateDecoders = updates.map(update => new YDecoder(decoding.createDecoder(update)))\n  let lazyStructDecoders = updateDecoders.map(decoder => new LazyStructReader(decoder, true))\n\n  /**\n   * @todo we don't need offset because we always slice before\n   * @type {null | { struct: Item | GC | Skip, offset: number }}\n   */\n  let currWrite = null\n\n  const updateEncoder = new YEncoder()\n  // write structs lazily\n  const lazyStructEncoder = new LazyStructWriter(updateEncoder)\n\n  // Note: We need to ensure that all lazyStructDecoders are fully consumed\n  // Note: Should merge document updates whenever possible - even from different updates\n  // Note: Should handle that some operations cannot be applied yet ()\n\n  while (true) {\n    // Write higher clients first  sort by clientID & clock and remove decoders without content\n    lazyStructDecoders = lazyStructDecoders.filter(dec => dec.curr !== null)\n    lazyStructDecoders.sort(\n      /** @type {function(any,any):number} */ (dec1, dec2) => {\n        if (dec1.curr.id.client === dec2.curr.id.client) {\n          const clockDiff = dec1.curr.id.clock - dec2.curr.id.clock\n          if (clockDiff === 0) {\n            return dec1.curr.constructor === dec2.curr.constructor ? 0 : (\n              dec1.curr.constructor === Skip ? 1 : -1\n            )\n          } else {\n            return clockDiff\n          }\n        } else {\n          return dec2.curr.id.client - dec1.curr.id.client\n        }\n      }\n    )\n    if (lazyStructDecoders.length === 0) {\n      break\n    }\n    const currDecoder = lazyStructDecoders[0]\n    // write from currDecoder until the next operation is from another client or if filler-struct\n    // then we need to reorder the decoders and find the next operation to write\n    const firstClient = /** @type {Item | GC} */ (currDecoder.curr).id.client\n\n    if (currWrite !== null) {\n      let curr = /** @type {Item | GC | null} */ (currDecoder.curr)\n\n      // iterate until we find something that we haven't written already\n      // remember: first the high client-ids are written\n      while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {\n        curr = currDecoder.next()\n      }\n      if (curr === null || curr.id.client !== firstClient) {\n        continue\n      }\n\n      if (firstClient !== currWrite.struct.id.client) {\n        writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset)\n        currWrite = { struct: curr, offset: 0 }\n        currDecoder.next()\n      } else {\n        if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {\n          // @todo write currStruct & set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)\n          if (currWrite.struct.constructor === Skip) {\n            // extend existing skip\n            currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock\n          } else {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset)\n            const diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length\n            /**\n             * @type {Skip}\n             */\n            const struct = new Skip(createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff)\n            currWrite = { struct, offset: 0 }\n          }\n        } else { // if (currWrite.struct.id.clock + currWrite.struct.length >= curr.id.clock) {\n          const diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock\n          if (diff > 0) {\n            if (currWrite.struct.constructor === Skip) {\n              // prefer to slice Skip because the other struct might contain more information\n              currWrite.struct.length -= diff\n            } else {\n              curr = sliceStruct(curr, diff)\n            }\n          }\n          if (!currWrite.struct.mergeWith(/** @type {any} */ (curr))) {\n            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset)\n            currWrite = { struct: curr, offset: 0 }\n            currDecoder.next()\n          }\n        }\n      }\n    } else {\n      currWrite = { struct: /** @type {Item | GC} */ (currDecoder.curr), offset: 0 }\n      currDecoder.next()\n    }\n    for (\n      let next = currDecoder.curr;\n      next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip;\n      next = currDecoder.next()\n    ) {\n      writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset)\n      currWrite = { struct: next, offset: 0 }\n    }\n  }\n  if (currWrite !== null) {\n    writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset)\n    currWrite = null\n  }\n  finishLazyStructWriting(lazyStructEncoder)\n\n  const dss = updateDecoders.map(decoder => readDeleteSet(decoder))\n  const ds = mergeDeleteSets(dss)\n  writeDeleteSet(updateEncoder, ds)\n  return updateEncoder.toUint8Array()\n}\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]\n */\nexport const diffUpdateV2 = (update, sv, YDecoder = UpdateDecoderV2, YEncoder = UpdateEncoderV2) => {\n  const state = decodeStateVector(sv)\n  const encoder = new YEncoder()\n  const lazyStructWriter = new LazyStructWriter(encoder)\n  const decoder = new YDecoder(decoding.createDecoder(update))\n  const reader = new LazyStructReader(decoder, false)\n  while (reader.curr) {\n    const curr = reader.curr\n    const currClient = curr.id.client\n    const svClock = state.get(currClient) || 0\n    if (reader.curr.constructor === Skip) {\n      // the first written struct shouldn't be a skip\n      reader.next()\n      continue\n    }\n    if (curr.id.clock + curr.length > svClock) {\n      writeStructToLazyStructWriter(lazyStructWriter, curr, math.max(svClock - curr.id.clock, 0))\n      reader.next()\n      while (reader.curr && reader.curr.id.client === currClient) {\n        writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0)\n        reader.next()\n      }\n    } else {\n      // read until something new comes up\n      while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {\n        reader.next()\n      }\n    }\n  }\n  finishLazyStructWriting(lazyStructWriter)\n  // write ds\n  const ds = readDeleteSet(decoder)\n  writeDeleteSet(encoder, ds)\n  return encoder.toUint8Array()\n}\n\n/**\n * @param {Uint8Array} update\n * @param {Uint8Array} sv\n */\nexport const diffUpdate = (update, sv) => diffUpdateV2(update, sv, UpdateDecoderV1, UpdateEncoderV1)\n\n/**\n * @param {LazyStructWriter} lazyWriter\n */\nconst flushLazyStructWriter = lazyWriter => {\n  if (lazyWriter.written > 0) {\n    lazyWriter.clientStructs.push({ written: lazyWriter.written, restEncoder: encoding.toUint8Array(lazyWriter.encoder.restEncoder) })\n    lazyWriter.encoder.restEncoder = encoding.createEncoder()\n    lazyWriter.written = 0\n  }\n}\n\n/**\n * @param {LazyStructWriter} lazyWriter\n * @param {Item | GC} struct\n * @param {number} offset\n */\nconst writeStructToLazyStructWriter = (lazyWriter, struct, offset) => {\n  // flush curr if we start another client\n  if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {\n    flushLazyStructWriter(lazyWriter)\n  }\n  if (lazyWriter.written === 0) {\n    lazyWriter.currClient = struct.id.client\n    // write next client\n    lazyWriter.encoder.writeClient(struct.id.client)\n    // write startClock\n    encoding.writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset)\n  }\n  struct.write(lazyWriter.encoder, offset)\n  lazyWriter.written++\n}\n/**\n * Call this function when we collected all parts and want to\n * put all the parts together. After calling this method,\n * you can continue using the UpdateEncoder.\n *\n * @param {LazyStructWriter} lazyWriter\n */\nconst finishLazyStructWriting = (lazyWriter) => {\n  flushLazyStructWriter(lazyWriter)\n\n  // this is a fresh encoder because we called flushCurr\n  const restEncoder = lazyWriter.encoder.restEncoder\n\n  /**\n   * Now we put all the fragments together.\n   * This works similarly to `writeClientsStructs`\n   */\n\n  // write # states that were updated - i.e. the clients\n  encoding.writeVarUint(restEncoder, lazyWriter.clientStructs.length)\n\n  for (let i = 0; i < lazyWriter.clientStructs.length; i++) {\n    const partStructs = lazyWriter.clientStructs[i]\n    /**\n     * Works similarly to `writeStructs`\n     */\n    // write # encoded structs\n    encoding.writeVarUint(restEncoder, partStructs.written)\n    // write the rest of the fragment\n    encoding.writeUint8Array(restEncoder, partStructs.restEncoder)\n  }\n}\n","\nimport {\n  findIndexSS,\n  getState,\n  splitItem,\n  iterateStructs,\n  UpdateEncoderV2,\n  DSDecoderV1, DSEncoderV1, DSDecoderV2, DSEncoderV2, Item, GC, StructStore, Transaction, ID // eslint-disable-line\n} from '../internals.js'\n\nimport * as array from 'lib0/array.js'\nimport * as math from 'lib0/math.js'\nimport * as map from 'lib0/map.js'\nimport * as encoding from 'lib0/encoding.js'\nimport * as decoding from 'lib0/decoding.js'\n\nexport class DeleteItem {\n  /**\n   * @param {number} clock\n   * @param {number} len\n   */\n  constructor (clock, len) {\n    /**\n     * @type {number}\n     */\n    this.clock = clock\n    /**\n     * @type {number}\n     */\n    this.len = len\n  }\n}\n\n/**\n * We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.\n * - When created in a transaction, it must only be accessed after sorting, and merging\n *   - This DeleteSet is send to other clients\n * - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore\n * - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.\n */\nexport class DeleteSet {\n  constructor () {\n    /**\n     * @type {Map<number,Array<DeleteItem>>}\n     */\n    this.clients = new Map()\n  }\n}\n\n/**\n * Iterate over all structs that the DeleteSet gc's.\n *\n * @param {Transaction} transaction\n * @param {DeleteSet} ds\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nexport const iterateDeletedStructs = (transaction, ds, f) =>\n  ds.clients.forEach((deletes, clientid) => {\n    const structs = /** @type {Array<GC|Item>} */ (transaction.doc.store.clients.get(clientid))\n    for (let i = 0; i < deletes.length; i++) {\n      const del = deletes[i]\n      iterateStructs(transaction, structs, del.clock, del.len, f)\n    }\n  })\n\n/**\n * @param {Array<DeleteItem>} dis\n * @param {number} clock\n * @return {number|null}\n *\n * @private\n * @function\n */\nexport const findIndexDS = (dis, clock) => {\n  let left = 0\n  let right = dis.length - 1\n  while (left <= right) {\n    const midindex = math.floor((left + right) / 2)\n    const mid = dis[midindex]\n    const midclock = mid.clock\n    if (midclock <= clock) {\n      if (clock < midclock + mid.len) {\n        return midindex\n      }\n      left = midindex + 1\n    } else {\n      right = midindex - 1\n    }\n  }\n  return null\n}\n\n/**\n * @param {DeleteSet} ds\n * @param {ID} id\n * @return {boolean}\n *\n * @private\n * @function\n */\nexport const isDeleted = (ds, id) => {\n  const dis = ds.clients.get(id.client)\n  return dis !== undefined && findIndexDS(dis, id.clock) !== null\n}\n\n/**\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nexport const sortAndMergeDeleteSet = ds => {\n  ds.clients.forEach(dels => {\n    dels.sort((a, b) => a.clock - b.clock)\n    // merge items without filtering or splicing the array\n    // i is the current pointer\n    // j refers to the current insert position for the pointed item\n    // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]\n    let i, j\n    for (i = 1, j = 1; i < dels.length; i++) {\n      const left = dels[j - 1]\n      const right = dels[i]\n      if (left.clock + left.len >= right.clock) {\n        left.len = math.max(left.len, right.clock + right.len - left.clock)\n      } else {\n        if (j < i) {\n          dels[j] = right\n        }\n        j++\n      }\n    }\n    dels.length = j\n  })\n}\n\n/**\n * @param {Array<DeleteSet>} dss\n * @return {DeleteSet} A fresh DeleteSet\n */\nexport const mergeDeleteSets = dss => {\n  const merged = new DeleteSet()\n  for (let dssI = 0; dssI < dss.length; dssI++) {\n    dss[dssI].clients.forEach((delsLeft, client) => {\n      if (!merged.clients.has(client)) {\n        // Write all missing keys from current ds and all following.\n        // If merged already contains `client` current ds has already been added.\n        /**\n         * @type {Array<DeleteItem>}\n         */\n        const dels = delsLeft.slice()\n        for (let i = dssI + 1; i < dss.length; i++) {\n          array.appendTo(dels, dss[i].clients.get(client) || [])\n        }\n        merged.clients.set(client, dels)\n      }\n    })\n  }\n  sortAndMergeDeleteSet(merged)\n  return merged\n}\n\n/**\n * @param {DeleteSet} ds\n * @param {number} client\n * @param {number} clock\n * @param {number} length\n *\n * @private\n * @function\n */\nexport const addToDeleteSet = (ds, client, clock, length) => {\n  map.setIfUndefined(ds.clients, client, () => []).push(new DeleteItem(clock, length))\n}\n\nexport const createDeleteSet = () => new DeleteSet()\n\n/**\n * @param {StructStore} ss\n * @return {DeleteSet} Merged and sorted DeleteSet\n *\n * @private\n * @function\n */\nexport const createDeleteSetFromStructStore = ss => {\n  const ds = createDeleteSet()\n  ss.clients.forEach((structs, client) => {\n    /**\n     * @type {Array<DeleteItem>}\n     */\n    const dsitems = []\n    for (let i = 0; i < structs.length; i++) {\n      const struct = structs[i]\n      if (struct.deleted) {\n        const clock = struct.id.clock\n        let len = struct.length\n        if (i + 1 < structs.length) {\n          for (let next = structs[i + 1]; i + 1 < structs.length && next.id.clock === clock + len && next.deleted; next = structs[++i + 1]) {\n            len += next.length\n          }\n        }\n        dsitems.push(new DeleteItem(clock, len))\n      }\n    }\n    if (dsitems.length > 0) {\n      ds.clients.set(client, dsitems)\n    }\n  })\n  return ds\n}\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {DeleteSet} ds\n *\n * @private\n * @function\n */\nexport const writeDeleteSet = (encoder, ds) => {\n  encoding.writeVarUint(encoder.restEncoder, ds.clients.size)\n  ds.clients.forEach((dsitems, client) => {\n    encoder.resetDsCurVal()\n    encoding.writeVarUint(encoder.restEncoder, client)\n    const len = dsitems.length\n    encoding.writeVarUint(encoder.restEncoder, len)\n    for (let i = 0; i < len; i++) {\n      const item = dsitems[i]\n      encoder.writeDsClock(item.clock)\n      encoder.writeDsLen(item.len)\n    }\n  })\n}\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {DeleteSet}\n *\n * @private\n * @function\n */\nexport const readDeleteSet = decoder => {\n  const ds = new DeleteSet()\n  const numClients = decoding.readVarUint(decoder.restDecoder)\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal()\n    const client = decoding.readVarUint(decoder.restDecoder)\n    const numberOfDeletes = decoding.readVarUint(decoder.restDecoder)\n    if (numberOfDeletes > 0) {\n      const dsField = map.setIfUndefined(ds.clients, client, () => [])\n      for (let i = 0; i < numberOfDeletes; i++) {\n        dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()))\n      }\n    }\n  }\n  return ds\n}\n\n/**\n * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..\n */\n\n/**\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @return {Uint8Array|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.\n *\n * @private\n * @function\n */\nexport const readAndApplyDeleteSet = (decoder, transaction, store) => {\n  const unappliedDS = new DeleteSet()\n  const numClients = decoding.readVarUint(decoder.restDecoder)\n  for (let i = 0; i < numClients; i++) {\n    decoder.resetDsCurVal()\n    const client = decoding.readVarUint(decoder.restDecoder)\n    const numberOfDeletes = decoding.readVarUint(decoder.restDecoder)\n    const structs = store.clients.get(client) || []\n    const state = getState(store, client)\n    for (let i = 0; i < numberOfDeletes; i++) {\n      const clock = decoder.readDsClock()\n      const clockEnd = clock + decoder.readDsLen()\n      if (clock < state) {\n        if (state < clockEnd) {\n          addToDeleteSet(unappliedDS, client, state, clockEnd - state)\n        }\n        let index = findIndexSS(structs, clock)\n        /**\n         * We can ignore the case of GC and Delete structs, because we are going to skip them\n         * @type {Item}\n         */\n        // @ts-ignore\n        let struct = structs[index]\n        // split the first item if necessary\n        if (!struct.deleted && struct.id.clock < clock) {\n          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock))\n          index++ // increase we now want to use the next struct\n        }\n        while (index < structs.length) {\n          // @ts-ignore\n          struct = structs[index++]\n          if (struct.id.clock < clockEnd) {\n            if (!struct.deleted) {\n              if (clockEnd < struct.id.clock + struct.length) {\n                structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock))\n              }\n              struct.delete(transaction)\n            }\n          } else {\n            break\n          }\n        }\n      } else {\n        addToDeleteSet(unappliedDS, client, clock, clockEnd - clock)\n      }\n    }\n  }\n  if (unappliedDS.clients.size > 0) {\n    const ds = new UpdateEncoderV2()\n    encoding.writeVarUint(ds.restEncoder, 0) // encode 0 structs\n    writeDeleteSet(ds, unappliedDS)\n    return ds.toUint8Array()\n  }\n  return null\n}\n","/**\n * @module Y\n */\n\nimport {\n  StructStore,\n  AbstractType,\n  YArray,\n  YText,\n  YMap,\n  YXmlFragment,\n  transact,\n  ContentDoc, Item, Transaction, YEvent // eslint-disable-line\n} from '../internals.js'\n\nimport { Observable } from 'lib0/observable.js'\nimport * as random from 'lib0/random.js'\nimport * as map from 'lib0/map.js'\nimport * as array from 'lib0/array.js'\n\nexport const generateNewClientId = random.uint32\n\n/**\n * @typedef {Object} DocOpts\n * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)\n * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.\n * @property {string} [DocOpts.guid] Define a globally unique identifier for this document\n * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.\n * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.\n */\n\n/**\n * A Yjs instance handles the state of shared data.\n * @extends Observable<string>\n */\nexport class Doc extends Observable {\n  /**\n   * @param {DocOpts} [opts] configuration\n   */\n  constructor ({ guid = random.uuidv4(), gc = true, gcFilter = () => true, meta = null, autoLoad = false } = {}) {\n    super()\n    this.gc = gc\n    this.gcFilter = gcFilter\n    this.clientID = generateNewClientId()\n    this.guid = guid\n    /**\n     * @type {Map<string, AbstractType<YEvent>>}\n     */\n    this.share = new Map()\n    this.store = new StructStore()\n    /**\n     * @type {Transaction | null}\n     */\n    this._transaction = null\n    /**\n     * @type {Array<Transaction>}\n     */\n    this._transactionCleanups = []\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocs = new Set()\n    /**\n     * If this document is a subdocument - a document integrated into another document - then _item is defined.\n     * @type {Item?}\n     */\n    this._item = null\n    this.shouldLoad = autoLoad\n    this.autoLoad = autoLoad\n    this.meta = meta\n  }\n\n  /**\n   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).\n   *\n   * `load()` might be used in the future to request any provider to load the most current data.\n   *\n   * It is safe to call `load()` multiple times.\n   */\n  load () {\n    const item = this._item\n    if (item !== null && !this.shouldLoad) {\n      transact(/** @type {any} */ (item.parent).doc, transaction => {\n        transaction.subdocsLoaded.add(this)\n      }, null, true)\n    }\n    this.shouldLoad = true\n  }\n\n  getSubdocs () {\n    return this.subdocs\n  }\n\n  getSubdocGuids () {\n    return new Set(Array.from(this.subdocs).map(doc => doc.guid))\n  }\n\n  /**\n   * Changes that happen inside of a transaction are bundled. This means that\n   * the observer fires _after_ the transaction is finished and that all changes\n   * that happened inside of the transaction are sent as one message to the\n   * other peers.\n   *\n   * @param {function(Transaction):void} f The function that should be executed as a transaction\n   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin\n   *\n   * @public\n   */\n  transact (f, origin = null) {\n    transact(this, f, origin)\n  }\n\n  /**\n   * Define a shared data type.\n   *\n   * Multiple calls of `y.get(name, TypeConstructor)` yield the same result\n   * and do not overwrite each other. I.e.\n   * `y.define(name, Y.Array) === y.define(name, Y.Array)`\n   *\n   * After this method is called, the type is also available on `y.share.get(name)`.\n   *\n   * *Best Practices:*\n   * Define all types right after the Yjs instance is created and store them in a separate object.\n   * Also use the typed methods `getText(name)`, `getArray(name)`, ..\n   *\n   * @example\n   *   const y = new Y(..)\n   *   const appState = {\n   *     document: y.getText('document')\n   *     comments: y.getArray('comments')\n   *   }\n   *\n   * @param {string} name\n   * @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...\n   * @return {AbstractType<any>} The created type. Constructed with TypeConstructor\n   *\n   * @public\n   */\n  get (name, TypeConstructor = AbstractType) {\n    const type = map.setIfUndefined(this.share, name, () => {\n      // @ts-ignore\n      const t = new TypeConstructor()\n      t._integrate(this, null)\n      return t\n    })\n    const Constr = type.constructor\n    if (TypeConstructor !== AbstractType && Constr !== TypeConstructor) {\n      if (Constr === AbstractType) {\n        // @ts-ignore\n        const t = new TypeConstructor()\n        t._map = type._map\n        type._map.forEach(/** @param {Item?} n */ n => {\n          for (; n !== null; n = n.left) {\n            // @ts-ignore\n            n.parent = t\n          }\n        })\n        t._start = type._start\n        for (let n = t._start; n !== null; n = n.right) {\n          n.parent = t\n        }\n        t._length = type._length\n        this.share.set(name, t)\n        t._integrate(this, null)\n        return t\n      } else {\n        throw new Error(`Type with the name ${name} has already been defined with a different constructor`)\n      }\n    }\n    return type\n  }\n\n  /**\n   * @template T\n   * @param {string} [name]\n   * @return {YArray<T>}\n   *\n   * @public\n   */\n  getArray (name = '') {\n    // @ts-ignore\n    return this.get(name, YArray)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YText}\n   *\n   * @public\n   */\n  getText (name = '') {\n    // @ts-ignore\n    return this.get(name, YText)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YMap<any>}\n   *\n   * @public\n   */\n  getMap (name = '') {\n    // @ts-ignore\n    return this.get(name, YMap)\n  }\n\n  /**\n   * @param {string} [name]\n   * @return {YXmlFragment}\n   *\n   * @public\n   */\n  getXmlFragment (name = '') {\n    // @ts-ignore\n    return this.get(name, YXmlFragment)\n  }\n\n  /**\n   * Converts the entire document into a js object, recursively traversing each yjs type\n   * Doesn't log types that have not been defined (using ydoc.getType(..)).\n   *\n   * @deprecated Do not use this method and rather call toJSON directly on the shared types.\n   *\n   * @return {Object<string, any>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string, any>}\n     */\n    const doc = {}\n\n    this.share.forEach((value, key) => {\n      doc[key] = value.toJSON()\n    })\n\n    return doc\n  }\n\n  /**\n   * Emit `destroy` event and unregister all event handlers.\n   */\n  destroy () {\n    array.from(this.subdocs).forEach(subdoc => subdoc.destroy())\n    const item = this._item\n    if (item !== null) {\n      this._item = null\n      const content = /** @type {ContentDoc} */ (item.content)\n      if (item.deleted) {\n        // @ts-ignore\n        content.doc = null\n      } else {\n        content.doc = new Doc({ guid: this.guid, ...content.opts })\n        content.doc._item = item\n      }\n      transact(/** @type {any} */ (item).parent.doc, transaction => {\n        if (!item.deleted) {\n          transaction.subdocsAdded.add(content.doc)\n        }\n        transaction.subdocsRemoved.add(this)\n      }, null, true)\n    }\n    this.emit('destroyed', [true])\n    this.emit('destroy', [this])\n    super.destroy()\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {function(...any):any} f\n   */\n  on (eventName, f) {\n    super.on(eventName, f)\n  }\n\n  /**\n   * @param {string} eventName\n   * @param {function} f\n   */\n  off (eventName, f) {\n    super.off(eventName, f)\n  }\n}\n","import * as buffer from 'lib0/buffer.js'\nimport * as decoding from 'lib0/decoding.js'\nimport {\n  ID, createID\n} from '../internals.js'\n\nexport class DSDecoderV1 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    this.restDecoder = decoder\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n}\n\nexport class UpdateDecoderV1 extends DSDecoderV1 {\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return createID(decoding.readVarUint(this.restDecoder), decoding.readVarUint(this.restDecoder))\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return createID(decoding.readVarUint(this.restDecoder), decoding.readVarUint(this.restDecoder))\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return decoding.readUint8(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return decoding.readVarString(this.restDecoder)\n  }\n\n  /**\n   * @return {boolean} isKey\n   */\n  readParentInfo () {\n    return decoding.readVarUint(this.restDecoder) === 1\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number} len\n   */\n  readLen () {\n    return decoding.readVarUint(this.restDecoder)\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return decoding.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return buffer.copyUint8Array(decoding.readVarUint8Array(this.restDecoder))\n  }\n\n  /**\n   * Legacy implementation uses JSON parse. We use any-decoding in v2.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return JSON.parse(decoding.readVarString(this.restDecoder))\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    return decoding.readVarString(this.restDecoder)\n  }\n}\n\nexport class DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    /**\n     * @private\n     */\n    this.dsCurrVal = 0\n    this.restDecoder = decoder\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsClock () {\n    this.dsCurrVal += decoding.readVarUint(this.restDecoder)\n    return this.dsCurrVal\n  }\n\n  /**\n   * @return {number}\n   */\n  readDsLen () {\n    const diff = decoding.readVarUint(this.restDecoder) + 1\n    this.dsCurrVal += diff\n    return diff\n  }\n}\n\nexport class UpdateDecoderV2 extends DSDecoderV2 {\n  /**\n   * @param {decoding.Decoder} decoder\n   */\n  constructor (decoder) {\n    super(decoder)\n    /**\n     * List of cached keys. If the keys[id] does not exist, we read a new key\n     * from stringEncoder and push it to keys.\n     *\n     * @type {Array<string>}\n     */\n    this.keys = []\n    decoding.readVarUint(decoder) // read feature flag - currently unused\n    this.keyClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder))\n    this.clientDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder))\n    this.leftClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder))\n    this.rightClockDecoder = new decoding.IntDiffOptRleDecoder(decoding.readVarUint8Array(decoder))\n    this.infoDecoder = new decoding.RleDecoder(decoding.readVarUint8Array(decoder), decoding.readUint8)\n    this.stringDecoder = new decoding.StringDecoder(decoding.readVarUint8Array(decoder))\n    this.parentInfoDecoder = new decoding.RleDecoder(decoding.readVarUint8Array(decoder), decoding.readUint8)\n    this.typeRefDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder))\n    this.lenDecoder = new decoding.UintOptRleDecoder(decoding.readVarUint8Array(decoder))\n  }\n\n  /**\n   * @return {ID}\n   */\n  readLeftID () {\n    return new ID(this.clientDecoder.read(), this.leftClockDecoder.read())\n  }\n\n  /**\n   * @return {ID}\n   */\n  readRightID () {\n    return new ID(this.clientDecoder.read(), this.rightClockDecoder.read())\n  }\n\n  /**\n   * Read the next client id.\n   * Use this in favor of readID whenever possible to reduce the number of objects created.\n   */\n  readClient () {\n    return this.clientDecoder.read()\n  }\n\n  /**\n   * @return {number} info An unsigned 8-bit integer\n   */\n  readInfo () {\n    return /** @type {number} */ (this.infoDecoder.read())\n  }\n\n  /**\n   * @return {string}\n   */\n  readString () {\n    return this.stringDecoder.read()\n  }\n\n  /**\n   * @return {boolean}\n   */\n  readParentInfo () {\n    return this.parentInfoDecoder.read() === 1\n  }\n\n  /**\n   * @return {number} An unsigned 8-bit integer\n   */\n  readTypeRef () {\n    return this.typeRefDecoder.read()\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @return {number}\n   */\n  readLen () {\n    return this.lenDecoder.read()\n  }\n\n  /**\n   * @return {any}\n   */\n  readAny () {\n    return decoding.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {Uint8Array}\n   */\n  readBuf () {\n    return decoding.readVarUint8Array(this.restDecoder)\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @return {any}\n   */\n  readJSON () {\n    return decoding.readAny(this.restDecoder)\n  }\n\n  /**\n   * @return {string}\n   */\n  readKey () {\n    const keyClock = this.keyClockDecoder.read()\n    if (keyClock < this.keys.length) {\n      return this.keys[keyClock]\n    } else {\n      const key = this.stringDecoder.read()\n      this.keys.push(key)\n      return key\n    }\n  }\n}\n","\nimport * as error from 'lib0/error.js'\nimport * as encoding from 'lib0/encoding.js'\n\nimport {\n  ID // eslint-disable-line\n} from '../internals.js'\n\nexport class DSEncoderV1 {\n  constructor () {\n    this.restEncoder = encoding.createEncoder()\n  }\n\n  toUint8Array () {\n    return encoding.toUint8Array(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    // nop\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    encoding.writeVarUint(this.restEncoder, clock)\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    encoding.writeVarUint(this.restEncoder, len)\n  }\n}\n\nexport class UpdateEncoderV1 extends DSEncoderV1 {\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    encoding.writeVarUint(this.restEncoder, id.client)\n    encoding.writeVarUint(this.restEncoder, id.clock)\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    encoding.writeVarUint(this.restEncoder, id.client)\n    encoding.writeVarUint(this.restEncoder, id.clock)\n  }\n\n  /**\n   * Use writeClient and writeClock instead of writeID if possible.\n   * @param {number} client\n   */\n  writeClient (client) {\n    encoding.writeVarUint(this.restEncoder, client)\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    encoding.writeUint8(this.restEncoder, info)\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    encoding.writeVarString(this.restEncoder, s)\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    encoding.writeVarUint(this.restEncoder, isYKey ? 1 : 0)\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    encoding.writeVarUint(this.restEncoder, info)\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    encoding.writeVarUint(this.restEncoder, len)\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    encoding.writeAny(this.restEncoder, any)\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    encoding.writeVarUint8Array(this.restEncoder, buf)\n  }\n\n  /**\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    encoding.writeVarString(this.restEncoder, JSON.stringify(embed))\n  }\n\n  /**\n   * @param {string} key\n   */\n  writeKey (key) {\n    encoding.writeVarString(this.restEncoder, key)\n  }\n}\n\nexport class DSEncoderV2 {\n  constructor () {\n    this.restEncoder = encoding.createEncoder() // encodes all the rest / non-optimized\n    this.dsCurrVal = 0\n  }\n\n  toUint8Array () {\n    return encoding.toUint8Array(this.restEncoder)\n  }\n\n  resetDsCurVal () {\n    this.dsCurrVal = 0\n  }\n\n  /**\n   * @param {number} clock\n   */\n  writeDsClock (clock) {\n    const diff = clock - this.dsCurrVal\n    this.dsCurrVal = clock\n    encoding.writeVarUint(this.restEncoder, diff)\n  }\n\n  /**\n   * @param {number} len\n   */\n  writeDsLen (len) {\n    if (len === 0) {\n      error.unexpectedCase()\n    }\n    encoding.writeVarUint(this.restEncoder, len - 1)\n    this.dsCurrVal += len\n  }\n}\n\nexport class UpdateEncoderV2 extends DSEncoderV2 {\n  constructor () {\n    super()\n    /**\n     * @type {Map<string,number>}\n     */\n    this.keyMap = new Map()\n    /**\n     * Refers to the next uniqe key-identifier to me used.\n     * See writeKey method for more information.\n     *\n     * @type {number}\n     */\n    this.keyClock = 0\n    this.keyClockEncoder = new encoding.IntDiffOptRleEncoder()\n    this.clientEncoder = new encoding.UintOptRleEncoder()\n    this.leftClockEncoder = new encoding.IntDiffOptRleEncoder()\n    this.rightClockEncoder = new encoding.IntDiffOptRleEncoder()\n    this.infoEncoder = new encoding.RleEncoder(encoding.writeUint8)\n    this.stringEncoder = new encoding.StringEncoder()\n    this.parentInfoEncoder = new encoding.RleEncoder(encoding.writeUint8)\n    this.typeRefEncoder = new encoding.UintOptRleEncoder()\n    this.lenEncoder = new encoding.UintOptRleEncoder()\n  }\n\n  toUint8Array () {\n    const encoder = encoding.createEncoder()\n    encoding.writeVarUint(encoder, 0) // this is a feature flag that we might use in the future\n    encoding.writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, this.clientEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, encoding.toUint8Array(this.infoEncoder))\n    encoding.writeVarUint8Array(encoder, this.stringEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, encoding.toUint8Array(this.parentInfoEncoder))\n    encoding.writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array())\n    encoding.writeVarUint8Array(encoder, this.lenEncoder.toUint8Array())\n    // @note The rest encoder is appended! (note the missing var)\n    encoding.writeUint8Array(encoder, encoding.toUint8Array(this.restEncoder))\n    return encoding.toUint8Array(encoder)\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeLeftID (id) {\n    this.clientEncoder.write(id.client)\n    this.leftClockEncoder.write(id.clock)\n  }\n\n  /**\n   * @param {ID} id\n   */\n  writeRightID (id) {\n    this.clientEncoder.write(id.client)\n    this.rightClockEncoder.write(id.clock)\n  }\n\n  /**\n   * @param {number} client\n   */\n  writeClient (client) {\n    this.clientEncoder.write(client)\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeInfo (info) {\n    this.infoEncoder.write(info)\n  }\n\n  /**\n   * @param {string} s\n   */\n  writeString (s) {\n    this.stringEncoder.write(s)\n  }\n\n  /**\n   * @param {boolean} isYKey\n   */\n  writeParentInfo (isYKey) {\n    this.parentInfoEncoder.write(isYKey ? 1 : 0)\n  }\n\n  /**\n   * @param {number} info An unsigned 8-bit integer\n   */\n  writeTypeRef (info) {\n    this.typeRefEncoder.write(info)\n  }\n\n  /**\n   * Write len of a struct - well suited for Opt RLE encoder.\n   *\n   * @param {number} len\n   */\n  writeLen (len) {\n    this.lenEncoder.write(len)\n  }\n\n  /**\n   * @param {any} any\n   */\n  writeAny (any) {\n    encoding.writeAny(this.restEncoder, any)\n  }\n\n  /**\n   * @param {Uint8Array} buf\n   */\n  writeBuf (buf) {\n    encoding.writeVarUint8Array(this.restEncoder, buf)\n  }\n\n  /**\n   * This is mainly here for legacy purposes.\n   *\n   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.\n   *\n   * @param {any} embed\n   */\n  writeJSON (embed) {\n    encoding.writeAny(this.restEncoder, embed)\n  }\n\n  /**\n   * Property keys are often reused. For example, in y-prosemirror the key `bold` might\n   * occur very often. For a 3d application, the key `position` might occur very often.\n   *\n   * We cache these keys in a Map and refer to them via a unique number.\n   *\n   * @param {string} key\n   */\n  writeKey (key) {\n    const clock = this.keyMap.get(key)\n    if (clock === undefined) {\n      this.keyClockEncoder.write(this.keyClock++)\n      this.stringEncoder.write(key)\n    } else {\n      this.keyClockEncoder.write(this.keyClock++)\n    }\n  }\n}\n","\n/**\n * @module encoding\n */\n/*\n * We use the first five bits in the info flag for determining the type of the struct.\n *\n * 0: GC\n * 1: Item with Deleted content\n * 2: Item with JSON content\n * 3: Item with Binary content\n * 4: Item with String content\n * 5: Item with Embed content (for richtext content)\n * 6: Item with Format content (a formatting marker for richtext content)\n * 7: Item with Type\n */\n\nimport {\n  findIndexSS,\n  getState,\n  createID,\n  getStateVector,\n  readAndApplyDeleteSet,\n  writeDeleteSet,\n  createDeleteSetFromStructStore,\n  transact,\n  readItemContent,\n  UpdateDecoderV1,\n  UpdateDecoderV2,\n  UpdateEncoderV1,\n  UpdateEncoderV2,\n  DSEncoderV2,\n  DSDecoderV1,\n  DSEncoderV1,\n  mergeUpdatesV2,\n  Skip,\n  diffUpdateV2,\n  DSDecoderV2, Doc, Transaction, GC, Item, StructStore // eslint-disable-line\n} from '../internals.js'\n\nimport * as encoding from 'lib0/encoding.js'\nimport * as decoding from 'lib0/decoding.js'\nimport * as binary from 'lib0/binary.js'\nimport * as map from 'lib0/map.js'\nimport * as math from 'lib0/math.js'\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Array<GC|Item>} structs All structs by `client`\n * @param {number} client\n * @param {number} clock write structs starting with `ID(client,clock)`\n *\n * @function\n */\nconst writeStructs = (encoder, structs, client, clock) => {\n  // write first id\n  clock = math.max(clock, structs[0].id.clock) // make sure the first id exists\n  const startNewStructs = findIndexSS(structs, clock)\n  // write # encoded structs\n  encoding.writeVarUint(encoder.restEncoder, structs.length - startNewStructs)\n  encoder.writeClient(client)\n  encoding.writeVarUint(encoder.restEncoder, clock)\n  const firstStruct = structs[startNewStructs]\n  // write first struct with an offset\n  firstStruct.write(encoder, clock - firstStruct.id.clock)\n  for (let i = startNewStructs + 1; i < structs.length; i++) {\n    structs[i].write(encoder, 0)\n  }\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {StructStore} store\n * @param {Map<number,number>} _sm\n *\n * @private\n * @function\n */\nexport const writeClientsStructs = (encoder, store, _sm) => {\n  // we filter all valid _sm entries into sm\n  const sm = new Map()\n  _sm.forEach((clock, client) => {\n    // only write if new structs are available\n    if (getState(store, client) > clock) {\n      sm.set(client, clock)\n    }\n  })\n  getStateVector(store).forEach((clock, client) => {\n    if (!_sm.has(client)) {\n      sm.set(client, 0)\n    }\n  })\n  // write # states that were updated\n  encoding.writeVarUint(encoder.restEncoder, sm.size)\n  // Write items with higher client ids first\n  // This heavily improves the conflict algorithm.\n  Array.from(sm.entries()).sort((a, b) => b[0] - a[0]).forEach(([client, clock]) => {\n    // @ts-ignore\n    writeStructs(encoder, store.clients.get(client), client, clock)\n  })\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.\n * @param {Doc} doc\n * @return {Map<number, { i: number, refs: Array<Item | GC> }>}\n *\n * @private\n * @function\n */\nexport const readClientsStructRefs = (decoder, doc) => {\n  /**\n   * @type {Map<number, { i: number, refs: Array<Item | GC> }>}\n   */\n  const clientRefs = map.create()\n  const numOfStateUpdates = decoding.readVarUint(decoder.restDecoder)\n  for (let i = 0; i < numOfStateUpdates; i++) {\n    const numberOfStructs = decoding.readVarUint(decoder.restDecoder)\n    /**\n     * @type {Array<GC|Item>}\n     */\n    const refs = new Array(numberOfStructs)\n    const client = decoder.readClient()\n    let clock = decoding.readVarUint(decoder.restDecoder)\n    // const start = performance.now()\n    clientRefs.set(client, { i: 0, refs })\n    for (let i = 0; i < numberOfStructs; i++) {\n      const info = decoder.readInfo()\n      switch (binary.BITS5 & info) {\n        case 0: { // GC\n          const len = decoder.readLen()\n          refs[i] = new GC(createID(client, clock), len)\n          clock += len\n          break\n        }\n        case 10: { // Skip Struct (nothing to apply)\n          // @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.\n          const len = decoding.readVarUint(decoder.restDecoder)\n          refs[i] = new Skip(createID(client, clock), len)\n          clock += len\n          break\n        }\n        default: { // Item with content\n          /**\n           * The optimized implementation doesn't use any variables because inlining variables is faster.\n           * Below a non-optimized version is shown that implements the basic algorithm with\n           * a few comments\n           */\n          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const struct = new Item(\n            createID(client, clock),\n            null, // leftd\n            (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null, // origin\n            null, // right\n            (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null, // right origin\n            cantCopyParentInfo ? (decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID()) : null, // parent\n            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          )\n          /* A non-optimized implementation of the above algorithm:\n\n          // The item that was originally to the left of this item.\n          const origin = (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null\n          // The item that was originally to the right of this item.\n          const rightOrigin = (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null\n          const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0\n          const hasParentYKey = cantCopyParentInfo ? decoder.readParentInfo() : false\n          // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`\n          // and we read the next string as parentYKey.\n          // It indicates how we store/retrieve parent from `y.share`\n          // @type {string|null}\n          const parentYKey = cantCopyParentInfo && hasParentYKey ? decoder.readString() : null\n\n          const struct = new Item(\n            createID(client, clock),\n            null, // leftd\n            origin, // origin\n            null, // right\n            rightOrigin, // right origin\n            cantCopyParentInfo && !hasParentYKey ? decoder.readLeftID() : (parentYKey !== null ? doc.get(parentYKey) : null), // parent\n            cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub\n            readItemContent(decoder, info) // item content\n          )\n          */\n          refs[i] = struct\n          clock += struct.length\n        }\n      }\n    }\n    // console.log('time to read: ', performance.now() - start) // @todo remove\n  }\n  return clientRefs\n}\n\n/**\n * Resume computing structs generated by struct readers.\n *\n * While there is something to do, we integrate structs in this order\n * 1. top element on stack, if stack is not empty\n * 2. next element from current struct reader (if empty, use next struct reader)\n *\n * If struct causally depends on another struct (ref.missing), we put next reader of\n * `ref.id.client` on top of stack.\n *\n * At some point we find a struct that has no causal dependencies,\n * then we start emptying the stack.\n *\n * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)\n * depends on struct3 (from client1). Therefore the max stack size is eqaul to `structReaders.length`.\n *\n * This method is implemented in a way so that we can resume computation if this update\n * causally depends on another update.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {Map<number, { i: number, refs: (GC | Item)[] }>} clientsStructRefs\n * @return { null | { update: Uint8Array, missing: Map<number,number> } }\n *\n * @private\n * @function\n */\nconst integrateStructs = (transaction, store, clientsStructRefs) => {\n  /**\n   * @type {Array<Item | GC>}\n   */\n  const stack = []\n  // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.\n  let clientsStructRefsIds = Array.from(clientsStructRefs.keys()).sort((a, b) => a - b)\n  if (clientsStructRefsIds.length === 0) {\n    return null\n  }\n  const getNextStructTarget = () => {\n    if (clientsStructRefsIds.length === 0) {\n      return null\n    }\n    let nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]))\n    while (nextStructsTarget.refs.length === nextStructsTarget.i) {\n      clientsStructRefsIds.pop()\n      if (clientsStructRefsIds.length > 0) {\n        nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */ (clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]))\n      } else {\n        return null\n      }\n    }\n    return nextStructsTarget\n  }\n  let curStructsTarget = getNextStructTarget()\n  if (curStructsTarget === null && stack.length === 0) {\n    return null\n  }\n\n  /**\n   * @type {StructStore}\n   */\n  const restStructs = new StructStore()\n  const missingSV = new Map()\n  /**\n   * @param {number} client\n   * @param {number} clock\n   */\n  const updateMissingSv = (client, clock) => {\n    const mclock = missingSV.get(client)\n    if (mclock == null || mclock > clock) {\n      missingSV.set(client, clock)\n    }\n  }\n  /**\n   * @type {GC|Item}\n   */\n  let stackHead = /** @type {any} */ (curStructsTarget).refs[/** @type {any} */ (curStructsTarget).i++]\n  // caching the state because it is used very often\n  const state = new Map()\n\n  const addStackToRestSS = () => {\n    for (const item of stack) {\n      const client = item.id.client\n      const unapplicableItems = clientsStructRefs.get(client)\n      if (unapplicableItems) {\n        // decrement because we weren't able to apply previous operation\n        unapplicableItems.i--\n        restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i))\n        clientsStructRefs.delete(client)\n        unapplicableItems.i = 0\n        unapplicableItems.refs = []\n      } else {\n        // item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue\n        restStructs.clients.set(client, [item])\n      }\n      // remove client from clientsStructRefsIds to prevent users from applying the same update again\n      clientsStructRefsIds = clientsStructRefsIds.filter(c => c !== client)\n    }\n    stack.length = 0\n  }\n\n  // iterate over all struct readers until we are done\n  while (true) {\n    if (stackHead.constructor !== Skip) {\n      const localClock = map.setIfUndefined(state, stackHead.id.client, () => getState(store, stackHead.id.client))\n      const offset = localClock - stackHead.id.clock\n      if (offset < 0) {\n        // update from the same client is missing\n        stack.push(stackHead)\n        updateMissingSv(stackHead.id.client, stackHead.id.clock - 1)\n        // hid a dead wall, add all items from stack to restSS\n        addStackToRestSS()\n      } else {\n        const missing = stackHead.getMissing(transaction, store)\n        if (missing !== null) {\n          stack.push(stackHead)\n          // get the struct reader that has the missing struct\n          /**\n           * @type {{ refs: Array<GC|Item>, i: number }}\n           */\n          const structRefs = clientsStructRefs.get(/** @type {number} */ (missing)) || { refs: [], i: 0 }\n          if (structRefs.refs.length === structRefs.i) {\n            // This update message causally depends on another update message that doesn't exist yet\n            updateMissingSv(/** @type {number} */ (missing), getState(store, missing))\n            addStackToRestSS()\n          } else {\n            stackHead = structRefs.refs[structRefs.i++]\n            continue\n          }\n        } else if (offset === 0 || offset < stackHead.length) {\n          // all fine, apply the stackhead\n          stackHead.integrate(transaction, offset)\n          state.set(stackHead.id.client, stackHead.id.clock + stackHead.length)\n        }\n      }\n    }\n    // iterate to next stackHead\n    if (stack.length > 0) {\n      stackHead = /** @type {GC|Item} */ (stack.pop())\n    } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {\n      stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++])\n    } else {\n      curStructsTarget = getNextStructTarget()\n      if (curStructsTarget === null) {\n        // we are done!\n        break\n      } else {\n        stackHead = /** @type {GC|Item} */ (curStructsTarget.refs[curStructsTarget.i++])\n      }\n    }\n  }\n  if (restStructs.clients.size > 0) {\n    const encoder = new UpdateEncoderV2()\n    writeClientsStructs(encoder, restStructs, new Map())\n    // write empty deleteset\n    // writeDeleteSet(encoder, new DeleteSet())\n    encoding.writeVarUint(encoder.restEncoder, 0) // => no need for an extra function call, just write 0 deletes\n    return { missing: missingSV, update: encoder.toUint8Array() }\n  }\n  return null\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n *\n * @private\n * @function\n */\nexport const writeStructsFromTransaction = (encoder, transaction) => writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState)\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]\n *\n * @function\n */\nexport const readUpdateV2 = (decoder, ydoc, transactionOrigin, structDecoder = new UpdateDecoderV2(decoder)) =>\n  transact(ydoc, transaction => {\n    let retry = false\n    const doc = transaction.doc\n    const store = doc.store\n    // let start = performance.now()\n    const ss = readClientsStructRefs(structDecoder, doc)\n    // console.log('time to read structs: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    // console.log('time to merge: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const restStructs = integrateStructs(transaction, store, ss)\n    const pending = store.pendingStructs\n    if (pending) {\n      // check if we can apply something\n      for (const [client, clock] of pending.missing) {\n        if (clock < getState(store, client)) {\n          retry = true\n          break\n        }\n      }\n      if (restStructs) {\n        // merge restStructs into store.pending\n        for (const [client, clock] of restStructs.missing) {\n          const mclock = pending.missing.get(client)\n          if (mclock == null || mclock > clock) {\n            pending.missing.set(client, clock)\n          }\n        }\n        pending.update = mergeUpdatesV2([pending.update, restStructs.update])\n      }\n    } else {\n      store.pendingStructs = restStructs\n    }\n    // console.log('time to integrate: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    const dsRest = readAndApplyDeleteSet(structDecoder, transaction, store)\n    if (store.pendingDs) {\n      // @todo we could make a lower-bound state-vector check as we do above\n      const pendingDSUpdate = new UpdateDecoderV2(decoding.createDecoder(store.pendingDs))\n      decoding.readVarUint(pendingDSUpdate.restDecoder) // read 0 structs, because we only encode deletes in pendingdsupdate\n      const dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store)\n      if (dsRest && dsRest2) {\n        // case 1: ds1 != null && ds2 != null\n        store.pendingDs = mergeUpdatesV2([dsRest, dsRest2])\n      } else {\n        // case 2: ds1 != null\n        // case 3: ds2 != null\n        // case 4: ds1 == null && ds2 == null\n        store.pendingDs = dsRest || dsRest2\n      }\n    } else {\n      // Either dsRest == null && pendingDs == null OR dsRest != null\n      store.pendingDs = dsRest\n    }\n    // console.log('time to cleanup: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n\n    // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove\n    // start = performance.now()\n    if (retry) {\n      const update = /** @type {{update: Uint8Array}} */ (store.pendingStructs).update\n      store.pendingStructs = null\n      applyUpdateV2(transaction.doc, update)\n    }\n  }, transactionOrigin, false)\n\n/**\n * Read and apply a document update.\n *\n * This function has the same effect as `applyUpdate` but accepts an decoder.\n *\n * @param {decoding.Decoder} decoder\n * @param {Doc} ydoc\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nexport const readUpdate = (decoder, ydoc, transactionOrigin) => readUpdateV2(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder))\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]\n *\n * @function\n */\nexport const applyUpdateV2 = (ydoc, update, transactionOrigin, YDecoder = UpdateDecoderV2) => {\n  const decoder = decoding.createDecoder(update)\n  readUpdateV2(decoder, ydoc, transactionOrigin, new YDecoder(decoder))\n}\n\n/**\n * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.\n *\n * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.\n *\n * @param {Doc} ydoc\n * @param {Uint8Array} update\n * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`\n *\n * @function\n */\nexport const applyUpdate = (ydoc, update, transactionOrigin) => applyUpdateV2(ydoc, update, transactionOrigin, UpdateDecoderV1)\n\n/**\n * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will\n * only write the operations that are missing.\n *\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Doc} doc\n * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n *\n * @function\n */\nexport const writeStateAsUpdate = (encoder, doc, targetStateVector = new Map()) => {\n  writeClientsStructs(encoder, doc.store, targetStateVector)\n  writeDeleteSet(encoder, createDeleteSetFromStructStore(doc.store))\n}\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nexport const encodeStateAsUpdateV2 = (doc, encodedTargetStateVector = new Uint8Array([0]), encoder = new UpdateEncoderV2()) => {\n  const targetStateVector = decodeStateVector(encodedTargetStateVector)\n  writeStateAsUpdate(encoder, doc, targetStateVector)\n  const updates = [encoder.toUint8Array()]\n  // also add the pending updates (if there are any)\n  // @todo support diffirent encoders\n  if (encoder.constructor === UpdateEncoderV2) {\n    if (doc.store.pendingDs) {\n      updates.push(doc.store.pendingDs)\n    }\n    if (doc.store.pendingStructs) {\n      updates.push(diffUpdateV2(doc.store.pendingStructs.update, encodedTargetStateVector))\n    }\n    if (updates.length > 1) {\n      return mergeUpdatesV2(updates)\n    }\n  }\n  return updates[0]\n}\n\n/**\n * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will\n * only write the operations that are missing.\n *\n * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder\n *\n * @param {Doc} doc\n * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs\n * @return {Uint8Array}\n *\n * @function\n */\nexport const encodeStateAsUpdate = (doc, encodedTargetStateVector) => encodeStateAsUpdateV2(doc, encodedTargetStateVector, new UpdateEncoderV1())\n\n/**\n * Read state vector from Decoder and return as Map\n *\n * @param {DSDecoderV1 | DSDecoderV2} decoder\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nexport const readStateVector = decoder => {\n  const ss = new Map()\n  const ssLength = decoding.readVarUint(decoder.restDecoder)\n  for (let i = 0; i < ssLength; i++) {\n    const client = decoding.readVarUint(decoder.restDecoder)\n    const clock = decoding.readVarUint(decoder.restDecoder)\n    ss.set(client, clock)\n  }\n  return ss\n}\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\n// export const decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))\n\n/**\n * Read decodedState and return State as Map.\n *\n * @param {Uint8Array} decodedState\n * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.\n *\n * @function\n */\nexport const decodeStateVector = decodedState => readStateVector(new DSDecoderV1(decoding.createDecoder(decodedState)))\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Map<number,number>} sv\n * @function\n */\nexport const writeStateVector = (encoder, sv) => {\n  encoding.writeVarUint(encoder.restEncoder, sv.size)\n  sv.forEach((clock, client) => {\n    encoding.writeVarUint(encoder.restEncoder, client) // @todo use a special client decoder that is based on mapping\n    encoding.writeVarUint(encoder.restEncoder, clock)\n  })\n  return encoder\n}\n\n/**\n * @param {DSEncoderV1 | DSEncoderV2} encoder\n * @param {Doc} doc\n *\n * @function\n */\nexport const writeDocumentStateVector = (encoder, doc) => writeStateVector(encoder, getStateVector(doc.store))\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n *\n * @function\n */\nexport const encodeStateVectorV2 = (doc, encoder = new DSEncoderV2()) => {\n  if (doc instanceof Map) {\n    writeStateVector(encoder, doc)\n  } else {\n    writeDocumentStateVector(encoder, doc)\n  }\n  return encoder.toUint8Array()\n}\n\n/**\n * Encode State as Uint8Array.\n *\n * @param {Doc|Map<number,number>} doc\n * @return {Uint8Array}\n *\n * @function\n */\nexport const encodeStateVector = doc => encodeStateVectorV2(doc, new DSEncoderV1())\n","import * as f from 'lib0/function.js'\n\n/**\n * General event handler implementation.\n *\n * @template ARG0, ARG1\n *\n * @private\n */\nexport class EventHandler {\n  constructor () {\n    /**\n     * @type {Array<function(ARG0, ARG1):void>}\n     */\n    this.l = []\n  }\n}\n\n/**\n * @template ARG0,ARG1\n * @returns {EventHandler<ARG0,ARG1>}\n *\n * @private\n * @function\n */\nexport const createEventHandler = () => new EventHandler()\n\n/**\n * Adds an event listener that is called when\n * {@link EventHandler#callEventListeners} is called.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler.\n *\n * @private\n * @function\n */\nexport const addEventHandlerListener = (eventHandler, f) =>\n  eventHandler.l.push(f)\n\n/**\n * Removes an event listener.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {function(ARG0,ARG1):void} f The event handler that was added with\n *                     {@link EventHandler#addEventListener}\n *\n * @private\n * @function\n */\nexport const removeEventHandlerListener = (eventHandler, f) => {\n  const l = eventHandler.l\n  const len = l.length\n  eventHandler.l = l.filter(g => f !== g)\n  if (len === eventHandler.l.length) {\n    console.error('[yjs] Tried to remove event handler that doesn\\'t exist.')\n  }\n}\n\n/**\n * Removes all event listeners.\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n *\n * @private\n * @function\n */\nexport const removeAllEventHandlerListeners = eventHandler => {\n  eventHandler.l.length = 0\n}\n\n/**\n * Call all event listeners that were added via\n * {@link EventHandler#addEventListener}.\n *\n * @template ARG0,ARG1\n * @param {EventHandler<ARG0,ARG1>} eventHandler\n * @param {ARG0} arg0\n * @param {ARG1} arg1\n *\n * @private\n * @function\n */\nexport const callEventHandlerListeners = (eventHandler, arg0, arg1) =>\n  f.callAll(eventHandler.l, [arg0, arg1])\n","\nimport { AbstractType } from '../internals.js' // eslint-disable-line\n\nimport * as decoding from 'lib0/decoding.js'\nimport * as encoding from 'lib0/encoding.js'\nimport * as error from 'lib0/error.js'\n\nexport class ID {\n  /**\n   * @param {number} client client id\n   * @param {number} clock unique per client id, continuous number\n   */\n  constructor (client, clock) {\n    /**\n     * Client id\n     * @type {number}\n     */\n    this.client = client\n    /**\n     * unique per client id, continuous number\n     * @type {number}\n     */\n    this.clock = clock\n  }\n}\n\n/**\n * @param {ID | null} a\n * @param {ID | null} b\n * @return {boolean}\n *\n * @function\n */\nexport const compareIDs = (a, b) => a === b || (a !== null && b !== null && a.client === b.client && a.clock === b.clock)\n\n/**\n * @param {number} client\n * @param {number} clock\n *\n * @private\n * @function\n */\nexport const createID = (client, clock) => new ID(client, clock)\n\n/**\n * @param {encoding.Encoder} encoder\n * @param {ID} id\n *\n * @private\n * @function\n */\nexport const writeID = (encoder, id) => {\n  encoding.writeVarUint(encoder, id.client)\n  encoding.writeVarUint(encoder, id.clock)\n}\n\n/**\n * Read ID.\n * * If first varUint read is 0xFFFFFF a RootID is returned.\n * * Otherwise an ID is returned\n *\n * @param {decoding.Decoder} decoder\n * @return {ID}\n *\n * @private\n * @function\n */\nexport const readID = decoder =>\n  createID(decoding.readVarUint(decoder), decoding.readVarUint(decoder))\n\n/**\n * The top types are mapped from y.share.get(keyname) => type.\n * `type` does not store any information about the `keyname`.\n * This function finds the correct `keyname` for `type` and throws otherwise.\n *\n * @param {AbstractType<any>} type\n * @return {string}\n *\n * @private\n * @function\n */\nexport const findRootTypeKey = type => {\n  // @ts-ignore _y must be defined, otherwise unexpected case\n  for (const [key, value] of type.doc.share.entries()) {\n    if (value === type) {\n      return key\n    }\n  }\n  throw error.unexpectedCase()\n}\n","\nimport {\n  isDeleted,\n  createDeleteSetFromStructStore,\n  getStateVector,\n  getItemCleanStart,\n  iterateDeletedStructs,\n  writeDeleteSet,\n  writeStateVector,\n  readDeleteSet,\n  readStateVector,\n  createDeleteSet,\n  createID,\n  getState,\n  findIndexSS,\n  UpdateEncoderV2,\n  applyUpdateV2,\n  DSEncoderV1, DSEncoderV2, DSDecoderV1, DSDecoderV2, Transaction, Doc, DeleteSet, Item // eslint-disable-line\n} from '../internals.js'\n\nimport * as map from 'lib0/map.js'\nimport * as set from 'lib0/set.js'\nimport * as decoding from 'lib0/decoding.js'\nimport * as encoding from 'lib0/encoding.js'\n\nexport class Snapshot {\n  /**\n   * @param {DeleteSet} ds\n   * @param {Map<number,number>} sv state map\n   */\n  constructor (ds, sv) {\n    /**\n     * @type {DeleteSet}\n     */\n    this.ds = ds\n    /**\n     * State Map\n     * @type {Map<number,number>}\n     */\n    this.sv = sv\n  }\n}\n\n/**\n * @param {Snapshot} snap1\n * @param {Snapshot} snap2\n * @return {boolean}\n */\nexport const equalSnapshots = (snap1, snap2) => {\n  const ds1 = snap1.ds.clients\n  const ds2 = snap2.ds.clients\n  const sv1 = snap1.sv\n  const sv2 = snap2.sv\n  if (sv1.size !== sv2.size || ds1.size !== ds2.size) {\n    return false\n  }\n  for (const [key, value] of sv1.entries()) {\n    if (sv2.get(key) !== value) {\n      return false\n    }\n  }\n  for (const [client, dsitems1] of ds1.entries()) {\n    const dsitems2 = ds2.get(client) || []\n    if (dsitems1.length !== dsitems2.length) {\n      return false\n    }\n    for (let i = 0; i < dsitems1.length; i++) {\n      const dsitem1 = dsitems1[i]\n      const dsitem2 = dsitems2[i]\n      if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {\n        return false\n      }\n    }\n  }\n  return true\n}\n\n/**\n * @param {Snapshot} snapshot\n * @param {DSEncoderV1 | DSEncoderV2} [encoder]\n * @return {Uint8Array}\n */\nexport const encodeSnapshotV2 = (snapshot, encoder = new DSEncoderV2()) => {\n  writeDeleteSet(encoder, snapshot.ds)\n  writeStateVector(encoder, snapshot.sv)\n  return encoder.toUint8Array()\n}\n\n/**\n * @param {Snapshot} snapshot\n * @return {Uint8Array}\n */\nexport const encodeSnapshot = snapshot => encodeSnapshotV2(snapshot, new DSEncoderV1())\n\n/**\n * @param {Uint8Array} buf\n * @param {DSDecoderV1 | DSDecoderV2} [decoder]\n * @return {Snapshot}\n */\nexport const decodeSnapshotV2 = (buf, decoder = new DSDecoderV2(decoding.createDecoder(buf))) => {\n  return new Snapshot(readDeleteSet(decoder), readStateVector(decoder))\n}\n\n/**\n * @param {Uint8Array} buf\n * @return {Snapshot}\n */\nexport const decodeSnapshot = buf => decodeSnapshotV2(buf, new DSDecoderV1(decoding.createDecoder(buf)))\n\n/**\n * @param {DeleteSet} ds\n * @param {Map<number,number>} sm\n * @return {Snapshot}\n */\nexport const createSnapshot = (ds, sm) => new Snapshot(ds, sm)\n\nexport const emptySnapshot = createSnapshot(createDeleteSet(), new Map())\n\n/**\n * @param {Doc} doc\n * @return {Snapshot}\n */\nexport const snapshot = doc => createSnapshot(createDeleteSetFromStructStore(doc.store), getStateVector(doc.store))\n\n/**\n * @param {Item} item\n * @param {Snapshot|undefined} snapshot\n *\n * @protected\n * @function\n */\nexport const isVisible = (item, snapshot) => snapshot === undefined ? !item.deleted : (\n  snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !isDeleted(snapshot.ds, item.id)\n)\n\n/**\n * @param {Transaction} transaction\n * @param {Snapshot} snapshot\n */\nexport const splitSnapshotAffectedStructs = (transaction, snapshot) => {\n  const meta = map.setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, set.create)\n  const store = transaction.doc.store\n  // check if we already split for this snapshot\n  if (!meta.has(snapshot)) {\n    snapshot.sv.forEach((clock, client) => {\n      if (clock < getState(store, client)) {\n        getItemCleanStart(transaction, createID(client, clock))\n      }\n    })\n    iterateDeletedStructs(transaction, snapshot.ds, item => {})\n    meta.add(snapshot)\n  }\n}\n\n/**\n * @param {Doc} originDoc\n * @param {Snapshot} snapshot\n * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc\n * @return {Doc}\n */\nexport const createDocFromSnapshot = (originDoc, snapshot, newDoc = new Doc()) => {\n  if (originDoc.gc) {\n    // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted\n    throw new Error('originDoc must not be garbage collected')\n  }\n  const { sv, ds } = snapshot\n\n  const encoder = new UpdateEncoderV2()\n  originDoc.transact(transaction => {\n    let size = 0\n    sv.forEach(clock => {\n      if (clock > 0) {\n        size++\n      }\n    })\n    encoding.writeVarUint(encoder.restEncoder, size)\n    // splitting the structs before writing them to the encoder\n    for (const [client, clock] of sv) {\n      if (clock === 0) {\n        continue\n      }\n      if (clock < getState(originDoc.store, client)) {\n        getItemCleanStart(transaction, createID(client, clock))\n      }\n      const structs = originDoc.store.clients.get(client) || []\n      const lastStructIndex = findIndexSS(structs, clock - 1)\n      // write # encoded structs\n      encoding.writeVarUint(encoder.restEncoder, lastStructIndex + 1)\n      encoder.writeClient(client)\n      // first clock written is 0\n      encoding.writeVarUint(encoder.restEncoder, 0)\n      for (let i = 0; i <= lastStructIndex; i++) {\n        structs[i].write(encoder, 0)\n      }\n    }\n    writeDeleteSet(encoder, ds)\n  })\n\n  applyUpdateV2(newDoc, encoder.toUint8Array(), 'snapshot')\n  return newDoc\n}\n","\nimport {\n  GC,\n  splitItem,\n  Transaction, ID, Item, DSDecoderV2 // eslint-disable-line\n} from '../internals.js'\n\nimport * as math from 'lib0/math.js'\nimport * as error from 'lib0/error.js'\n\nexport class StructStore {\n  constructor () {\n    /**\n     * @type {Map<number,Array<GC|Item>>}\n     */\n    this.clients = new Map()\n    /**\n     * @type {null | { missing: Map<number, number>, update: Uint8Array }}\n     */\n    this.pendingStructs = null\n    /**\n     * @type {null | Uint8Array}\n     */\n    this.pendingDs = null\n  }\n}\n\n/**\n * Return the states as a Map<client,clock>.\n * Note that clock refers to the next expected clock id.\n *\n * @param {StructStore} store\n * @return {Map<number,number>}\n *\n * @public\n * @function\n */\nexport const getStateVector = store => {\n  const sm = new Map()\n  store.clients.forEach((structs, client) => {\n    const struct = structs[structs.length - 1]\n    sm.set(client, struct.id.clock + struct.length)\n  })\n  return sm\n}\n\n/**\n * @param {StructStore} store\n * @param {number} client\n * @return {number}\n *\n * @public\n * @function\n */\nexport const getState = (store, client) => {\n  const structs = store.clients.get(client)\n  if (structs === undefined) {\n    return 0\n  }\n  const lastStruct = structs[structs.length - 1]\n  return lastStruct.id.clock + lastStruct.length\n}\n\n/**\n * @param {StructStore} store\n *\n * @private\n * @function\n */\nexport const integretyCheck = store => {\n  store.clients.forEach(structs => {\n    for (let i = 1; i < structs.length; i++) {\n      const l = structs[i - 1]\n      const r = structs[i]\n      if (l.id.clock + l.length !== r.id.clock) {\n        throw new Error('StructStore failed integrety check')\n      }\n    }\n  })\n}\n\n/**\n * @param {StructStore} store\n * @param {GC|Item} struct\n *\n * @private\n * @function\n */\nexport const addStruct = (store, struct) => {\n  let structs = store.clients.get(struct.id.client)\n  if (structs === undefined) {\n    structs = []\n    store.clients.set(struct.id.client, structs)\n  } else {\n    const lastStruct = structs[structs.length - 1]\n    if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {\n      throw error.unexpectedCase()\n    }\n  }\n  structs.push(struct)\n}\n\n/**\n * Perform a binary search on a sorted array\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n * @return {number}\n *\n * @private\n * @function\n */\nexport const findIndexSS = (structs, clock) => {\n  let left = 0\n  let right = structs.length - 1\n  let mid = structs[right]\n  let midclock = mid.id.clock\n  if (midclock === clock) {\n    return right\n  }\n  // @todo does it even make sense to pivot the search?\n  // If a good split misses, it might actually increase the time to find the correct item.\n  // Currently, the only advantage is that search with pivoting might find the item on the first try.\n  let midindex = math.floor((clock / (midclock + mid.length - 1)) * right) // pivoting the search\n  while (left <= right) {\n    mid = structs[midindex]\n    midclock = mid.id.clock\n    if (midclock <= clock) {\n      if (clock < midclock + mid.length) {\n        return midindex\n      }\n      left = midindex + 1\n    } else {\n      right = midindex - 1\n    }\n    midindex = math.floor((left + right) / 2)\n  }\n  // Always check state before looking for a struct in StructStore\n  // Therefore the case of not finding a struct is unexpected\n  throw error.unexpectedCase()\n}\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {GC|Item}\n *\n * @private\n * @function\n */\nexport const find = (store, id) => {\n  /**\n   * @type {Array<GC|Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client)\n  return structs[findIndexSS(structs, id.clock)]\n}\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n * @private\n * @function\n */\nexport const getItem = /** @type {function(StructStore,ID):Item} */ (find)\n\n/**\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clock\n */\nexport const findIndexCleanStart = (transaction, structs, clock) => {\n  const index = findIndexSS(structs, clock)\n  const struct = structs[index]\n  if (struct.id.clock < clock && struct instanceof Item) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock))\n    return index + 1\n  }\n  return index\n}\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nexport const getItemCleanStart = (transaction, id) => {\n  const structs = /** @type {Array<Item>} */ (transaction.doc.store.clients.get(id.client))\n  return structs[findIndexCleanStart(transaction, structs, id.clock)]\n}\n\n/**\n * Expects that id is actually in store. This function throws or is an infinite loop otherwise.\n *\n * @param {Transaction} transaction\n * @param {StructStore} store\n * @param {ID} id\n * @return {Item}\n *\n * @private\n * @function\n */\nexport const getItemCleanEnd = (transaction, store, id) => {\n  /**\n   * @type {Array<Item>}\n   */\n  // @ts-ignore\n  const structs = store.clients.get(id.client)\n  const index = findIndexSS(structs, id.clock)\n  const struct = structs[index]\n  if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== GC) {\n    structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1))\n  }\n  return struct\n}\n\n/**\n * Replace `item` with `newitem` in store\n * @param {StructStore} store\n * @param {GC|Item} struct\n * @param {GC|Item} newStruct\n *\n * @private\n * @function\n */\nexport const replaceStruct = (store, struct, newStruct) => {\n  const structs = /** @type {Array<GC|Item>} */ (store.clients.get(struct.id.client))\n  structs[findIndexSS(structs, struct.id.clock)] = newStruct\n}\n\n/**\n * Iterate over a range of structs\n *\n * @param {Transaction} transaction\n * @param {Array<Item|GC>} structs\n * @param {number} clockStart Inclusive start\n * @param {number} len\n * @param {function(GC|Item):void} f\n *\n * @function\n */\nexport const iterateStructs = (transaction, structs, clockStart, len, f) => {\n  if (len === 0) {\n    return\n  }\n  const clockEnd = clockStart + len\n  let index = findIndexCleanStart(transaction, structs, clockStart)\n  let struct\n  do {\n    struct = structs[index++]\n    if (clockEnd < struct.id.clock + struct.length) {\n      findIndexCleanStart(transaction, structs, clockEnd)\n    }\n    f(struct)\n  } while (index < structs.length && structs[index].id.clock < clockEnd)\n}\n","\nimport {\n  getState,\n  writeStructsFromTransaction,\n  writeDeleteSet,\n  DeleteSet,\n  sortAndMergeDeleteSet,\n  getStateVector,\n  findIndexSS,\n  callEventHandlerListeners,\n  Item,\n  generateNewClientId,\n  createID,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, GC, StructStore, AbstractType, AbstractStruct, YEvent, Doc // eslint-disable-line\n} from '../internals.js'\n\nimport * as map from 'lib0/map.js'\nimport * as math from 'lib0/math.js'\nimport * as set from 'lib0/set.js'\nimport * as logging from 'lib0/logging.js'\nimport { callAll } from 'lib0/function.js'\n\n/**\n * A transaction is created for every change on the Yjs model. It is possible\n * to bundle changes on the Yjs model in a single transaction to\n * minimize the number on messages sent and the number of observer calls.\n * If possible the user of this library should bundle as many changes as\n * possible. Here is an example to illustrate the advantages of bundling:\n *\n * @example\n * const map = y.define('map', YMap)\n * // Log content when change is triggered\n * map.observe(() => {\n *   console.log('change triggered')\n * })\n * // Each change on the map type triggers a log message:\n * map.set('a', 0) // => \"change triggered\"\n * map.set('b', 0) // => \"change triggered\"\n * // When put in a transaction, it will trigger the log after the transaction:\n * y.transact(() => {\n *   map.set('a', 1)\n *   map.set('b', 1)\n * }) // => \"change triggered\"\n *\n * @public\n */\nexport class Transaction {\n  /**\n   * @param {Doc} doc\n   * @param {any} origin\n   * @param {boolean} local\n   */\n  constructor (doc, origin, local) {\n    /**\n     * The Yjs instance.\n     * @type {Doc}\n     */\n    this.doc = doc\n    /**\n     * Describes the set of deleted items by ids\n     * @type {DeleteSet}\n     */\n    this.deleteSet = new DeleteSet()\n    /**\n     * Holds the state before the transaction started.\n     * @type {Map<Number,Number>}\n     */\n    this.beforeState = getStateVector(doc.store)\n    /**\n     * Holds the state after the transaction.\n     * @type {Map<Number,Number>}\n     */\n    this.afterState = new Map()\n    /**\n     * All types that were directly modified (property added or child\n     * inserted/deleted). New types are not included in this Set.\n     * Maps from type to parentSubs (`item.parentSub = null` for YArray)\n     * @type {Map<AbstractType<YEvent>,Set<String|null>>}\n     */\n    this.changed = new Map()\n    /**\n     * Stores the events for the types that observe also child elements.\n     * It is mainly used by `observeDeep`.\n     * @type {Map<AbstractType<YEvent>,Array<YEvent>>}\n     */\n    this.changedParentTypes = new Map()\n    /**\n     * @type {Array<AbstractStruct>}\n     */\n    this._mergeStructs = []\n    /**\n     * @type {any}\n     */\n    this.origin = origin\n    /**\n     * Stores meta information on the transaction\n     * @type {Map<any,any>}\n     */\n    this.meta = new Map()\n    /**\n     * Whether this change originates from this doc.\n     * @type {boolean}\n     */\n    this.local = local\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsAdded = new Set()\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsRemoved = new Set()\n    /**\n     * @type {Set<Doc>}\n     */\n    this.subdocsLoaded = new Set()\n  }\n}\n\n/**\n * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n * @param {Transaction} transaction\n * @return {boolean} Whether data was written.\n */\nexport const writeUpdateMessageFromTransaction = (encoder, transaction) => {\n  if (transaction.deleteSet.clients.size === 0 && !map.any(transaction.afterState, (clock, client) => transaction.beforeState.get(client) !== clock)) {\n    return false\n  }\n  sortAndMergeDeleteSet(transaction.deleteSet)\n  writeStructsFromTransaction(encoder, transaction)\n  writeDeleteSet(encoder, transaction.deleteSet)\n  return true\n}\n\n/**\n * @param {Transaction} transaction\n *\n * @private\n * @function\n */\nexport const nextID = transaction => {\n  const y = transaction.doc\n  return createID(y.clientID, getState(y.store, y.clientID))\n}\n\n/**\n * If `type.parent` was added in current transaction, `type` technically\n * did not change, it was just added and we should not fire events for `type`.\n *\n * @param {Transaction} transaction\n * @param {AbstractType<YEvent>} type\n * @param {string|null} parentSub\n */\nexport const addChangedTypeToTransaction = (transaction, type, parentSub) => {\n  const item = type._item\n  if (item === null || (item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted)) {\n    map.setIfUndefined(transaction.changed, type, set.create).add(parentSub)\n  }\n}\n\n/**\n * @param {Array<AbstractStruct>} structs\n * @param {number} pos\n */\nconst tryToMergeWithLeft = (structs, pos) => {\n  const left = structs[pos - 1]\n  const right = structs[pos]\n  if (left.deleted === right.deleted && left.constructor === right.constructor) {\n    if (left.mergeWith(right)) {\n      structs.splice(pos, 1)\n      if (right instanceof Item && right.parentSub !== null && /** @type {AbstractType<any>} */ (right.parent)._map.get(right.parentSub) === right) {\n        /** @type {AbstractType<any>} */ (right.parent)._map.set(right.parentSub, /** @type {Item} */ (left))\n      }\n    }\n  }\n}\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nconst tryGcDeleteSet = (ds, store, gcFilter) => {\n  for (const [client, deleteItems] of ds.clients.entries()) {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client))\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di]\n      const endDeleteItemClock = deleteItem.clock + deleteItem.len\n      for (\n        let si = findIndexSS(structs, deleteItem.clock), struct = structs[si];\n        si < structs.length && struct.id.clock < endDeleteItemClock;\n        struct = structs[++si]\n      ) {\n        const struct = structs[si]\n        if (deleteItem.clock + deleteItem.len <= struct.id.clock) {\n          break\n        }\n        if (struct instanceof Item && struct.deleted && !struct.keep && gcFilter(struct)) {\n          struct.gc(store, false)\n        }\n      }\n    }\n  }\n}\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n */\nconst tryMergeDeleteSet = (ds, store) => {\n  // try to merge deleted / gc'd items\n  // merge from right to left for better efficiecy and so we don't miss any merge targets\n  ds.clients.forEach((deleteItems, client) => {\n    const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client))\n    for (let di = deleteItems.length - 1; di >= 0; di--) {\n      const deleteItem = deleteItems[di]\n      // start with merging the item next to the last deleted item\n      const mostRightIndexToCheck = math.min(structs.length - 1, 1 + findIndexSS(structs, deleteItem.clock + deleteItem.len - 1))\n      for (\n        let si = mostRightIndexToCheck, struct = structs[si];\n        si > 0 && struct.id.clock >= deleteItem.clock;\n        struct = structs[--si]\n      ) {\n        tryToMergeWithLeft(structs, si)\n      }\n    }\n  })\n}\n\n/**\n * @param {DeleteSet} ds\n * @param {StructStore} store\n * @param {function(Item):boolean} gcFilter\n */\nexport const tryGc = (ds, store, gcFilter) => {\n  tryGcDeleteSet(ds, store, gcFilter)\n  tryMergeDeleteSet(ds, store)\n}\n\n/**\n * @param {Array<Transaction>} transactionCleanups\n * @param {number} i\n */\nconst cleanupTransactions = (transactionCleanups, i) => {\n  if (i < transactionCleanups.length) {\n    const transaction = transactionCleanups[i]\n    const doc = transaction.doc\n    const store = doc.store\n    const ds = transaction.deleteSet\n    const mergeStructs = transaction._mergeStructs\n    try {\n      sortAndMergeDeleteSet(ds)\n      transaction.afterState = getStateVector(transaction.doc.store)\n      doc._transaction = null\n      doc.emit('beforeObserverCalls', [transaction, doc])\n      /**\n       * An array of event callbacks.\n       *\n       * Each callback is called even if the other ones throw errors.\n       *\n       * @type {Array<function():void>}\n       */\n      const fs = []\n      // observe events on changed types\n      transaction.changed.forEach((subs, itemtype) =>\n        fs.push(() => {\n          if (itemtype._item === null || !itemtype._item.deleted) {\n            itemtype._callObserver(transaction, subs)\n          }\n        })\n      )\n      fs.push(() => {\n        // deep observe events\n        transaction.changedParentTypes.forEach((events, type) =>\n          fs.push(() => {\n            // We need to think about the possibility that the user transforms the\n            // Y.Doc in the event.\n            if (type._item === null || !type._item.deleted) {\n              events = events\n                .filter(event =>\n                  event.target._item === null || !event.target._item.deleted\n                )\n              events\n                .forEach(event => {\n                  event.currentTarget = type\n                })\n              // sort events by path length so that top-level events are fired first.\n              events\n                .sort((event1, event2) => event1.path.length - event2.path.length)\n              // We don't need to check for events.length\n              // because we know it has at least one element\n              callEventHandlerListeners(type._dEH, events, transaction)\n            }\n          })\n        )\n        fs.push(() => doc.emit('afterTransaction', [transaction, doc]))\n      })\n      callAll(fs, [])\n    } finally {\n      // Replace deleted items with ItemDeleted / GC.\n      // This is where content is actually remove from the Yjs Doc.\n      if (doc.gc) {\n        tryGcDeleteSet(ds, store, doc.gcFilter)\n      }\n      tryMergeDeleteSet(ds, store)\n\n      // on all affected store.clients props, try to merge\n      transaction.afterState.forEach((clock, client) => {\n        const beforeClock = transaction.beforeState.get(client) || 0\n        if (beforeClock !== clock) {\n          const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client))\n          // we iterate from right to left so we can safely remove entries\n          const firstChangePos = math.max(findIndexSS(structs, beforeClock), 1)\n          for (let i = structs.length - 1; i >= firstChangePos; i--) {\n            tryToMergeWithLeft(structs, i)\n          }\n        }\n      })\n      // try to merge mergeStructs\n      // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left\n      //        but at the moment DS does not handle duplicates\n      for (let i = 0; i < mergeStructs.length; i++) {\n        const { client, clock } = mergeStructs[i].id\n        const structs = /** @type {Array<GC|Item>} */ (store.clients.get(client))\n        const replacedStructPos = findIndexSS(structs, clock)\n        if (replacedStructPos + 1 < structs.length) {\n          tryToMergeWithLeft(structs, replacedStructPos + 1)\n        }\n        if (replacedStructPos > 0) {\n          tryToMergeWithLeft(structs, replacedStructPos)\n        }\n      }\n      if (!transaction.local && transaction.afterState.get(doc.clientID) !== transaction.beforeState.get(doc.clientID)) {\n        doc.clientID = generateNewClientId()\n        logging.print(logging.ORANGE, logging.BOLD, '[yjs] ', logging.UNBOLD, logging.RED, 'Changed the client-id because another client seems to be using it.')\n      }\n      // @todo Merge all the transactions into one and provide send the data as a single update message\n      doc.emit('afterTransactionCleanup', [transaction, doc])\n      if (doc._observers.has('update')) {\n        const encoder = new UpdateEncoderV1()\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction)\n        if (hasContent) {\n          doc.emit('update', [encoder.toUint8Array(), transaction.origin, doc, transaction])\n        }\n      }\n      if (doc._observers.has('updateV2')) {\n        const encoder = new UpdateEncoderV2()\n        const hasContent = writeUpdateMessageFromTransaction(encoder, transaction)\n        if (hasContent) {\n          doc.emit('updateV2', [encoder.toUint8Array(), transaction.origin, doc, transaction])\n        }\n      }\n      transaction.subdocsAdded.forEach(subdoc => doc.subdocs.add(subdoc))\n      transaction.subdocsRemoved.forEach(subdoc => doc.subdocs.delete(subdoc))\n\n      doc.emit('subdocs', [{ loaded: transaction.subdocsLoaded, added: transaction.subdocsAdded, removed: transaction.subdocsRemoved }])\n      transaction.subdocsRemoved.forEach(subdoc => subdoc.destroy())\n\n      if (transactionCleanups.length <= i + 1) {\n        doc._transactionCleanups = []\n        doc.emit('afterAllTransactions', [doc, transactionCleanups])\n      } else {\n        cleanupTransactions(transactionCleanups, i + 1)\n      }\n    }\n  }\n}\n\n/**\n * Implements the functionality of `y.transact(()=>{..})`\n *\n * @param {Doc} doc\n * @param {function(Transaction):void} f\n * @param {any} [origin=true]\n *\n * @function\n */\nexport const transact = (doc, f, origin = null, local = true) => {\n  const transactionCleanups = doc._transactionCleanups\n  let initialCall = false\n  if (doc._transaction === null) {\n    initialCall = true\n    doc._transaction = new Transaction(doc, origin, local)\n    transactionCleanups.push(doc._transaction)\n    if (transactionCleanups.length === 1) {\n      doc.emit('beforeAllTransactions', [doc])\n    }\n    doc.emit('beforeTransaction', [doc._transaction, doc])\n  }\n  try {\n    f(doc._transaction)\n  } finally {\n    if (initialCall && transactionCleanups[0] === doc._transaction) {\n      // The first transaction ended, now process observer calls.\n      // Observer call may create new transactions for which we need to call the observers and do cleanup.\n      // We don't want to nest these calls, so we execute these calls one after\n      // another.\n      // Also we need to ensure that all cleanups are called, even if the\n      // observes throw errors.\n      // This file is full of hacky try {} finally {} blocks to ensure that an\n      // event can throw errors and also that the cleanup is called.\n      cleanupTransactions(transactionCleanups, 0)\n    }\n  }\n}\n","\nimport {\n  isDeleted,\n  Item, AbstractType, Transaction, AbstractStruct // eslint-disable-line\n} from '../internals.js'\n\nimport * as set from 'lib0/set.js'\nimport * as array from 'lib0/array.js'\n\n/**\n * YEvent describes the changes on a YType.\n */\nexport class YEvent {\n  /**\n   * @param {AbstractType<any>} target The changed type.\n   * @param {Transaction} transaction\n   */\n  constructor (target, transaction) {\n    /**\n     * The type on which this event was created on.\n     * @type {AbstractType<any>}\n     */\n    this.target = target\n    /**\n     * The current target on which the observe callback is called.\n     * @type {AbstractType<any>}\n     */\n    this.currentTarget = target\n    /**\n     * The transaction that triggered this event.\n     * @type {Transaction}\n     */\n    this.transaction = transaction\n    /**\n     * @type {Object|null}\n     */\n    this._changes = null\n    /**\n     * @type {null | Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n     */\n    this._keys = null\n    /**\n     * @type {null | Array<{ insert?: string | Array<any>, retain?: number, delete?: number, attributes?: Object<string, any> }>}\n     */\n    this._delta = null\n  }\n\n  /**\n   * Computes the path from `y` to the changed type.\n   *\n   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.\n   *\n   * The following property holds:\n   * @example\n   *   let type = y\n   *   event.path.forEach(dir => {\n   *     type = type.get(dir)\n   *   })\n   *   type === event.target // => true\n   */\n  get path () {\n    // @ts-ignore _item is defined because target is integrated\n    return getPathTo(this.currentTarget, this.target)\n  }\n\n  /**\n   * Check if a struct is deleted by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  deletes (struct) {\n    return isDeleted(this.transaction.deleteSet, struct.id)\n  }\n\n  /**\n   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}\n   */\n  get keys () {\n    if (this._keys === null) {\n      const keys = new Map()\n      const target = this.target\n      const changed = /** @type Set<string|null> */ (this.transaction.changed.get(target))\n      changed.forEach(key => {\n        if (key !== null) {\n          const item = /** @type {Item} */ (target._map.get(key))\n          /**\n           * @type {'delete' | 'add' | 'update'}\n           */\n          let action\n          let oldValue\n          if (this.adds(item)) {\n            let prev = item.left\n            while (prev !== null && this.adds(prev)) {\n              prev = prev.left\n            }\n            if (this.deletes(item)) {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'delete'\n                oldValue = array.last(prev.content.getContent())\n              } else {\n                return\n              }\n            } else {\n              if (prev !== null && this.deletes(prev)) {\n                action = 'update'\n                oldValue = array.last(prev.content.getContent())\n              } else {\n                action = 'add'\n                oldValue = undefined\n              }\n            }\n          } else {\n            if (this.deletes(item)) {\n              action = 'delete'\n              oldValue = array.last(/** @type {Item} */ item.content.getContent())\n            } else {\n              return // nop\n            }\n          }\n          keys.set(key, { action, oldValue })\n        }\n      })\n      this._keys = keys\n    }\n    return this._keys\n  }\n\n  /**\n   * @type {Array<{insert?: string | Array<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}\n   */\n  get delta () {\n    return this.changes.delta\n  }\n\n  /**\n   * Check if a struct is added by this event.\n   *\n   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.\n   *\n   * @param {AbstractStruct} struct\n   * @return {boolean}\n   */\n  adds (struct) {\n    return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0)\n  }\n\n  /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes () {\n    let changes = this._changes\n    if (changes === null) {\n      const target = this.target\n      const added = set.create()\n      const deleted = set.create()\n      /**\n       * @type {Array<{insert:Array<any>}|{delete:number}|{retain:number}>}\n       */\n      const delta = []\n      changes = {\n        added,\n        deleted,\n        delta,\n        keys: this.keys\n      }\n      const changed = /** @type Set<string|null> */ (this.transaction.changed.get(target))\n      if (changed.has(null)) {\n        /**\n         * @type {any}\n         */\n        let lastOp = null\n        const packOp = () => {\n          if (lastOp) {\n            delta.push(lastOp)\n          }\n        }\n        for (let item = target._start; item !== null; item = item.right) {\n          if (item.deleted) {\n            if (this.deletes(item) && !this.adds(item)) {\n              if (lastOp === null || lastOp.delete === undefined) {\n                packOp()\n                lastOp = { delete: 0 }\n              }\n              lastOp.delete += item.length\n              deleted.add(item)\n            } // else nop\n          } else {\n            if (this.adds(item)) {\n              if (lastOp === null || lastOp.insert === undefined) {\n                packOp()\n                lastOp = { insert: [] }\n              }\n              lastOp.insert = lastOp.insert.concat(item.content.getContent())\n              added.add(item)\n            } else {\n              if (lastOp === null || lastOp.retain === undefined) {\n                packOp()\n                lastOp = { retain: 0 }\n              }\n              lastOp.retain += item.length\n            }\n          }\n        }\n        if (lastOp !== null && lastOp.retain === undefined) {\n          packOp()\n        }\n      }\n      this._changes = changes\n    }\n    return /** @type {any} */ (changes)\n  }\n}\n\n/**\n * Compute the path from this type to the specified target.\n *\n * @example\n *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`\n *   const path = type.getPathTo(child)\n *   // assuming `type instanceof YArray`\n *   console.log(path) // might look like => [2, 'key1']\n *   child === type.get(path[0]).get(path[1])\n *\n * @param {AbstractType<any>} parent\n * @param {AbstractType<any>} child target\n * @return {Array<string|number>} Path to the target\n *\n * @private\n * @function\n */\nconst getPathTo = (parent, child) => {\n  const path = []\n  while (child._item !== null && child !== parent) {\n    if (child._item.parentSub !== null) {\n      // parent is map-ish\n      path.unshift(child._item.parentSub)\n    } else {\n      // parent is array-ish\n      let i = 0\n      let c = /** @type {AbstractType<any>} */ (child._item.parent)._start\n      while (c !== child._item && c !== null) {\n        if (!c.deleted) {\n          i++\n        }\n        c = c.right\n      }\n      path.unshift(i)\n    }\n    child = /** @type {AbstractType<any>} */ (child._item.parent)\n  }\n  return path\n}\n","\nimport {\n  removeEventHandlerListener,\n  callEventHandlerListeners,\n  addEventHandlerListener,\n  createEventHandler,\n  getState,\n  isVisible,\n  ContentType,\n  createID,\n  ContentAny,\n  ContentBinary,\n  getItemCleanStart,\n  ContentDoc, YText, YArray, UpdateEncoderV1, UpdateEncoderV2, Doc, Snapshot, Transaction, EventHandler, YEvent, Item, // eslint-disable-line\n} from '../internals.js'\n\nimport * as map from 'lib0/map.js'\nimport * as iterator from 'lib0/iterator.js'\nimport * as error from 'lib0/error.js'\nimport * as math from 'lib0/math.js'\n\nconst maxSearchMarker = 80\n\n/**\n * A unique timestamp that identifies each marker.\n *\n * Time is relative,.. this is more like an ever-increasing clock.\n *\n * @type {number}\n */\nlet globalSearchMarkerTimestamp = 0\n\nexport class ArraySearchMarker {\n  /**\n   * @param {Item} p\n   * @param {number} index\n   */\n  constructor (p, index) {\n    p.marker = true\n    this.p = p\n    this.index = index\n    this.timestamp = globalSearchMarkerTimestamp++\n  }\n}\n\n/**\n * @param {ArraySearchMarker} marker\n */\nconst refreshMarkerTimestamp = marker => { marker.timestamp = globalSearchMarkerTimestamp++ }\n\n/**\n * This is rather complex so this function is the only thing that should overwrite a marker\n *\n * @param {ArraySearchMarker} marker\n * @param {Item} p\n * @param {number} index\n */\nconst overwriteMarker = (marker, p, index) => {\n  marker.p.marker = false\n  marker.p = p\n  p.marker = true\n  marker.index = index\n  marker.timestamp = globalSearchMarkerTimestamp++\n}\n\n/**\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {Item} p\n * @param {number} index\n */\nconst markPosition = (searchMarker, p, index) => {\n  if (searchMarker.length >= maxSearchMarker) {\n    // override oldest marker (we don't want to create more objects)\n    const marker = searchMarker.reduce((a, b) => a.timestamp < b.timestamp ? a : b)\n    overwriteMarker(marker, p, index)\n    return marker\n  } else {\n    // create new marker\n    const pm = new ArraySearchMarker(p, index)\n    searchMarker.push(pm)\n    return pm\n  }\n}\n\n/**\n * Search marker help us to find positions in the associative array faster.\n *\n * They speed up the process of finding a position without much bookkeeping.\n *\n * A maximum of `maxSearchMarker` objects are created.\n *\n * This function always returns a refreshed marker (updated timestamp)\n *\n * @param {AbstractType<any>} yarray\n * @param {number} index\n */\nexport const findMarker = (yarray, index) => {\n  if (yarray._start === null || index === 0 || yarray._searchMarker === null) {\n    return null\n  }\n  const marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce((a, b) => math.abs(index - a.index) < math.abs(index - b.index) ? a : b)\n  let p = yarray._start\n  let pindex = 0\n  if (marker !== null) {\n    p = marker.p\n    pindex = marker.index\n    refreshMarkerTimestamp(marker) // we used it, we might need to use it again\n  }\n  // iterate to right if possible\n  while (p.right !== null && pindex < index) {\n    if (!p.deleted && p.countable) {\n      if (index < pindex + p.length) {\n        break\n      }\n      pindex += p.length\n    }\n    p = p.right\n  }\n  // iterate to left if necessary (might be that pindex > index)\n  while (p.left !== null && pindex > index) {\n    p = p.left\n    if (!p.deleted && p.countable) {\n      pindex -= p.length\n    }\n  }\n  // we want to make sure that p can't be merged with left, because that would screw up everything\n  // in that cas just return what we have (it is most likely the best marker anyway)\n  // iterate to left until p can't be merged with left\n  while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {\n    p = p.left\n    if (!p.deleted && p.countable) {\n      pindex -= p.length\n    }\n  }\n\n  // @todo remove!\n  // assure position\n  // {\n  //   let start = yarray._start\n  //   let pos = 0\n  //   while (start !== p) {\n  //     if (!start.deleted && start.countable) {\n  //       pos += start.length\n  //     }\n  //     start = /** @type {Item} */ (start.right)\n  //   }\n  //   if (pos !== pindex) {\n  //     debugger\n  //     throw new Error('Gotcha position fail!')\n  //   }\n  // }\n  // if (marker) {\n  //   if (window.lengthes == null) {\n  //     window.lengthes = []\n  //     window.getLengthes = () => window.lengthes.sort((a, b) => a - b)\n  //   }\n  //   window.lengthes.push(marker.index - pindex)\n  //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)\n  // }\n  if (marker !== null && math.abs(marker.index - pindex) < /** @type {YText|YArray<any>} */ (p.parent).length / maxSearchMarker) {\n    // adjust existing marker\n    overwriteMarker(marker, p, pindex)\n    return marker\n  } else {\n    // create new marker\n    return markPosition(yarray._searchMarker, p, pindex)\n  }\n}\n\n/**\n * Update markers when a change happened.\n *\n * This should be called before doing a deletion!\n *\n * @param {Array<ArraySearchMarker>} searchMarker\n * @param {number} index\n * @param {number} len If insertion, len is positive. If deletion, len is negative.\n */\nexport const updateMarkerChanges = (searchMarker, index, len) => {\n  for (let i = searchMarker.length - 1; i >= 0; i--) {\n    const m = searchMarker[i]\n    if (len > 0) {\n      /**\n       * @type {Item|null}\n       */\n      let p = m.p\n      p.marker = false\n      // Ideally we just want to do a simple position comparison, but this will only work if\n      // search markers don't point to deleted items for formats.\n      // Iterate marker to prev undeleted countable position so we know what to do when updating a position\n      while (p && (p.deleted || !p.countable)) {\n        p = p.left\n        if (p && !p.deleted && p.countable) {\n          // adjust position. the loop should break now\n          m.index -= p.length\n        }\n      }\n      if (p === null || p.marker === true) {\n        // remove search marker if updated position is null or if position is already marked\n        searchMarker.splice(i, 1)\n        continue\n      }\n      m.p = p\n      p.marker = true\n    }\n    if (index < m.index || (len > 0 && index === m.index)) { // a simple index <= m.index check would actually suffice\n      m.index = math.max(index, m.index + len)\n    }\n  }\n}\n\n/**\n * Accumulate all (list) children of a type and return them as an Array.\n *\n * @param {AbstractType<any>} t\n * @return {Array<Item>}\n */\nexport const getTypeChildren = t => {\n  let s = t._start\n  const arr = []\n  while (s) {\n    arr.push(s)\n    s = s.right\n  }\n  return arr\n}\n\n/**\n * Call event listeners with an event. This will also add an event to all\n * parents (for `.observeDeep` handlers).\n *\n * @template EventType\n * @param {AbstractType<EventType>} type\n * @param {Transaction} transaction\n * @param {EventType} event\n */\nexport const callTypeObservers = (type, transaction, event) => {\n  const changedType = type\n  const changedParentTypes = transaction.changedParentTypes\n  while (true) {\n    // @ts-ignore\n    map.setIfUndefined(changedParentTypes, type, () => []).push(event)\n    if (type._item === null) {\n      break\n    }\n    type = /** @type {AbstractType<any>} */ (type._item.parent)\n  }\n  callEventHandlerListeners(changedType._eH, event, transaction)\n}\n\n/**\n * @template EventType\n * Abstract Yjs Type class\n */\nexport class AbstractType {\n  constructor () {\n    /**\n     * @type {Item|null}\n     */\n    this._item = null\n    /**\n     * @type {Map<string,Item>}\n     */\n    this._map = new Map()\n    /**\n     * @type {Item|null}\n     */\n    this._start = null\n    /**\n     * @type {Doc|null}\n     */\n    this.doc = null\n    this._length = 0\n    /**\n     * Event handlers\n     * @type {EventHandler<EventType,Transaction>}\n     */\n    this._eH = createEventHandler()\n    /**\n     * Deep event handlers\n     * @type {EventHandler<Array<YEvent>,Transaction>}\n     */\n    this._dEH = createEventHandler()\n    /**\n     * @type {null | Array<ArraySearchMarker>}\n     */\n    this._searchMarker = null\n  }\n\n  /**\n   * @return {AbstractType<any>|null}\n   */\n  get parent () {\n    return this._item ? /** @type {AbstractType<any>} */ (this._item.parent) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item|null} item\n   */\n  _integrate (y, item) {\n    this.doc = y\n    this._item = item\n  }\n\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  _copy () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @return {AbstractType<EventType>}\n   */\n  clone () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) { }\n\n  /**\n   * The first non-deleted item\n   */\n  get _first () {\n    let n = this._start\n    while (n !== null && n.deleted) {\n      n = n.right\n    }\n    return n\n  }\n\n  /**\n   * Creates YEvent and calls all type observers.\n   * Must be implemented by each type.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    if (!transaction.local && this._searchMarker) {\n      this._searchMarker.length = 0\n    }\n  }\n\n  /**\n   * Observe all events that are created on this type.\n   *\n   * @param {function(EventType, Transaction):void} f Observer function\n   */\n  observe (f) {\n    addEventHandlerListener(this._eH, f)\n  }\n\n  /**\n   * Observe all events that are created by this type and its children.\n   *\n   * @param {function(Array<YEvent>,Transaction):void} f Observer function\n   */\n  observeDeep (f) {\n    addEventHandlerListener(this._dEH, f)\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(EventType,Transaction):void} f Observer function\n   */\n  unobserve (f) {\n    removeEventHandlerListener(this._eH, f)\n  }\n\n  /**\n   * Unregister an observer function.\n   *\n   * @param {function(Array<YEvent>,Transaction):void} f Observer function\n   */\n  unobserveDeep (f) {\n    removeEventHandlerListener(this._dEH, f)\n  }\n\n  /**\n   * @abstract\n   * @return {any}\n   */\n  toJSON () {}\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} start\n * @param {number} end\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nexport const typeListSlice = (type, start, end) => {\n  if (start < 0) {\n    start = type._length + start\n  }\n  if (end < 0) {\n    end = type._length + end\n  }\n  let len = end - start\n  const cs = []\n  let n = type._start\n  while (n !== null && len > 0) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent()\n      if (c.length <= start) {\n        start -= c.length\n      } else {\n        for (let i = start; i < c.length && len > 0; i++) {\n          cs.push(c[i])\n          len--\n        }\n        start = 0\n      }\n    }\n    n = n.right\n  }\n  return cs\n}\n\n/**\n * @param {AbstractType<any>} type\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nexport const typeListToArray = type => {\n  const cs = []\n  let n = type._start\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent()\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i])\n      }\n    }\n    n = n.right\n  }\n  return cs\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {Snapshot} snapshot\n * @return {Array<any>}\n *\n * @private\n * @function\n */\nexport const typeListToArraySnapshot = (type, snapshot) => {\n  const cs = []\n  let n = type._start\n  while (n !== null) {\n    if (n.countable && isVisible(n, snapshot)) {\n      const c = n.content.getContent()\n      for (let i = 0; i < c.length; i++) {\n        cs.push(c[i])\n      }\n    }\n    n = n.right\n  }\n  return cs\n}\n\n/**\n * Executes a provided function on once on overy element of this YArray.\n *\n * @param {AbstractType<any>} type\n * @param {function(any,number,any):void} f A function to execute on every element of this YArray.\n *\n * @private\n * @function\n */\nexport const typeListForEach = (type, f) => {\n  let index = 0\n  let n = type._start\n  while (n !== null) {\n    if (n.countable && !n.deleted) {\n      const c = n.content.getContent()\n      for (let i = 0; i < c.length; i++) {\n        f(c[i], index++, type)\n      }\n    }\n    n = n.right\n  }\n}\n\n/**\n * @template C,R\n * @param {AbstractType<any>} type\n * @param {function(C,number,AbstractType<any>):R} f\n * @return {Array<R>}\n *\n * @private\n * @function\n */\nexport const typeListMap = (type, f) => {\n  /**\n   * @type {Array<any>}\n   */\n  const result = []\n  typeListForEach(type, (c, i) => {\n    result.push(f(c, i, type))\n  })\n  return result\n}\n\n/**\n * @param {AbstractType<any>} type\n * @return {IterableIterator<any>}\n *\n * @private\n * @function\n */\nexport const typeListCreateIterator = type => {\n  let n = type._start\n  /**\n   * @type {Array<any>|null}\n   */\n  let currentContent = null\n  let currentContentIndex = 0\n  return {\n    [Symbol.iterator] () {\n      return this\n    },\n    next: () => {\n      // find some content\n      if (currentContent === null) {\n        while (n !== null && n.deleted) {\n          n = n.right\n        }\n        // check if we reached the end, no need to check currentContent, because it does not exist\n        if (n === null) {\n          return {\n            done: true,\n            value: undefined\n          }\n        }\n        // we found n, so we can set currentContent\n        currentContent = n.content.getContent()\n        currentContentIndex = 0\n        n = n.right // we used the content of n, now iterate to next\n      }\n      const value = currentContent[currentContentIndex++]\n      // check if we need to empty currentContent\n      if (currentContent.length <= currentContentIndex) {\n        currentContent = null\n      }\n      return {\n        done: false,\n        value\n      }\n    }\n  }\n}\n\n/**\n * Executes a provided function on once on overy element of this YArray.\n * Operates on a snapshotted state of the document.\n *\n * @param {AbstractType<any>} type\n * @param {function(any,number,AbstractType<any>):void} f A function to execute on every element of this YArray.\n * @param {Snapshot} snapshot\n *\n * @private\n * @function\n */\nexport const typeListForEachSnapshot = (type, f, snapshot) => {\n  let index = 0\n  let n = type._start\n  while (n !== null) {\n    if (n.countable && isVisible(n, snapshot)) {\n      const c = n.content.getContent()\n      for (let i = 0; i < c.length; i++) {\n        f(c[i], index++, type)\n      }\n    }\n    n = n.right\n  }\n}\n\n/**\n * @param {AbstractType<any>} type\n * @param {number} index\n * @return {any}\n *\n * @private\n * @function\n */\nexport const typeListGet = (type, index) => {\n  const marker = findMarker(type, index)\n  let n = type._start\n  if (marker !== null) {\n    n = marker.p\n    index -= marker.index\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        return n.content.getContent()[index]\n      }\n      index -= n.length\n    }\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {Item?} referenceItem\n * @param {Array<Object<string,any>|Array<any>|boolean|number|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nexport const typeListInsertGenericsAfter = (transaction, parent, referenceItem, content) => {\n  let left = referenceItem\n  const doc = transaction.doc\n  const ownClientId = doc.clientID\n  const store = doc.store\n  const right = referenceItem === null ? parent._start : referenceItem.right\n  /**\n   * @type {Array<Object|Array<any>|number>}\n   */\n  let jsonContent = []\n  const packJsonContent = () => {\n    if (jsonContent.length > 0) {\n      left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentAny(jsonContent))\n      left.integrate(transaction, 0)\n      jsonContent = []\n    }\n  }\n  content.forEach(c => {\n    switch (c.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n        jsonContent.push(c)\n        break\n      default:\n        packJsonContent()\n        switch (c.constructor) {\n          case Uint8Array:\n          case ArrayBuffer:\n            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentBinary(new Uint8Array(/** @type {Uint8Array} */ (c))))\n            left.integrate(transaction, 0)\n            break\n          case Doc:\n            left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc(/** @type {Doc} */ (c)))\n            left.integrate(transaction, 0)\n            break\n          default:\n            if (c instanceof AbstractType) {\n              left = new Item(createID(ownClientId, getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentType(c))\n              left.integrate(transaction, 0)\n            } else {\n              throw new Error('Unexpected content type in insert operation')\n            }\n        }\n    }\n  })\n  packJsonContent()\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {Array<Object<string,any>|Array<any>|number|string|Uint8Array>} content\n *\n * @private\n * @function\n */\nexport const typeListInsertGenerics = (transaction, parent, index, content) => {\n  if (index === 0) {\n    if (parent._searchMarker) {\n      updateMarkerChanges(parent._searchMarker, index, content.length)\n    }\n    return typeListInsertGenericsAfter(transaction, parent, null, content)\n  }\n  const startIndex = index\n  const marker = findMarker(parent, index)\n  let n = parent._start\n  if (marker !== null) {\n    n = marker.p\n    index -= marker.index\n    // we need to iterate one to the left so that the algorithm works\n    if (index === 0) {\n      // @todo refactor this as it actually doesn't consider formats\n      n = n.prev // important! get the left undeleted item so that we can actually decrease index\n      index += (n && n.countable && !n.deleted) ? n.length : 0\n    }\n  }\n  for (; n !== null; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index <= n.length) {\n        if (index < n.length) {\n          // insert in-between\n          getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index))\n        }\n        break\n      }\n      index -= n.length\n    }\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, content.length)\n  }\n  return typeListInsertGenericsAfter(transaction, parent, n, content)\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @param {number} length\n *\n * @private\n * @function\n */\nexport const typeListDelete = (transaction, parent, index, length) => {\n  if (length === 0) { return }\n  const startIndex = index\n  const startLength = length\n  const marker = findMarker(parent, index)\n  let n = parent._start\n  if (marker !== null) {\n    n = marker.p\n    index -= marker.index\n  }\n  // compute the first item to be deleted\n  for (; n !== null && index > 0; n = n.right) {\n    if (!n.deleted && n.countable) {\n      if (index < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + index))\n      }\n      index -= n.length\n    }\n  }\n  // delete all items until done\n  while (length > 0 && n !== null) {\n    if (!n.deleted) {\n      if (length < n.length) {\n        getItemCleanStart(transaction, createID(n.id.client, n.id.clock + length))\n      }\n      n.delete(transaction)\n      length -= n.length\n    }\n    n = n.right\n  }\n  if (length > 0) {\n    throw error.create('array length exceeded')\n  }\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */)\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n *\n * @private\n * @function\n */\nexport const typeMapDelete = (transaction, parent, key) => {\n  const c = parent._map.get(key)\n  if (c !== undefined) {\n    c.delete(transaction)\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Object|number|Array<any>|string|Uint8Array|AbstractType<any>} value\n *\n * @private\n * @function\n */\nexport const typeMapSet = (transaction, parent, key, value) => {\n  const left = parent._map.get(key) || null\n  const doc = transaction.doc\n  const ownClientId = doc.clientID\n  let content\n  if (value == null) {\n    content = new ContentAny([value])\n  } else {\n    switch (value.constructor) {\n      case Number:\n      case Object:\n      case Boolean:\n      case Array:\n      case String:\n        content = new ContentAny([value])\n        break\n      case Uint8Array:\n        content = new ContentBinary(/** @type {Uint8Array} */ (value))\n        break\n      case Doc:\n        content = new ContentDoc(/** @type {Doc} */ (value))\n        break\n      default:\n        if (value instanceof AbstractType) {\n          content = new ContentType(value)\n        } else {\n          throw new Error('Unexpected content type')\n        }\n    }\n  }\n  new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0)\n}\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nexport const typeMapGet = (parent, key) => {\n  const val = parent._map.get(key)\n  return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined\n}\n\n/**\n * @param {AbstractType<any>} parent\n * @return {Object<string,Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}\n *\n * @private\n * @function\n */\nexport const typeMapGetAll = (parent) => {\n  /**\n   * @type {Object<string,any>}\n   */\n  const res = {}\n  parent._map.forEach((value, key) => {\n    if (!value.deleted) {\n      res[key] = value.content.getContent()[value.length - 1]\n    }\n  })\n  return res\n}\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @return {boolean}\n *\n * @private\n * @function\n */\nexport const typeMapHas = (parent, key) => {\n  const val = parent._map.get(key)\n  return val !== undefined && !val.deleted\n}\n\n/**\n * @param {AbstractType<any>} parent\n * @param {string} key\n * @param {Snapshot} snapshot\n * @return {Object<string,any>|number|Array<any>|string|Uint8Array|AbstractType<any>|undefined}\n *\n * @private\n * @function\n */\nexport const typeMapGetSnapshot = (parent, key, snapshot) => {\n  let v = parent._map.get(key) || null\n  while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {\n    v = v.left\n  }\n  return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined\n}\n\n/**\n * @param {Map<string,Item>} map\n * @return {IterableIterator<Array<any>>}\n *\n * @private\n * @function\n */\nexport const createMapIterator = map => iterator.iteratorFilter(map.entries(), /** @param {any} entry */ entry => !entry[1].deleted)\n","/**\n * @module YArray\n */\n\nimport {\n  YEvent,\n  AbstractType,\n  typeListGet,\n  typeListToArray,\n  typeListForEach,\n  typeListCreateIterator,\n  typeListInsertGenerics,\n  typeListDelete,\n  typeListMap,\n  YArrayRefID,\n  callTypeObservers,\n  transact,\n  ArraySearchMarker, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Doc, Transaction, Item // eslint-disable-line\n} from '../internals.js'\nimport { typeListSlice } from './AbstractType.js'\n\n/**\n * Event that describes the changes on a YArray\n * @template T\n */\nexport class YArrayEvent extends YEvent {\n  /**\n   * @param {YArray<T>} yarray The changed type\n   * @param {Transaction} transaction The transaction object\n   */\n  constructor (yarray, transaction) {\n    super(yarray, transaction)\n    this._transaction = transaction\n  }\n}\n\n/**\n * A shared Array implementation.\n * @template T\n * @extends AbstractType<YArrayEvent<T>>\n * @implements {Iterable<T>}\n */\nexport class YArray extends AbstractType {\n  constructor () {\n    super()\n    /**\n     * @type {Array<any>?}\n     * @private\n     */\n    this._prelimContent = []\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = []\n  }\n\n  /**\n   * Construct a new YArray containing the specified items.\n   * @template T\n   * @param {Array<T>} items\n   * @return {YArray<T>}\n   */\n  static from (items) {\n    const a = new YArray()\n    a.push(items)\n    return a\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent))\n    this._prelimContent = null\n  }\n\n  _copy () {\n    return new YArray()\n  }\n\n  /**\n   * @return {YArray<T>}\n   */\n  clone () {\n    const arr = new YArray()\n    arr.insert(0, this.toArray().map(el =>\n      el instanceof AbstractType ? el.clone() : el\n    ))\n    return arr\n  }\n\n  get length () {\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Creates YArrayEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs)\n    callTypeObservers(this, transaction, new YArrayEvent(this, transaction))\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * Important: This function expects an array of content. Not just a content\n   * object. The reason for this \"weirdness\" is that inserting several elements\n   * is very efficient when it is done as a single operation.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  yarray.insert(0, ['a'])\n   *  // Insert numbers 1, 2 at position 1\n   *  yarray.insert(1, [1, 2])\n   *\n   * @param {number} index The index to insert content at.\n   * @param {Array<T>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, content)\n      })\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, 0, ...content)\n    }\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to append.\n   */\n  push (content) {\n    this.insert(this.length, content)\n  }\n\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<T>} content Array of content to preppend.\n   */\n  unshift (content) {\n    this.insert(0, content)\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} length The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length)\n      })\n    } else {\n      /** @type {Array<any>} */ (this._prelimContent).splice(index, length)\n    }\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {T}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<T>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<T>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Array<any>}\n   */\n  toJSON () {\n    return this.map(c => c instanceof AbstractType ? c.toJSON() : c)\n  }\n\n  /**\n   * Returns an Array with the result of calling a provided function on every\n   * element of this YArray.\n   *\n   * @template T,M\n   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array\n   * @return {Array<M>} A new array with each element being the result of the\n   *                 callback function\n   */\n  map (f) {\n    return typeListMap(this, /** @type {any} */ (f))\n  }\n\n  /**\n   * Executes a provided function on once on overy element of this YArray.\n   *\n   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    typeListForEach(this, f)\n  }\n\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return typeListCreateIterator(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YArrayRefID)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n *\n * @private\n * @function\n */\nexport const readYArray = decoder => new YArray()\n","\n/**\n * @module YMap\n */\n\nimport {\n  YEvent,\n  AbstractType,\n  typeMapDelete,\n  typeMapSet,\n  typeMapGet,\n  typeMapHas,\n  createMapIterator,\n  YMapRefID,\n  callTypeObservers,\n  transact,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Doc, Transaction, Item // eslint-disable-line\n} from '../internals.js'\n\nimport * as iterator from 'lib0/iterator.js'\n\n/**\n * @template T\n * Event that describes the changes on a YMap.\n */\nexport class YMapEvent extends YEvent {\n  /**\n   * @param {YMap<T>} ymap The YArray that changed.\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed.\n   */\n  constructor (ymap, transaction, subs) {\n    super(ymap, transaction)\n    this.keysChanged = subs\n  }\n}\n\n/**\n * @template T number|string|Object|Array|Uint8Array\n * A shared Map implementation.\n *\n * @extends AbstractType<YMapEvent<T>>\n * @implements {Iterable<T>}\n */\nexport class YMap extends AbstractType {\n  /**\n   *\n   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap\n   */\n  constructor (entries) {\n    super()\n    /**\n     * @type {Map<string,any>?}\n     * @private\n     */\n    this._prelimContent = null\n\n    if (entries === undefined) {\n      this._prelimContent = new Map()\n    } else {\n      this._prelimContent = new Map(entries)\n    }\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;/** @type {Map<string, any>} */ (this._prelimContent).forEach((value, key) => {\n      this.set(key, value)\n    })\n    this._prelimContent = null\n  }\n\n  _copy () {\n    return new YMap()\n  }\n\n  /**\n   * @return {YMap<T>}\n   */\n  clone () {\n    const map = new YMap()\n    this.forEach((value, key) => {\n      map.set(key, value instanceof AbstractType ? value.clone() : value)\n    })\n    return map\n  }\n\n  /**\n   * Creates YMapEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YMapEvent(this, transaction, parentSubs))\n  }\n\n  /**\n   * Transforms this Shared Type to a JSON object.\n   *\n   * @return {Object<string,T>}\n   */\n  toJSON () {\n    /**\n     * @type {Object<string,T>}\n     */\n    const map = {}\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        const v = item.content.getContent()[item.length - 1]\n        map[key] = v instanceof AbstractType ? v.toJSON() : v\n      }\n    })\n    return map\n  }\n\n  /**\n   * Returns the size of the YMap (count of key/value pairs)\n   *\n   * @return {number}\n   */\n  get size () {\n    return [...createMapIterator(this._map)].length\n  }\n\n  /**\n   * Returns the keys for each element in the YMap Type.\n   *\n   * @return {IterableIterator<string>}\n   */\n  keys () {\n    return iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v => v[0])\n  }\n\n  /**\n   * Returns the values for each element in the YMap Type.\n   *\n   * @return {IterableIterator<any>}\n   */\n  values () {\n    return iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v => v[1].content.getContent()[v[1].length - 1])\n  }\n\n  /**\n   * Returns an Iterator of [key, value] pairs\n   *\n   * @return {IterableIterator<any>}\n   */\n  entries () {\n    return iterator.iteratorMap(createMapIterator(this._map), /** @param {any} v */ v => [v[0], v[1].content.getContent()[v[1].length - 1]])\n  }\n\n  /**\n   * Executes a provided function on once on every key-value pair.\n   *\n   * @param {function(T,string,YMap<T>):void} f A function to execute on every element of this YArray.\n   */\n  forEach (f) {\n    /**\n     * @type {Object<string,T>}\n     */\n    const map = {}\n    this._map.forEach((item, key) => {\n      if (!item.deleted) {\n        f(item.content.getContent()[item.length - 1], key, this)\n      }\n    })\n    return map\n  }\n\n  /**\n   * @return {IterableIterator<T>}\n   */\n  [Symbol.iterator] () {\n    return this.entries()\n  }\n\n  /**\n   * Remove a specified element from this YMap.\n   *\n   * @param {string} key The key of the element to remove.\n   */\n  delete (key) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, key)\n      })\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).delete(key)\n    }\n  }\n\n  /**\n   * Adds or updates an element with a specified key and value.\n   *\n   * @param {string} key The key of the element to add to this YMap\n   * @param {T} value The value of the element to add\n   */\n  set (key, value) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, key, value)\n      })\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimContent).set(key, value)\n    }\n    return value\n  }\n\n  /**\n   * Returns a specified element from this YMap.\n   *\n   * @param {string} key\n   * @return {T|undefined}\n   */\n  get (key) {\n    return /** @type {any} */ (typeMapGet(this, key))\n  }\n\n  /**\n   * Returns a boolean indicating whether the specified key exists or not.\n   *\n   * @param {string} key The key to test.\n   * @return {boolean}\n   */\n  has (key) {\n    return typeMapHas(this, key)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YMapRefID)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n *\n * @private\n * @function\n */\nexport const readYMap = decoder => new YMap()\n","\n/**\n * @module YText\n */\n\nimport {\n  YEvent,\n  AbstractType,\n  getItemCleanStart,\n  getState,\n  isVisible,\n  createID,\n  YTextRefID,\n  callTypeObservers,\n  transact,\n  ContentEmbed,\n  GC,\n  ContentFormat,\n  ContentString,\n  splitSnapshotAffectedStructs,\n  iterateDeletedStructs,\n  iterateStructs,\n  findMarker,\n  typeMapDelete,\n  typeMapSet,\n  typeMapGet,\n  typeMapGetAll,\n  updateMarkerChanges,\n  ArraySearchMarker, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, ID, Doc, Item, Snapshot, Transaction // eslint-disable-line\n} from '../internals.js'\n\nimport * as object from 'lib0/object.js'\nimport * as map from 'lib0/map.js'\nimport * as error from 'lib0/error.js'\n\n/**\n * @param {any} a\n * @param {any} b\n * @return {boolean}\n */\nconst equalAttrs = (a, b) => a === b || (typeof a === 'object' && typeof b === 'object' && a && b && object.equalFlat(a, b))\n\nexport class ItemTextListPosition {\n  /**\n   * @param {Item|null} left\n   * @param {Item|null} right\n   * @param {number} index\n   * @param {Map<string,any>} currentAttributes\n   */\n  constructor (left, right, index, currentAttributes) {\n    this.left = left\n    this.right = right\n    this.index = index\n    this.currentAttributes = currentAttributes\n  }\n\n  /**\n   * Only call this if you know that this.right is defined\n   */\n  forward () {\n    if (this.right === null) {\n      error.unexpectedCase()\n    }\n    switch (this.right.content.constructor) {\n      case ContentEmbed:\n      case ContentString:\n        if (!this.right.deleted) {\n          this.index += this.right.length\n        }\n        break\n      case ContentFormat:\n        if (!this.right.deleted) {\n          updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */ (this.right.content))\n        }\n        break\n    }\n    this.left = this.right\n    this.right = this.right.right\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} pos\n * @param {number} count steps to move forward\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findNextPosition = (transaction, pos, count) => {\n  while (pos.right !== null && count > 0) {\n    switch (pos.right.content.constructor) {\n      case ContentEmbed:\n      case ContentString:\n        if (!pos.right.deleted) {\n          if (count < pos.right.length) {\n            // split right\n            getItemCleanStart(transaction, createID(pos.right.id.client, pos.right.id.clock + count))\n          }\n          pos.index += pos.right.length\n          count -= pos.right.length\n        }\n        break\n      case ContentFormat:\n        if (!pos.right.deleted) {\n          updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */ (pos.right.content))\n        }\n        break\n    }\n    pos.left = pos.right\n    pos.right = pos.right.right\n    // pos.forward() - we don't forward because that would halve the performance because we already do the checks above\n  }\n  return pos\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {number} index\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst findPosition = (transaction, parent, index) => {\n  const currentAttributes = new Map()\n  const marker = findMarker(parent, index)\n  if (marker) {\n    const pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes)\n    return findNextPosition(transaction, pos, index - marker.index)\n  } else {\n    const pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes)\n    return findNextPosition(transaction, pos, index)\n  }\n}\n\n/**\n * Negate applied formats\n *\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Map<string,any>} negatedAttributes\n *\n * @private\n * @function\n */\nconst insertNegatedAttributes = (transaction, parent, currPos, negatedAttributes) => {\n  // check if we really need to remove attributes\n  while (\n    currPos.right !== null && (\n      currPos.right.deleted === true || (\n        currPos.right.content.constructor === ContentFormat &&\n        equalAttrs(negatedAttributes.get(/** @type {ContentFormat} */ (currPos.right.content).key), /** @type {ContentFormat} */ (currPos.right.content).value)\n      )\n    )\n  ) {\n    if (!currPos.right.deleted) {\n      negatedAttributes.delete(/** @type {ContentFormat} */ (currPos.right.content).key)\n    }\n    currPos.forward()\n  }\n  const doc = transaction.doc\n  const ownClientId = doc.clientID\n  let nextFormat = currPos.left\n  const right = currPos.right\n  negatedAttributes.forEach((val, key) => {\n    nextFormat = new Item(createID(ownClientId, getState(doc.store, ownClientId)), nextFormat, nextFormat && nextFormat.lastId, right, right && right.id, parent, null, new ContentFormat(key, val))\n    nextFormat.integrate(transaction, 0)\n    currPos.right = nextFormat\n  })\n}\n\n/**\n * @param {Map<string,any>} currentAttributes\n * @param {ContentFormat} format\n *\n * @private\n * @function\n */\nconst updateCurrentAttributes = (currentAttributes, format) => {\n  const { key, value } = format\n  if (value === null) {\n    currentAttributes.delete(key)\n  } else {\n    currentAttributes.set(key, value)\n  }\n}\n\n/**\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst minimizeAttributeChanges = (currPos, attributes) => {\n  // go right while attributes[right.key] === right.value (or right is deleted)\n  while (true) {\n    if (currPos.right === null) {\n      break\n    } else if (currPos.right.deleted || (currPos.right.content.constructor === ContentFormat && equalAttrs(attributes[(/** @type {ContentFormat} */ (currPos.right.content)).key] || null, /** @type {ContentFormat} */ (currPos.right.content).value))) {\n      //\n    } else {\n      break\n    }\n    currPos.forward()\n  }\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {Object<string,any>} attributes\n * @return {Map<string,any>}\n *\n * @private\n * @function\n **/\nconst insertAttributes = (transaction, parent, currPos, attributes) => {\n  const doc = transaction.doc\n  const ownClientId = doc.clientID\n  const negatedAttributes = new Map()\n  // insert format-start items\n  for (const key in attributes) {\n    const val = attributes[key]\n    const currentVal = currPos.currentAttributes.get(key) || null\n    if (!equalAttrs(currentVal, val)) {\n      // save negated attribute (set null if currentVal undefined)\n      negatedAttributes.set(key, currentVal)\n      const { left, right } = currPos\n      currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentFormat(key, val))\n      currPos.right.integrate(transaction, 0)\n      currPos.forward()\n    }\n  }\n  return negatedAttributes\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {string|object} text\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n **/\nconst insertText = (transaction, parent, currPos, text, attributes) => {\n  currPos.currentAttributes.forEach((val, key) => {\n    if (attributes[key] === undefined) {\n      attributes[key] = null\n    }\n  })\n  const doc = transaction.doc\n  const ownClientId = doc.clientID\n  minimizeAttributeChanges(currPos, attributes)\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes)\n  // insert content\n  const content = text.constructor === String ? new ContentString(/** @type {string} */ (text)) : new ContentEmbed(text)\n  let { left, right, index } = currPos\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength())\n  }\n  right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content)\n  right.integrate(transaction, 0)\n  currPos.right = right\n  currPos.index = index\n  currPos.forward()\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes)\n}\n\n/**\n * @param {Transaction} transaction\n * @param {AbstractType<any>} parent\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @param {Object<string,any>} attributes\n *\n * @private\n * @function\n */\nconst formatText = (transaction, parent, currPos, length, attributes) => {\n  const doc = transaction.doc\n  const ownClientId = doc.clientID\n  minimizeAttributeChanges(currPos, attributes)\n  const negatedAttributes = insertAttributes(transaction, parent, currPos, attributes)\n  // iterate until first non-format or null is found\n  // delete all formats with attributes[format.key] != null\n  while (length > 0 && currPos.right !== null) {\n    if (!currPos.right.deleted) {\n      switch (currPos.right.content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (currPos.right.content)\n          const attr = attributes[key]\n          if (attr !== undefined) {\n            if (equalAttrs(attr, value)) {\n              negatedAttributes.delete(key)\n            } else {\n              negatedAttributes.set(key, value)\n            }\n            currPos.right.delete(transaction)\n          }\n          break\n        }\n        case ContentEmbed:\n        case ContentString:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length))\n          }\n          length -= currPos.right.length\n          break\n      }\n    }\n    currPos.forward()\n  }\n  // Quill just assumes that the editor starts with a newline and that it always\n  // ends with a newline. We only insert that newline when a new newline is\n  // inserted - i.e when length is bigger than type.length\n  if (length > 0) {\n    let newlines = ''\n    for (; length > 0; length--) {\n      newlines += '\\n'\n    }\n    currPos.right = new Item(createID(ownClientId, getState(doc.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new ContentString(newlines))\n    currPos.right.integrate(transaction, 0)\n    currPos.forward()\n  }\n  insertNegatedAttributes(transaction, parent, currPos, negatedAttributes)\n}\n\n/**\n * Call this function after string content has been deleted in order to\n * clean up formatting Items.\n *\n * @param {Transaction} transaction\n * @param {Item} start\n * @param {Item|null} end exclusive end, automatically iterates to the next Content Item\n * @param {Map<string,any>} startAttributes\n * @param {Map<string,any>} endAttributes This attribute is modified!\n * @return {number} The amount of formatting Items deleted.\n *\n * @function\n */\nconst cleanupFormattingGap = (transaction, start, end, startAttributes, endAttributes) => {\n  while (end && end.content.constructor !== ContentString && end.content.constructor !== ContentEmbed) {\n    if (!end.deleted && end.content.constructor === ContentFormat) {\n      updateCurrentAttributes(endAttributes, /** @type {ContentFormat} */ (end.content))\n    }\n    end = end.right\n  }\n  let cleanups = 0\n  while (start !== end) {\n    if (!start.deleted) {\n      const content = start.content\n      switch (content.constructor) {\n        case ContentFormat: {\n          const { key, value } = /** @type {ContentFormat} */ (content)\n          if ((endAttributes.get(key) || null) !== value || (startAttributes.get(key) || null) === value) {\n            // Either this format is overwritten or it is not necessary because the attribute already existed.\n            start.delete(transaction)\n            cleanups++\n          }\n          break\n        }\n      }\n    }\n    start = /** @type {Item} */ (start.right)\n  }\n  return cleanups\n}\n\n/**\n * @param {Transaction} transaction\n * @param {Item | null} item\n */\nconst cleanupContextlessFormattingGap = (transaction, item) => {\n  // iterate until item.right is null or content\n  while (item && item.right && (item.right.deleted || (item.right.content.constructor !== ContentString && item.right.content.constructor !== ContentEmbed))) {\n    item = item.right\n  }\n  const attrs = new Set()\n  // iterate back until a content item is found\n  while (item && (item.deleted || (item.content.constructor !== ContentString && item.content.constructor !== ContentEmbed))) {\n    if (!item.deleted && item.content.constructor === ContentFormat) {\n      const key = /** @type {ContentFormat} */ (item.content).key\n      if (attrs.has(key)) {\n        item.delete(transaction)\n      } else {\n        attrs.add(key)\n      }\n    }\n    item = item.left\n  }\n}\n\n/**\n * This function is experimental and subject to change / be removed.\n *\n * Ideally, we don't need this function at all. Formatting attributes should be cleaned up\n * automatically after each change. This function iterates twice over the complete YText type\n * and removes unnecessary formatting attributes. This is also helpful for testing.\n *\n * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.\n *\n * @param {YText} type\n * @return {number} How many formatting attributes have been cleaned up.\n */\nexport const cleanupYTextFormatting = type => {\n  let res = 0\n  transact(/** @type {Doc} */ (type.doc), transaction => {\n    let start = /** @type {Item} */ (type._start)\n    let end = type._start\n    let startAttributes = map.create()\n    const currentAttributes = map.copy(startAttributes)\n    while (end) {\n      if (end.deleted === false) {\n        switch (end.content.constructor) {\n          case ContentFormat:\n            updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (end.content))\n            break\n          case ContentEmbed:\n          case ContentString:\n            res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes)\n            startAttributes = map.copy(currentAttributes)\n            start = end\n            break\n        }\n      }\n      end = end.right\n    }\n  })\n  return res\n}\n\n/**\n * @param {Transaction} transaction\n * @param {ItemTextListPosition} currPos\n * @param {number} length\n * @return {ItemTextListPosition}\n *\n * @private\n * @function\n */\nconst deleteText = (transaction, currPos, length) => {\n  const startLength = length\n  const startAttrs = map.copy(currPos.currentAttributes)\n  const start = currPos.right\n  while (length > 0 && currPos.right !== null) {\n    if (currPos.right.deleted === false) {\n      switch (currPos.right.content.constructor) {\n        case ContentEmbed:\n        case ContentString:\n          if (length < currPos.right.length) {\n            getItemCleanStart(transaction, createID(currPos.right.id.client, currPos.right.id.clock + length))\n          }\n          length -= currPos.right.length\n          currPos.right.delete(transaction)\n          break\n      }\n    }\n    currPos.forward()\n  }\n  if (start) {\n    cleanupFormattingGap(transaction, start, currPos.right, startAttrs, map.copy(currPos.currentAttributes))\n  }\n  const parent = /** @type {AbstractType<any>} */ (/** @type {Item} */ (currPos.left || currPos.right).parent)\n  if (parent._searchMarker) {\n    updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length)\n  }\n  return currPos\n}\n\n/**\n * The Quill Delta format represents changes on a text document with\n * formatting information. For mor information visit {@link https://quilljs.com/docs/delta/|Quill Delta}\n *\n * @example\n *   {\n *     ops: [\n *       { insert: 'Gandalf', attributes: { bold: true } },\n *       { insert: ' the ' },\n *       { insert: 'Grey', attributes: { color: '#cccccc' } }\n *     ]\n *   }\n *\n */\n\n/**\n  * Attributes that can be assigned to a selection of text.\n  *\n  * @example\n  *   {\n  *     bold: true,\n  *     font-size: '40px'\n  *   }\n  *\n  * @typedef {Object} TextAttributes\n  */\n\n/**\n * Event that describes the changes on a YText type.\n */\nexport class YTextEvent extends YEvent {\n  /**\n   * @param {YText} ytext\n   * @param {Transaction} transaction\n   * @param {Set<any>} subs The keys that changed\n   */\n  constructor (ytext, transaction, subs) {\n    super(ytext, transaction)\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.keysChanged = new Set()\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true\n      } else {\n        this.keysChanged.add(sub)\n      }\n    })\n  }\n\n  /**\n   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n   */\n  get changes () {\n    if (this._changes === null) {\n      /**\n       * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}\n       */\n      const changes = {\n        keys: this.keys,\n        delta: this.delta,\n        added: new Set(),\n        deleted: new Set()\n      }\n      this._changes = changes\n    }\n    return /** @type {any} */ (this._changes)\n  }\n\n  /**\n   * Compute the changes in the delta format.\n   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.\n   *\n   * @type {Array<{insert?:string, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n   *\n   * @public\n   */\n  get delta () {\n    if (this._delta === null) {\n      const y = /** @type {Doc} */ (this.target.doc)\n      /**\n       * @type {Array<{insert?:string, delete?:number, retain?:number, attributes?: Object<string,any>}>}\n       */\n      const delta = []\n      transact(y, transaction => {\n        const currentAttributes = new Map() // saves all current attributes for insert\n        const oldAttributes = new Map()\n        let item = this.target._start\n        /**\n         * @type {string?}\n         */\n        let action = null\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {} // counts added or removed new attributes for retain\n        /**\n         * @type {string|object}\n         */\n        let insert = ''\n        let retain = 0\n        let deleteLen = 0\n        const addOp = () => {\n          if (action !== null) {\n            /**\n             * @type {any}\n             */\n            let op\n            switch (action) {\n              case 'delete':\n                op = { delete: deleteLen }\n                deleteLen = 0\n                break\n              case 'insert':\n                op = { insert }\n                if (currentAttributes.size > 0) {\n                  op.attributes = {}\n                  currentAttributes.forEach((value, key) => {\n                    if (value !== null) {\n                      op.attributes[key] = value\n                    }\n                  })\n                }\n                insert = ''\n                break\n              case 'retain':\n                op = { retain }\n                if (Object.keys(attributes).length > 0) {\n                  op.attributes = {}\n                  for (const key in attributes) {\n                    op.attributes[key] = attributes[key]\n                  }\n                }\n                retain = 0\n                break\n            }\n            delta.push(op)\n            action = null\n          }\n        }\n        while (item !== null) {\n          switch (item.content.constructor) {\n            case ContentEmbed:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  addOp()\n                  action = 'insert'\n                  insert = /** @type {ContentEmbed} */ (item.content).embed\n                  addOp()\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp()\n                  action = 'delete'\n                }\n                deleteLen += 1\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp()\n                  action = 'retain'\n                }\n                retain += 1\n              }\n              break\n            case ContentString:\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  if (action !== 'insert') {\n                    addOp()\n                    action = 'insert'\n                  }\n                  insert += /** @type {ContentString} */ (item.content).str\n                }\n              } else if (this.deletes(item)) {\n                if (action !== 'delete') {\n                  addOp()\n                  action = 'delete'\n                }\n                deleteLen += item.length\n              } else if (!item.deleted) {\n                if (action !== 'retain') {\n                  addOp()\n                  action = 'retain'\n                }\n                retain += item.length\n              }\n              break\n            case ContentFormat: {\n              const { key, value } = /** @type {ContentFormat} */ (item.content)\n              if (this.adds(item)) {\n                if (!this.deletes(item)) {\n                  const curVal = currentAttributes.get(key) || null\n                  if (!equalAttrs(curVal, value)) {\n                    if (action === 'retain') {\n                      addOp()\n                    }\n                    if (equalAttrs(value, (oldAttributes.get(key) || null))) {\n                      delete attributes[key]\n                    } else {\n                      attributes[key] = value\n                    }\n                  } else {\n                    item.delete(transaction)\n                  }\n                }\n              } else if (this.deletes(item)) {\n                oldAttributes.set(key, value)\n                const curVal = currentAttributes.get(key) || null\n                if (!equalAttrs(curVal, value)) {\n                  if (action === 'retain') {\n                    addOp()\n                  }\n                  attributes[key] = curVal\n                }\n              } else if (!item.deleted) {\n                oldAttributes.set(key, value)\n                const attr = attributes[key]\n                if (attr !== undefined) {\n                  if (!equalAttrs(attr, value)) {\n                    if (action === 'retain') {\n                      addOp()\n                    }\n                    if (value === null) {\n                      attributes[key] = value\n                    } else {\n                      delete attributes[key]\n                    }\n                  } else {\n                    item.delete(transaction)\n                  }\n                }\n              }\n              if (!item.deleted) {\n                if (action === 'insert') {\n                  addOp()\n                }\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (item.content))\n              }\n              break\n            }\n          }\n          item = item.right\n        }\n        addOp()\n        while (delta.length > 0) {\n          const lastOp = delta[delta.length - 1]\n          if (lastOp.retain !== undefined && lastOp.attributes === undefined) {\n            // retain delta's if they don't assign attributes\n            delta.pop()\n          } else {\n            break\n          }\n        }\n      })\n      this._delta = delta\n    }\n    return /** @type {any} */ (this._delta)\n  }\n}\n\n/**\n * Type that represents text with formatting information.\n *\n * This type replaces y-richtext as this implementation is able to handle\n * block formats (format information on a paragraph), embeds (complex elements\n * like pictures and videos), and text formats (**bold**, *italic*).\n *\n * @extends AbstractType<YTextEvent>\n */\nexport class YText extends AbstractType {\n  /**\n   * @param {String} [string] The initial value of the YText.\n   */\n  constructor (string) {\n    super()\n    /**\n     * Array of pending operations on this type\n     * @type {Array<function():void>?}\n     */\n    this._pending = string !== undefined ? [() => this.insert(0, string)] : []\n    /**\n     * @type {Array<ArraySearchMarker>}\n     */\n    this._searchMarker = []\n  }\n\n  /**\n   * Number of characters of this text type.\n   *\n   * @type {number}\n   */\n  get length () {\n    return this._length\n  }\n\n  /**\n   * @param {Doc} y\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    try {\n      /** @type {Array<function>} */ (this._pending).forEach(f => f())\n    } catch (e) {\n      console.error(e)\n    }\n    this._pending = null\n  }\n\n  _copy () {\n    return new YText()\n  }\n\n  /**\n   * @return {YText}\n   */\n  clone () {\n    const text = new YText()\n    text.applyDelta(this.toDelta())\n    return text\n  }\n\n  /**\n   * Creates YTextEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    super._callObserver(transaction, parentSubs)\n    const event = new YTextEvent(this, transaction, parentSubs)\n    const doc = transaction.doc\n    callTypeObservers(this, transaction, event)\n    // If a remote change happened, we try to cleanup potential formatting duplicates.\n    if (!transaction.local) {\n      // check if another formatting item was inserted\n      let foundFormattingItem = false\n      for (const [client, afterClock] of transaction.afterState.entries()) {\n        const clock = transaction.beforeState.get(client) || 0\n        if (afterClock === clock) {\n          continue\n        }\n        iterateStructs(transaction, /** @type {Array<Item|GC>} */ (doc.store.clients.get(client)), clock, afterClock, item => {\n          if (!item.deleted && /** @type {Item} */ (item).content.constructor === ContentFormat) {\n            foundFormattingItem = true\n          }\n        })\n        if (foundFormattingItem) {\n          break\n        }\n      }\n      if (!foundFormattingItem) {\n        iterateDeletedStructs(transaction, transaction.deleteSet, item => {\n          if (item instanceof GC || foundFormattingItem) {\n            return\n          }\n          if (item.parent === this && item.content.constructor === ContentFormat) {\n            foundFormattingItem = true\n          }\n        })\n      }\n      transact(doc, (t) => {\n        if (foundFormattingItem) {\n          // If a formatting item was inserted, we simply clean the whole type.\n          // We need to compute currentAttributes for the current position anyway.\n          cleanupYTextFormatting(this)\n        } else {\n          // If no formatting attribute was inserted, we can make due with contextless\n          // formatting cleanups.\n          // Contextless: it is not necessary to compute currentAttributes for the affected position.\n          iterateDeletedStructs(t, t.deleteSet, item => {\n            if (item instanceof GC) {\n              return\n            }\n            if (item.parent === this) {\n              cleanupContextlessFormattingGap(t, item)\n            }\n          })\n        }\n      })\n    }\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @public\n   */\n  toString () {\n    let str = ''\n    /**\n     * @type {Item|null}\n     */\n    let n = this._start\n    while (n !== null) {\n      if (!n.deleted && n.countable && n.content.constructor === ContentString) {\n        str += /** @type {ContentString} */ (n.content).str\n      }\n      n = n.right\n    }\n    return str\n  }\n\n  /**\n   * Returns the unformatted string representation of this YText type.\n   *\n   * @return {string}\n   * @public\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Apply a {@link Delta} on this shared YText type.\n   *\n   * @param {any} delta The changes to apply on this element.\n   * @param {object}  [opts]\n   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.\n   *\n   *\n   * @public\n   */\n  applyDelta (delta, { sanitize = true } = {}) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const currPos = new ItemTextListPosition(null, this._start, 0, new Map())\n        for (let i = 0; i < delta.length; i++) {\n          const op = delta[i]\n          if (op.insert !== undefined) {\n            // Quill assumes that the content starts with an empty paragraph.\n            // Yjs/Y.Text assumes that it starts empty. We always hide that\n            // there is a newline at the end of the content.\n            // If we omit this step, clients will see a different number of\n            // paragraphs, but nothing bad will happen.\n            const ins = (!sanitize && typeof op.insert === 'string' && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === '\\n') ? op.insert.slice(0, -1) : op.insert\n            if (typeof ins !== 'string' || ins.length > 0) {\n              insertText(transaction, this, currPos, ins, op.attributes || {})\n            }\n          } else if (op.retain !== undefined) {\n            formatText(transaction, this, currPos, op.retain, op.attributes || {})\n          } else if (op.delete !== undefined) {\n            deleteText(transaction, currPos, op.delete)\n          }\n        }\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.applyDelta(delta))\n    }\n  }\n\n  /**\n   * Returns the Delta representation of this YText type.\n   *\n   * @param {Snapshot} [snapshot]\n   * @param {Snapshot} [prevSnapshot]\n   * @param {function('removed' | 'added', ID):any} [computeYChange]\n   * @return {any} The Delta representation of this type.\n   *\n   * @public\n   */\n  toDelta (snapshot, prevSnapshot, computeYChange) {\n    /**\n     * @type{Array<any>}\n     */\n    const ops = []\n    const currentAttributes = new Map()\n    const doc = /** @type {Doc} */ (this.doc)\n    let str = ''\n    let n = this._start\n    function packStr () {\n      if (str.length > 0) {\n        // pack str with attributes to ops\n        /**\n         * @type {Object<string,any>}\n         */\n        const attributes = {}\n        let addAttributes = false\n        currentAttributes.forEach((value, key) => {\n          addAttributes = true\n          attributes[key] = value\n        })\n        /**\n         * @type {Object<string,any>}\n         */\n        const op = { insert: str }\n        if (addAttributes) {\n          op.attributes = attributes\n        }\n        ops.push(op)\n        str = ''\n      }\n    }\n    // snapshots are merged again after the transaction, so we need to keep the\n    // transalive until we are done\n    transact(doc, transaction => {\n      if (snapshot) {\n        splitSnapshotAffectedStructs(transaction, snapshot)\n      }\n      if (prevSnapshot) {\n        splitSnapshotAffectedStructs(transaction, prevSnapshot)\n      }\n      while (n !== null) {\n        if (isVisible(n, snapshot) || (prevSnapshot !== undefined && isVisible(n, prevSnapshot))) {\n          switch (n.content.constructor) {\n            case ContentString: {\n              const cur = currentAttributes.get('ychange')\n              if (snapshot !== undefined && !isVisible(n, snapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.state !== 'removed') {\n                  packStr()\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('removed', n.id) : { type: 'removed' })\n                }\n              } else if (prevSnapshot !== undefined && !isVisible(n, prevSnapshot)) {\n                if (cur === undefined || cur.user !== n.id.client || cur.state !== 'added') {\n                  packStr()\n                  currentAttributes.set('ychange', computeYChange ? computeYChange('added', n.id) : { type: 'added' })\n                }\n              } else if (cur !== undefined) {\n                packStr()\n                currentAttributes.delete('ychange')\n              }\n              str += /** @type {ContentString} */ (n.content).str\n              break\n            }\n            case ContentEmbed: {\n              packStr()\n              /**\n               * @type {Object<string,any>}\n               */\n              const op = {\n                insert: /** @type {ContentEmbed} */ (n.content).embed\n              }\n              if (currentAttributes.size > 0) {\n                const attrs = /** @type {Object<string,any>} */ ({})\n                op.attributes = attrs\n                currentAttributes.forEach((value, key) => {\n                  attrs[key] = value\n                })\n              }\n              ops.push(op)\n              break\n            }\n            case ContentFormat:\n              if (isVisible(n, snapshot)) {\n                packStr()\n                updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */ (n.content))\n              }\n              break\n          }\n        }\n        n = n.right\n      }\n      packStr()\n    }, splitSnapshotAffectedStructs)\n    return ops\n  }\n\n  /**\n   * Insert text at a given index.\n   *\n   * @param {number} index The index at which to start inserting.\n   * @param {String} text The text to insert at the specified position.\n   * @param {TextAttributes} [attributes] Optionally define some formatting\n   *                                    information to apply on the inserted\n   *                                    Text.\n   * @public\n   */\n  insert (index, text, attributes) {\n    if (text.length <= 0) {\n      return\n    }\n    const y = this.doc\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index)\n        if (!attributes) {\n          attributes = {}\n          // @ts-ignore\n          pos.currentAttributes.forEach((v, k) => { attributes[k] = v })\n        }\n        insertText(transaction, this, pos, text, attributes)\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insert(index, text, attributes))\n    }\n  }\n\n  /**\n   * Inserts an embed at a index.\n   *\n   * @param {number} index The index to insert the embed at.\n   * @param {Object} embed The Object that represents the embed.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    embed\n   *\n   * @public\n   */\n  insertEmbed (index, embed, attributes = {}) {\n    if (embed.constructor !== Object) {\n      throw new Error('Embed must be an Object')\n    }\n    const y = this.doc\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index)\n        insertText(transaction, this, pos, embed, attributes)\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.insertEmbed(index, embed, attributes))\n    }\n  }\n\n  /**\n   * Deletes text starting from an index.\n   *\n   * @param {number} index Index at which to start deleting.\n   * @param {number} length The number of characters to remove. Defaults to 1.\n   *\n   * @public\n   */\n  delete (index, length) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc\n    if (y !== null) {\n      transact(y, transaction => {\n        deleteText(transaction, findPosition(transaction, this, index), length)\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.delete(index, length))\n    }\n  }\n\n  /**\n   * Assigns properties to a range of text.\n   *\n   * @param {number} index The position where to start formatting.\n   * @param {number} length The amount of characters to assign properties to.\n   * @param {TextAttributes} attributes Attribute information to apply on the\n   *                                    text.\n   *\n   * @public\n   */\n  format (index, length, attributes) {\n    if (length === 0) {\n      return\n    }\n    const y = this.doc\n    if (y !== null) {\n      transact(y, transaction => {\n        const pos = findPosition(transaction, this, index)\n        if (pos.right === null) {\n          return\n        }\n        formatText(transaction, this, pos, length, attributes)\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.format(index, length, attributes))\n    }\n  }\n\n  /**\n   * Removes an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName)\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.removeAttribute(attributeName))\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {any} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue)\n      })\n    } else {\n      /** @type {Array<function>} */ (this._pending).push(() => this.setAttribute(attributeName, attributeValue))\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {any} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes (snapshot) {\n    return typeMapGetAll(this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YTextRefID)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YText}\n *\n * @private\n * @function\n */\nexport const readYText = decoder => new YText()\n","/**\n * @module YXml\n */\n\nimport {\n  YXmlEvent,\n  YXmlElement,\n  AbstractType,\n  typeListMap,\n  typeListForEach,\n  typeListInsertGenerics,\n  typeListInsertGenericsAfter,\n  typeListDelete,\n  typeListToArray,\n  YXmlFragmentRefID,\n  callTypeObservers,\n  transact,\n  typeListGet,\n  typeListSlice,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Doc, ContentType, Transaction, Item, YXmlText, YXmlHook, Snapshot // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error.js'\n\n/**\n * Define the elements to which a set of CSS queries apply.\n * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}\n *\n * @example\n *   query = '.classSelector'\n *   query = 'nodeSelector'\n *   query = '#idSelector'\n *\n * @typedef {string} CSS_Selector\n */\n\n/**\n * Dom filter function.\n *\n * @callback domFilter\n * @param {string} nodeName The nodeName of the element\n * @param {Map} attributes The map of attributes.\n * @return {boolean} Whether to include the Dom node in the YXmlElement.\n */\n\n/**\n * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a\n * position within them.\n *\n * Can be created with {@link YXmlFragment#createTreeWalker}\n *\n * @public\n * @implements {Iterable<YXmlElement|YXmlText|YXmlElement|YXmlHook>}\n */\nexport class YXmlTreeWalker {\n  /**\n   * @param {YXmlFragment | YXmlElement} root\n   * @param {function(AbstractType<any>):boolean} [f]\n   */\n  constructor (root, f = () => true) {\n    this._filter = f\n    this._root = root\n    /**\n     * @type {Item}\n     */\n    this._currentNode = /** @type {Item} */ (root._start)\n    this._firstCall = true\n  }\n\n  [Symbol.iterator] () {\n    return this\n  }\n\n  /**\n   * Get the next node.\n   *\n   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.\n   *\n   * @public\n   */\n  next () {\n    /**\n     * @type {Item|null}\n     */\n    let n = this._currentNode\n    let type = n && n.content && /** @type {any} */ (n.content).type\n    if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) { // if first call, we check if we can use the first item\n      do {\n        type = /** @type {any} */ (n.content).type\n        if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {\n          // walk down in the tree\n          n = type._start\n        } else {\n          // walk right or up in the tree\n          while (n !== null) {\n            if (n.right !== null) {\n              n = n.right\n              break\n            } else if (n.parent === this._root) {\n              n = null\n            } else {\n              n = /** @type {AbstractType<any>} */ (n.parent)._item\n            }\n          }\n        }\n      } while (n !== null && (n.deleted || !this._filter(/** @type {ContentType} */ (n.content).type)))\n    }\n    this._firstCall = false\n    if (n === null) {\n      // @ts-ignore\n      return { value: undefined, done: true }\n    }\n    this._currentNode = n\n    return { value: /** @type {any} */ (n.content).type, done: false }\n  }\n}\n\n/**\n * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.\n * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a\n * nodeName and it does not have attributes. Though it can be bound to a DOM\n * element - in this case the attributes and the nodeName are not shared.\n *\n * @public\n * @extends AbstractType<YXmlEvent>\n */\nexport class YXmlFragment extends AbstractType {\n  constructor () {\n    super()\n    /**\n     * @type {Array<any>|null}\n     */\n    this._prelimContent = []\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get firstChild () {\n    const first = this._first\n    return first ? first.content.getContent()[0] : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    this.insert(0, /** @type {Array<any>} */ (this._prelimContent))\n    this._prelimContent = null\n  }\n\n  _copy () {\n    return new YXmlFragment()\n  }\n\n  /**\n   * @return {YXmlFragment}\n   */\n  clone () {\n    const el = new YXmlFragment()\n    // @ts-ignore\n    el.insert(0, el.toArray().map(item => item instanceof AbstractType ? item.clone() : item))\n    return el\n  }\n\n  get length () {\n    return this._prelimContent === null ? this._length : this._prelimContent.length\n  }\n\n  /**\n   * Create a subtree of childNodes.\n   *\n   * @example\n   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')\n   * for (let node in walker) {\n   *   // `node` is a div node\n   *   nop(node)\n   * }\n   *\n   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and\n   *                          returns a Boolean indicating whether the child\n   *                          is to be included in the subtree.\n   * @return {YXmlTreeWalker} A subtree and a position within it.\n   *\n   * @public\n   */\n  createTreeWalker (filter) {\n    return new YXmlTreeWalker(this, filter)\n  }\n\n  /**\n   * Returns the first YXmlElement that matches the query.\n   * Similar to DOM's {@link querySelector}.\n   *\n   * Query support:\n   *   - tagname\n   * TODO:\n   *   - id\n   *   - attribute\n   *\n   * @param {CSS_Selector} query The query on the children.\n   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.\n   *\n   * @public\n   */\n  querySelector (query) {\n    query = query.toUpperCase()\n    // @ts-ignore\n    const iterator = new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query)\n    const next = iterator.next()\n    if (next.done) {\n      return null\n    } else {\n      return next.value\n    }\n  }\n\n  /**\n   * Returns all YXmlElements that match the query.\n   * Similar to Dom's {@link querySelectorAll}.\n   *\n   * @todo Does not yet support all queries. Currently only query by tagName.\n   *\n   * @param {CSS_Selector} query The query on the children\n   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.\n   *\n   * @public\n   */\n  querySelectorAll (query) {\n    query = query.toUpperCase()\n    // @ts-ignore\n    return Array.from(new YXmlTreeWalker(this, element => element.nodeName && element.nodeName.toUpperCase() === query))\n  }\n\n  /**\n   * Creates YXmlEvent and calls observers.\n   *\n   * @param {Transaction} transaction\n   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.\n   */\n  _callObserver (transaction, parentSubs) {\n    callTypeObservers(this, transaction, new YXmlEvent(this, parentSubs, transaction))\n  }\n\n  /**\n   * Get the string representation of all the children of this YXmlFragment.\n   *\n   * @return {string} The string representation of all children.\n   */\n  toString () {\n    return typeListMap(this, xml => xml.toString()).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const fragment = _document.createDocumentFragment()\n    if (binding !== undefined) {\n      binding._createAssociation(fragment, this)\n    }\n    typeListForEach(this, xmlType => {\n      fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null)\n    })\n    return fragment\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {number} index The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insert (index, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListInsertGenerics(transaction, this, index, content)\n      })\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, 0, ...content)\n    }\n  }\n\n  /**\n   * Inserts new content at an index.\n   *\n   * @example\n   *  // Insert character 'a' at position 0\n   *  xml.insert(0, [new Y.XmlText('text')])\n   *\n   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at\n   * @param {Array<YXmlElement|YXmlText>} content The array of content\n   */\n  insertAfter (ref, content) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        const refItem = (ref && ref instanceof AbstractType) ? ref._item : ref\n        typeListInsertGenericsAfter(transaction, this, refItem, content)\n      })\n    } else {\n      const pc = /** @type {Array<any>} */ (this._prelimContent)\n      const index = ref === null ? 0 : pc.findIndex(el => el === ref) + 1\n      if (index === 0 && ref !== null) {\n        throw error.create('Reference item not found')\n      }\n      pc.splice(index, 0, ...content)\n    }\n  }\n\n  /**\n   * Deletes elements starting from an index.\n   *\n   * @param {number} index Index at which to start deleting elements\n   * @param {number} [length=1] The number of elements to remove. Defaults to 1.\n   */\n  delete (index, length = 1) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeListDelete(transaction, this, index, length)\n      })\n    } else {\n      // @ts-ignore _prelimContent is defined because this is not yet integrated\n      this._prelimContent.splice(index, length)\n    }\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @return {Array<YXmlElement|YXmlText|YXmlHook>}\n   */\n  toArray () {\n    return typeListToArray(this)\n  }\n\n  /**\n   * Appends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.\n   */\n  push (content) {\n    this.insert(this.length, content)\n  }\n\n  /**\n   * Preppends content to this YArray.\n   *\n   * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.\n   */\n  unshift (content) {\n    this.insert(0, content)\n  }\n\n  /**\n   * Returns the i-th element from a YArray.\n   *\n   * @param {number} index The index of the element to return from the YArray\n   * @return {YXmlElement|YXmlText}\n   */\n  get (index) {\n    return typeListGet(this, index)\n  }\n\n  /**\n   * Transforms this YArray to a JavaScript Array.\n   *\n   * @param {number} [start]\n   * @param {number} [end]\n   * @return {Array<YXmlElement|YXmlText>}\n   */\n  slice (start = 0, end = this.length) {\n    return typeListSlice(this, start, end)\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlFragmentRefID)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlFragment}\n *\n * @private\n * @function\n */\nexport const readYXmlFragment = decoder => new YXmlFragment()\n","\nimport {\n  YXmlFragment,\n  transact,\n  typeMapDelete,\n  typeMapSet,\n  typeMapGet,\n  typeMapGetAll,\n  typeListForEach,\n  YXmlElementRefID,\n  YXmlText, ContentType, AbstractType, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Snapshot, Doc, Item // eslint-disable-line\n} from '../internals.js'\n\n/**\n * An YXmlElement imitates the behavior of a\n * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}.\n *\n * * An YXmlElement has attributes (key value pairs)\n * * An YXmlElement has childElements that must inherit from YXmlElement\n */\nexport class YXmlElement extends YXmlFragment {\n  constructor (nodeName = 'UNDEFINED') {\n    super()\n    this.nodeName = nodeName\n    /**\n     * @type {Map<string, any>|null}\n     */\n    this._prelimAttrs = new Map()\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * Integrate this type into the Yjs instance.\n   *\n   * * Save this struct in the os\n   * * This type is sent to other client\n   * * Observer functions are fired\n   *\n   * @param {Doc} y The Yjs instance\n   * @param {Item} item\n   */\n  _integrate (y, item) {\n    super._integrate(y, item)\n    ;(/** @type {Map<string, any>} */ (this._prelimAttrs)).forEach((value, key) => {\n      this.setAttribute(key, value)\n    })\n    this._prelimAttrs = null\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   *\n   * @return {YXmlElement}\n   */\n  _copy () {\n    return new YXmlElement(this.nodeName)\n  }\n\n  /**\n   * @return {YXmlElement}\n   */\n  clone () {\n    const el = new YXmlElement(this.nodeName)\n    const attrs = this.getAttributes()\n    for (const key in attrs) {\n      el.setAttribute(key, attrs[key])\n    }\n    // @ts-ignore\n    el.insert(0, el.toArray().map(item => item instanceof AbstractType ? item.clone() : item))\n    return el\n  }\n\n  /**\n   * Returns the XML serialization of this YXmlElement.\n   * The attributes are ordered by attribute-name, so you can easily use this\n   * method to compare YXmlElements\n   *\n   * @return {string} The string representation of this type.\n   *\n   * @public\n   */\n  toString () {\n    const attrs = this.getAttributes()\n    const stringBuilder = []\n    const keys = []\n    for (const key in attrs) {\n      keys.push(key)\n    }\n    keys.sort()\n    const keysLen = keys.length\n    for (let i = 0; i < keysLen; i++) {\n      const key = keys[i]\n      stringBuilder.push(key + '=\"' + attrs[key] + '\"')\n    }\n    const nodeName = this.nodeName.toLocaleLowerCase()\n    const attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : ''\n    return `<${nodeName}${attrsString}>${super.toString()}</${nodeName}>`\n  }\n\n  /**\n   * Removes an attribute from this YXmlElement.\n   *\n   * @param {String} attributeName The attribute name that is to be removed.\n   *\n   * @public\n   */\n  removeAttribute (attributeName) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapDelete(transaction, this, attributeName)\n      })\n    } else {\n      /** @type {Map<string,any>} */ (this._prelimAttrs).delete(attributeName)\n    }\n  }\n\n  /**\n   * Sets or updates an attribute.\n   *\n   * @param {String} attributeName The attribute name that is to be set.\n   * @param {String} attributeValue The attribute value that is to be set.\n   *\n   * @public\n   */\n  setAttribute (attributeName, attributeValue) {\n    if (this.doc !== null) {\n      transact(this.doc, transaction => {\n        typeMapSet(transaction, this, attributeName, attributeValue)\n      })\n    } else {\n      /** @type {Map<string, any>} */ (this._prelimAttrs).set(attributeName, attributeValue)\n    }\n  }\n\n  /**\n   * Returns an attribute value that belongs to the attribute name.\n   *\n   * @param {String} attributeName The attribute name that identifies the\n   *                               queried value.\n   * @return {String} The queried attribute value.\n   *\n   * @public\n   */\n  getAttribute (attributeName) {\n    return /** @type {any} */ (typeMapGet(this, attributeName))\n  }\n\n  /**\n   * Returns all attribute name/value pairs in a JSON Object.\n   *\n   * @param {Snapshot} [snapshot]\n   * @return {Object<string, any>} A JSON Object that describes the attributes.\n   *\n   * @public\n   */\n  getAttributes (snapshot) {\n    return typeMapGetAll(this)\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const dom = _document.createElement(this.nodeName)\n    const attrs = this.getAttributes()\n    for (const key in attrs) {\n      dom.setAttribute(key, attrs[key])\n    }\n    typeListForEach(this, yxml => {\n      dom.appendChild(yxml.toDOM(_document, hooks, binding))\n    })\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this)\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlElementRefID)\n    encoder.writeKey(this.nodeName)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlElement}\n *\n * @function\n */\nexport const readYXmlElement = decoder => new YXmlElement(decoder.readKey())\n","\nimport {\n  YEvent,\n  YXmlText, YXmlElement, YXmlFragment, Transaction // eslint-disable-line\n} from '../internals.js'\n\n/**\n * An Event that describes changes on a YXml Element or Yxml Fragment\n */\nexport class YXmlEvent extends YEvent {\n  /**\n   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.\n   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the\n   *                   child list changed.\n   * @param {Transaction} transaction The transaction instance with wich the\n   *                                  change was created.\n   */\n  constructor (target, subs, transaction) {\n    super(target, transaction)\n    /**\n     * Whether the children changed.\n     * @type {Boolean}\n     * @private\n     */\n    this.childListChanged = false\n    /**\n     * Set of all changed attributes.\n     * @type {Set<string>}\n     */\n    this.attributesChanged = new Set()\n    subs.forEach((sub) => {\n      if (sub === null) {\n        this.childListChanged = true\n      } else {\n        this.attributesChanged.add(sub)\n      }\n    })\n  }\n}\n","\nimport {\n  YMap,\n  YXmlHookRefID,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2 // eslint-disable-line\n} from '../internals.js'\n\n/**\n * You can manage binding to a custom type with YXmlHook.\n *\n * @extends {YMap<any>}\n */\nexport class YXmlHook extends YMap {\n  /**\n   * @param {string} hookName nodeName of the Dom Node.\n   */\n  constructor (hookName) {\n    super()\n    /**\n     * @type {string}\n     */\n    this.hookName = hookName\n  }\n\n  /**\n   * Creates an Item with the same effect as this Item (without position effect)\n   */\n  _copy () {\n    return new YXmlHook(this.hookName)\n  }\n\n  /**\n   * @return {YXmlHook}\n   */\n  clone () {\n    const el = new YXmlHook(this.hookName)\n    this.forEach((value, key) => {\n      el.set(key, value)\n    })\n    return el\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlElement.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type\n   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks = {}, binding) {\n    const hook = hooks[this.hookName]\n    let dom\n    if (hook !== undefined) {\n      dom = hook.createDom(this)\n    } else {\n      dom = document.createElement(this.hookName)\n    }\n    dom.setAttribute('data-yjs-hook', this.hookName)\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this)\n    }\n    return dom\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlHookRefID)\n    encoder.writeKey(this.hookName)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlHook}\n *\n * @private\n * @function\n */\nexport const readYXmlHook = decoder =>\n  new YXmlHook(decoder.readKey())\n","\nimport {\n  YText,\n  YXmlTextRefID,\n  ContentType, YXmlElement, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, // eslint-disable-line\n} from '../internals.js'\n\n/**\n * Represents text in a Dom Element. In the future this type will also handle\n * simple formatting information like bold and italic.\n */\nexport class YXmlText extends YText {\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get nextSibling () {\n    const n = this._item ? this._item.next : null\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  /**\n   * @type {YXmlElement|YXmlText|null}\n   */\n  get prevSibling () {\n    const n = this._item ? this._item.prev : null\n    return n ? /** @type {YXmlElement|YXmlText} */ (/** @type {ContentType} */ (n.content).type) : null\n  }\n\n  _copy () {\n    return new YXmlText()\n  }\n\n  /**\n   * @return {YXmlText}\n   */\n  clone () {\n    const text = new YXmlText()\n    text.applyDelta(this.toDelta())\n    return text\n  }\n\n  /**\n   * Creates a Dom Element that mirrors this YXmlText.\n   *\n   * @param {Document} [_document=document] The document object (you must define\n   *                                        this when calling this method in\n   *                                        nodejs)\n   * @param {Object<string, any>} [hooks] Optional property to customize how hooks\n   *                                             are presented in the DOM\n   * @param {any} [binding] You should not set this property. This is\n   *                               used if DomBinding wants to create a\n   *                               association to the created DOM type.\n   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}\n   *\n   * @public\n   */\n  toDOM (_document = document, hooks, binding) {\n    const dom = _document.createTextNode(this.toString())\n    if (binding !== undefined) {\n      binding._createAssociation(dom, this)\n    }\n    return dom\n  }\n\n  toString () {\n    // @ts-ignore\n    return this.toDelta().map(delta => {\n      const nestedNodes = []\n      for (const nodeName in delta.attributes) {\n        const attrs = []\n        for (const key in delta.attributes[nodeName]) {\n          attrs.push({ key, value: delta.attributes[nodeName][key] })\n        }\n        // sort attributes to get a unique order\n        attrs.sort((a, b) => a.key < b.key ? -1 : 1)\n        nestedNodes.push({ nodeName, attrs })\n      }\n      // sort node order to get a unique order\n      nestedNodes.sort((a, b) => a.nodeName < b.nodeName ? -1 : 1)\n      // now convert to dom string\n      let str = ''\n      for (let i = 0; i < nestedNodes.length; i++) {\n        const node = nestedNodes[i]\n        str += `<${node.nodeName}`\n        for (let j = 0; j < node.attrs.length; j++) {\n          const attr = node.attrs[j]\n          str += ` ${attr.key}=\"${attr.value}\"`\n        }\n        str += '>'\n      }\n      str += delta.insert\n      for (let i = nestedNodes.length - 1; i >= 0; i--) {\n        str += `</${nestedNodes[i].nodeName}>`\n      }\n      return str\n    }).join('')\n  }\n\n  /**\n   * @return {string}\n   */\n  toJSON () {\n    return this.toString()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   */\n  _write (encoder) {\n    encoder.writeTypeRef(YXmlTextRefID)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {YXmlText}\n *\n * @private\n * @function\n */\nexport const readYXmlText = decoder => new YXmlText()\n","\nimport {\n  UpdateEncoderV1, UpdateEncoderV2, ID, Transaction // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error.js'\n\nexport class AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {number} length\n   */\n  constructor (id, length) {\n    this.id = id\n    this.length = length\n  }\n\n  /**\n   * @type {boolean}\n   */\n  get deleted () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * Merge this struct with the item to the right.\n   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.\n   * Also this method does *not* remove right from StructStore!\n   * @param {AbstractStruct} right\n   * @return {boolean} wether this merged with right\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   * @param {number} encodingRef\n   */\n  write (encoder, offset, encodingRef) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    throw error.methodUnimplemented()\n  }\n}\n","\nimport {\n  AbstractStruct,\n  addStruct,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, StructStore, Transaction, ID // eslint-disable-line\n} from '../internals.js'\n\nexport const structGCRefNumber = 0\n\n/**\n * @private\n */\nexport class GC extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {GC} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset\n      this.length -= offset\n    }\n    addStruct(transaction.doc.store, this)\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structGCRefNumber)\n    encoder.writeLen(this.length - offset)\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    return null\n  }\n}\n","import {\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, StructStore, Item, Transaction // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error.js'\n\nexport class ContentBinary {\n  /**\n   * @param {Uint8Array} content\n   */\n  constructor (content) {\n    this.content = content\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.content]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentBinary}\n   */\n  copy () {\n    return new ContentBinary(this.content)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentBinary}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentBinary} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeBuf(this.content)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 3\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentBinary}\n */\nexport const readContentBinary = decoder => new ContentBinary(decoder.readBuf())\n","\nimport {\n  addToDeleteSet,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, StructStore, Item, Transaction // eslint-disable-line\n} from '../internals.js'\n\nexport class ContentDeleted {\n  /**\n   * @param {number} len\n   */\n  constructor (len) {\n    this.len = len\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.len\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentDeleted}\n   */\n  copy () {\n    return new ContentDeleted(this.len)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDeleted}\n   */\n  splice (offset) {\n    const right = new ContentDeleted(this.len - offset)\n    this.len = offset\n    return right\n  }\n\n  /**\n   * @param {ContentDeleted} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.len += right.len\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len)\n    item.markDeleted()\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeLen(this.len - offset)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 1\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder\n * @return {ContentDeleted}\n */\nexport const readContentDeleted = decoder => new ContentDeleted(decoder.readLen())\n","\nimport {\n  Doc, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, StructStore, Transaction, Item // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error.js'\n\n/**\n * @private\n */\nexport class ContentDoc {\n  /**\n   * @param {Doc} doc\n   */\n  constructor (doc) {\n    if (doc._item) {\n      console.error('This document was already integrated as a sub-document. You should create a second instance instead with the same guid.')\n    }\n    /**\n     * @type {Doc}\n     */\n    this.doc = doc\n    /**\n     * @type {any}\n     */\n    const opts = {}\n    this.opts = opts\n    if (!doc.gc) {\n      opts.gc = false\n    }\n    if (doc.autoLoad) {\n      opts.autoLoad = true\n    }\n    if (doc.meta !== null) {\n      opts.meta = doc.meta\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.doc]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentDoc}\n   */\n  copy () {\n    return new ContentDoc(this.doc)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentDoc}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentDoc} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // this needs to be reflected in doc.destroy as well\n    this.doc._item = item\n    transaction.subdocsAdded.add(this.doc)\n    if (this.doc.shouldLoad) {\n      transaction.subdocsLoaded.add(this.doc)\n    }\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (transaction.subdocsAdded.has(this.doc)) {\n      transaction.subdocsAdded.delete(this.doc)\n    } else {\n      transaction.subdocsRemoved.add(this.doc)\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) { }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(this.doc.guid)\n    encoder.writeAny(this.opts)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 9\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentDoc}\n */\nexport const readContentDoc = decoder => new ContentDoc(new Doc({ guid: decoder.readString(), ...decoder.readAny() }))\n","\nimport {\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, StructStore, Item, Transaction // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error.js'\n\n/**\n * @private\n */\nexport class ContentEmbed {\n  /**\n   * @param {Object} embed\n   */\n  constructor (embed) {\n    this.embed = embed\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.embed]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentEmbed}\n   */\n  copy () {\n    return new ContentEmbed(this.embed)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentEmbed}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentEmbed} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeJSON(this.embed)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 5\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentEmbed}\n */\nexport const readContentEmbed = decoder => new ContentEmbed(decoder.readJSON())\n","\nimport {\n  AbstractType, UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Item, StructStore, Transaction // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error.js'\n\n/**\n * @private\n */\nexport class ContentFormat {\n  /**\n   * @param {string} key\n   * @param {Object} value\n   */\n  constructor (key, value) {\n    this.key = key\n    this.value = value\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return []\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return false\n  }\n\n  /**\n   * @return {ContentFormat}\n   */\n  copy () {\n    return new ContentFormat(this.key, this.value)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentFormat}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentFormat} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    // @todo searchmarker are currently unsupported for rich text documents\n    /** @type {AbstractType<any>} */ (item.parent)._searchMarker = null\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeKey(this.key)\n    encoder.writeJSON(this.value)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 6\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentFormat}\n */\nexport const readContentFormat = decoder => new ContentFormat(decoder.readString(), decoder.readJSON())\n","import {\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Transaction, Item, StructStore // eslint-disable-line\n} from '../internals.js'\n\n/**\n * @private\n */\nexport class ContentJSON {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentJSON}\n   */\n  copy () {\n    return new ContentJSON(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentJSON}\n   */\n  splice (offset) {\n    const right = new ContentJSON(this.arr.slice(offset))\n    this.arr = this.arr.slice(0, offset)\n    return right\n  }\n\n  /**\n   * @param {ContentJSON} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr)\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length\n    encoder.writeLen(len - offset)\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i]\n      encoder.writeString(c === undefined ? 'undefined' : JSON.stringify(c))\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 2\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentJSON}\n */\nexport const readContentJSON = decoder => {\n  const len = decoder.readLen()\n  const cs = []\n  for (let i = 0; i < len; i++) {\n    const c = decoder.readString()\n    if (c === 'undefined') {\n      cs.push(undefined)\n    } else {\n      cs.push(JSON.parse(c))\n    }\n  }\n  return new ContentJSON(cs)\n}\n","import {\n  UpdateEncoderV1, UpdateEncoderV2, UpdateDecoderV1, UpdateDecoderV2, Transaction, Item, StructStore // eslint-disable-line\n} from '../internals.js'\n\nexport class ContentAny {\n  /**\n   * @param {Array<any>} arr\n   */\n  constructor (arr) {\n    /**\n     * @type {Array<any>}\n     */\n    this.arr = arr\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.arr.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.arr\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentAny}\n   */\n  copy () {\n    return new ContentAny(this.arr)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentAny}\n   */\n  splice (offset) {\n    const right = new ContentAny(this.arr.slice(offset))\n    this.arr = this.arr.slice(0, offset)\n    return right\n  }\n\n  /**\n   * @param {ContentAny} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.arr = this.arr.concat(right.arr)\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const len = this.arr.length\n    encoder.writeLen(len - offset)\n    for (let i = offset; i < len; i++) {\n      const c = this.arr[i]\n      encoder.writeAny(c)\n    }\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 8\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentAny}\n */\nexport const readContentAny = decoder => {\n  const len = decoder.readLen()\n  const cs = []\n  for (let i = 0; i < len; i++) {\n    cs.push(decoder.readAny())\n  }\n  return new ContentAny(cs)\n}\n","import {\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, Transaction, Item, StructStore // eslint-disable-line\n} from '../internals.js'\n\n/**\n * @private\n */\nexport class ContentString {\n  /**\n   * @param {string} str\n   */\n  constructor (str) {\n    /**\n     * @type {string}\n     */\n    this.str = str\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return this.str.length\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return this.str.split('')\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentString}\n   */\n  copy () {\n    return new ContentString(this.str)\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentString}\n   */\n  splice (offset) {\n    const right = new ContentString(this.str.slice(offset))\n    this.str = this.str.slice(0, offset)\n\n    // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248\n    const firstCharCode = this.str.charCodeAt(offset - 1)\n    if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {\n      // Last character of the left split is the start of a surrogate utf16/ucs2 pair.\n      // We don't support splitting of surrogate pairs because this may lead to invalid documents.\n      // Replace the invalid character with a unicode replacement character ( / U+FFFD)\n      this.str = this.str.slice(0, offset - 1) + ''\n      // replace right as well\n      right.str = '' + right.str.slice(1)\n    }\n    return right\n  }\n\n  /**\n   * @param {ContentString} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    this.str += right.str\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {}\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {}\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {}\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeString(offset === 0 ? this.str : this.str.slice(offset))\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 4\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentString}\n */\nexport const readContentString = decoder => new ContentString(decoder.readString())\n","\nimport {\n  readYArray,\n  readYMap,\n  readYText,\n  readYXmlElement,\n  readYXmlFragment,\n  readYXmlHook,\n  readYXmlText,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, StructStore, Transaction, Item, YEvent, AbstractType // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error.js'\n\n/**\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractType<any>>}\n * @private\n */\nexport const typeRefs = [\n  readYArray,\n  readYMap,\n  readYText,\n  readYXmlElement,\n  readYXmlFragment,\n  readYXmlHook,\n  readYXmlText\n]\n\nexport const YArrayRefID = 0\nexport const YMapRefID = 1\nexport const YTextRefID = 2\nexport const YXmlElementRefID = 3\nexport const YXmlFragmentRefID = 4\nexport const YXmlHookRefID = 5\nexport const YXmlTextRefID = 6\n\n/**\n * @private\n */\nexport class ContentType {\n  /**\n   * @param {AbstractType<YEvent>} type\n   */\n  constructor (type) {\n    /**\n     * @type {AbstractType<any>}\n     */\n    this.type = type\n  }\n\n  /**\n   * @return {number}\n   */\n  getLength () {\n    return 1\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    return [this.type]\n  }\n\n  /**\n   * @return {boolean}\n   */\n  isCountable () {\n    return true\n  }\n\n  /**\n   * @return {ContentType}\n   */\n  copy () {\n    return new ContentType(this.type._copy())\n  }\n\n  /**\n   * @param {number} offset\n   * @return {ContentType}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {ContentType} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    return false\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    this.type._integrate(transaction.doc, item)\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    let item = this.type._start\n    while (item !== null) {\n      if (!item.deleted) {\n        item.delete(transaction)\n      } else {\n        // Whis will be gc'd later and we want to merge it if possible\n        // We try to merge all deleted items after each transaction,\n        // but we have no knowledge about that this needs to be merged\n        // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs\n        transaction._mergeStructs.push(item)\n      }\n      item = item.right\n    }\n    this.type._map.forEach(item => {\n      if (!item.deleted) {\n        item.delete(transaction)\n      } else {\n        // same as above\n        transaction._mergeStructs.push(item)\n      }\n    })\n    transaction.changed.delete(this.type)\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {\n    let item = this.type._start\n    while (item !== null) {\n      item.gc(store, true)\n      item = item.right\n    }\n    this.type._start = null\n    this.type._map.forEach(/** @param {Item | null} item */ (item) => {\n      while (item !== null) {\n        item.gc(store, true)\n        item = item.left\n      }\n    })\n    this.type._map = new Map()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    this.type._write(encoder)\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    return 7\n  }\n}\n\n/**\n * @private\n *\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @return {ContentType}\n */\nexport const readContentType = decoder => new ContentType(typeRefs[decoder.readTypeRef()](decoder))\n","\nimport {\n  GC,\n  getState,\n  AbstractStruct,\n  replaceStruct,\n  addStruct,\n  addToDeleteSet,\n  findRootTypeKey,\n  compareIDs,\n  getItem,\n  getItemCleanEnd,\n  getItemCleanStart,\n  readContentDeleted,\n  readContentBinary,\n  readContentJSON,\n  readContentAny,\n  readContentString,\n  readContentEmbed,\n  readContentDoc,\n  createID,\n  readContentFormat,\n  readContentType,\n  addChangedTypeToTransaction,\n  UpdateDecoderV1, UpdateDecoderV2, UpdateEncoderV1, UpdateEncoderV2, ContentType, ContentDeleted, StructStore, ID, AbstractType, Transaction // eslint-disable-line\n} from '../internals.js'\n\nimport * as error from 'lib0/error.js'\nimport * as binary from 'lib0/binary.js'\n\n/**\n * @todo This should return several items\n *\n * @param {StructStore} store\n * @param {ID} id\n * @return {{item:Item, diff:number}}\n */\nexport const followRedone = (store, id) => {\n  /**\n   * @type {ID|null}\n   */\n  let nextID = id\n  let diff = 0\n  let item\n  do {\n    if (diff > 0) {\n      nextID = createID(nextID.client, nextID.clock + diff)\n    }\n    item = getItem(store, nextID)\n    diff = nextID.clock - item.id.clock\n    nextID = item.redone\n  } while (nextID !== null && item instanceof Item)\n  return {\n    item, diff\n  }\n}\n\n/**\n * Make sure that neither item nor any of its parents is ever deleted.\n *\n * This property does not persist when storing it into a database or when\n * sending it to other peers\n *\n * @param {Item|null} item\n * @param {boolean} keep\n */\nexport const keepItem = (item, keep) => {\n  while (item !== null && item.keep !== keep) {\n    item.keep = keep\n    item = /** @type {AbstractType<any>} */ (item.parent)._item\n  }\n}\n\n/**\n * Split leftItem into two items\n * @param {Transaction} transaction\n * @param {Item} leftItem\n * @param {number} diff\n * @return {Item}\n *\n * @function\n * @private\n */\nexport const splitItem = (transaction, leftItem, diff) => {\n  // create rightItem\n  const { client, clock } = leftItem.id\n  const rightItem = new Item(\n    createID(client, clock + diff),\n    leftItem,\n    createID(client, clock + diff - 1),\n    leftItem.right,\n    leftItem.rightOrigin,\n    leftItem.parent,\n    leftItem.parentSub,\n    leftItem.content.splice(diff)\n  )\n  if (leftItem.deleted) {\n    rightItem.markDeleted()\n  }\n  if (leftItem.keep) {\n    rightItem.keep = true\n  }\n  if (leftItem.redone !== null) {\n    rightItem.redone = createID(leftItem.redone.client, leftItem.redone.clock + diff)\n  }\n  // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)\n  leftItem.right = rightItem\n  // update right\n  if (rightItem.right !== null) {\n    rightItem.right.left = rightItem\n  }\n  // right is more specific.\n  transaction._mergeStructs.push(rightItem)\n  // update parent._map\n  if (rightItem.parentSub !== null && rightItem.right === null) {\n    /** @type {AbstractType<any>} */ (rightItem.parent)._map.set(rightItem.parentSub, rightItem)\n  }\n  leftItem.length = diff\n  return rightItem\n}\n\n/**\n * Redoes the effect of this operation.\n *\n * @param {Transaction} transaction The Yjs instance.\n * @param {Item} item\n * @param {Set<Item>} redoitems\n *\n * @return {Item|null}\n *\n * @private\n */\nexport const redoItem = (transaction, item, redoitems) => {\n  const doc = transaction.doc\n  const store = doc.store\n  const ownClientID = doc.clientID\n  const redone = item.redone\n  if (redone !== null) {\n    return getItemCleanStart(transaction, redone)\n  }\n  let parentItem = /** @type {AbstractType<any>} */ (item.parent)._item\n  /**\n   * @type {Item|null}\n   */\n  let left\n  /**\n   * @type {Item|null}\n   */\n  let right\n  if (item.parentSub === null) {\n    // Is an array item. Insert at the old position\n    left = item.left\n    right = item\n  } else {\n    // Is a map item. Insert as current value\n    left = item\n    while (left.right !== null) {\n      left = left.right\n      if (left.id.client !== ownClientID) {\n        // It is not possible to redo this item because it conflicts with a\n        // change from another client\n        return null\n      }\n    }\n    if (left.right !== null) {\n      left = /** @type {Item} */ (/** @type {AbstractType<any>} */ (item.parent)._map.get(item.parentSub))\n    }\n    right = null\n  }\n  // make sure that parent is redone\n  if (parentItem !== null && parentItem.deleted === true && parentItem.redone === null) {\n    // try to undo parent if it will be undone anyway\n    if (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems) === null) {\n      return null\n    }\n  }\n  if (parentItem !== null && parentItem.redone !== null) {\n    while (parentItem.redone !== null) {\n      parentItem = getItemCleanStart(transaction, parentItem.redone)\n    }\n    // find next cloned_redo items\n    while (left !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let leftTrace = left\n      // trace redone until parent matches\n      while (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item !== parentItem) {\n        leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone)\n      }\n      if (leftTrace !== null && /** @type {AbstractType<any>} */ (leftTrace.parent)._item === parentItem) {\n        left = leftTrace\n        break\n      }\n      left = left.left\n    }\n    while (right !== null) {\n      /**\n       * @type {Item|null}\n       */\n      let rightTrace = right\n      // trace redone until parent matches\n      while (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item !== parentItem) {\n        rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone)\n      }\n      if (rightTrace !== null && /** @type {AbstractType<any>} */ (rightTrace.parent)._item === parentItem) {\n        right = rightTrace\n        break\n      }\n      right = right.right\n    }\n  }\n  const nextClock = getState(store, ownClientID)\n  const nextId = createID(ownClientID, nextClock)\n  const redoneItem = new Item(\n    nextId,\n    left, left && left.lastId,\n    right, right && right.id,\n    parentItem === null ? item.parent : /** @type {ContentType} */ (parentItem.content).type,\n    item.parentSub,\n    item.content.copy()\n  )\n  item.redone = nextId\n  keepItem(redoneItem, true)\n  redoneItem.integrate(transaction, 0)\n  return redoneItem\n}\n\n/**\n * Abstract class that represents any content.\n */\nexport class Item extends AbstractStruct {\n  /**\n   * @param {ID} id\n   * @param {Item | null} left\n   * @param {ID | null} origin\n   * @param {Item | null} right\n   * @param {ID | null} rightOrigin\n   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.\n   * @param {string | null} parentSub\n   * @param {AbstractContent} content\n   */\n  constructor (id, left, origin, right, rightOrigin, parent, parentSub, content) {\n    super(id, content.getLength())\n    /**\n     * The item that was originally to the left of this item.\n     * @type {ID | null}\n     */\n    this.origin = origin\n    /**\n     * The item that is currently to the left of this item.\n     * @type {Item | null}\n     */\n    this.left = left\n    /**\n     * The item that is currently to the right of this item.\n     * @type {Item | null}\n     */\n    this.right = right\n    /**\n     * The item that was originally to the right of this item.\n     * @type {ID | null}\n     */\n    this.rightOrigin = rightOrigin\n    /**\n     * @type {AbstractType<any>|ID|null}\n     */\n    this.parent = parent\n    /**\n     * If the parent refers to this item with some kind of key (e.g. YMap, the\n     * key is specified here. The key is then used to refer to the list in which\n     * to insert this item. If `parentSub = null` type._start is the list in\n     * which to insert to. Otherwise it is `parent._map`.\n     * @type {String | null}\n     */\n    this.parentSub = parentSub\n    /**\n     * If this type's effect is reundone this type refers to the type that undid\n     * this operation.\n     * @type {ID | null}\n     */\n    this.redone = null\n    /**\n     * @type {AbstractContent}\n     */\n    this.content = content\n    /**\n     * bit1: keep\n     * bit2: countable\n     * bit3: deleted\n     * bit4: mark - mark node as fast-search-marker\n     * @type {number} byte\n     */\n    this.info = this.content.isCountable() ? binary.BIT2 : 0\n  }\n\n  /**\n   * This is used to mark the item as an indexed fast-search marker\n   *\n   * @type {boolean}\n   */\n  set marker (isMarked) {\n    if (((this.info & binary.BIT4) > 0) !== isMarked) {\n      this.info ^= binary.BIT4\n    }\n  }\n\n  get marker () {\n    return (this.info & binary.BIT4) > 0\n  }\n\n  /**\n   * If true, do not garbage collect this Item.\n   */\n  get keep () {\n    return (this.info & binary.BIT1) > 0\n  }\n\n  set keep (doKeep) {\n    if (this.keep !== doKeep) {\n      this.info ^= binary.BIT1\n    }\n  }\n\n  get countable () {\n    return (this.info & binary.BIT2) > 0\n  }\n\n  /**\n   * Whether this item was deleted or not.\n   * @type {Boolean}\n   */\n  get deleted () {\n    return (this.info & binary.BIT3) > 0\n  }\n\n  set deleted (doDelete) {\n    if (this.deleted !== doDelete) {\n      this.info ^= binary.BIT3\n    }\n  }\n\n  markDeleted () {\n    this.info |= binary.BIT3\n  }\n\n  /**\n   * Return the creator clientID of the missing op or define missing items and return null.\n   *\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= getState(store, this.origin.client)) {\n      return this.origin.client\n    }\n    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= getState(store, this.rightOrigin.client)) {\n      return this.rightOrigin.client\n    }\n    if (this.parent && this.parent.constructor === ID && this.id.client !== this.parent.client && this.parent.clock >= getState(store, this.parent.client)) {\n      return this.parent.client\n    }\n\n    // We have all missing ids, now find the items\n\n    if (this.origin) {\n      this.left = getItemCleanEnd(transaction, store, this.origin)\n      this.origin = this.left.lastId\n    }\n    if (this.rightOrigin) {\n      this.right = getItemCleanStart(transaction, this.rightOrigin)\n      this.rightOrigin = this.right.id\n    }\n    if ((this.left && this.left.constructor === GC) || (this.right && this.right.constructor === GC)) {\n      this.parent = null\n    }\n    // only set parent if this shouldn't be garbage collected\n    if (!this.parent) {\n      if (this.left && this.left.constructor === Item) {\n        this.parent = this.left.parent\n        this.parentSub = this.left.parentSub\n      }\n      if (this.right && this.right.constructor === Item) {\n        this.parent = this.right.parent\n        this.parentSub = this.right.parentSub\n      }\n    } else if (this.parent.constructor === ID) {\n      const parentItem = getItem(store, this.parent)\n      if (parentItem.constructor === GC) {\n        this.parent = null\n      } else {\n        this.parent = /** @type {ContentType} */ (parentItem.content).type\n      }\n    }\n    return null\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    if (offset > 0) {\n      this.id.clock += offset\n      this.left = getItemCleanEnd(transaction, transaction.doc.store, createID(this.id.client, this.id.clock - 1))\n      this.origin = this.left.lastId\n      this.content = this.content.splice(offset)\n      this.length -= offset\n    }\n\n    if (this.parent) {\n      if ((!this.left && (!this.right || this.right.left !== null)) || (this.left && this.left.right !== this.right)) {\n        /**\n         * @type {Item|null}\n         */\n        let left = this.left\n\n        /**\n         * @type {Item|null}\n         */\n        let o\n        // set o to the first conflicting item\n        if (left !== null) {\n          o = left.right\n        } else if (this.parentSub !== null) {\n          o = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null\n          while (o !== null && o.left !== null) {\n            o = o.left\n          }\n        } else {\n          o = /** @type {AbstractType<any>} */ (this.parent)._start\n        }\n        // TODO: use something like DeleteSet here (a tree implementation would be best)\n        // @todo use global set definitions\n        /**\n         * @type {Set<Item>}\n         */\n        const conflictingItems = new Set()\n        /**\n         * @type {Set<Item>}\n         */\n        const itemsBeforeOrigin = new Set()\n        // Let c in conflictingItems, b in itemsBeforeOrigin\n        // ***{origin}bbbb{this}{c,b}{c,b}{o}***\n        // Note that conflictingItems is a subset of itemsBeforeOrigin\n        while (o !== null && o !== this.right) {\n          itemsBeforeOrigin.add(o)\n          conflictingItems.add(o)\n          if (compareIDs(this.origin, o.origin)) {\n            // case 1\n            if (o.id.client < this.id.client) {\n              left = o\n              conflictingItems.clear()\n            } else if (compareIDs(this.rightOrigin, o.rightOrigin)) {\n              // this and o are conflicting and point to the same integration points. The id decides which item comes first.\n              // Since this is to the left of o, we can break here\n              break\n            } // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations\n          } else if (o.origin !== null && itemsBeforeOrigin.has(getItem(transaction.doc.store, o.origin))) { // use getItem instead of getItemCleanEnd because we don't want / need to split items.\n            // case 2\n            if (!conflictingItems.has(getItem(transaction.doc.store, o.origin))) {\n              left = o\n              conflictingItems.clear()\n            }\n          } else {\n            break\n          }\n          o = o.right\n        }\n        this.left = left\n      }\n      // reconnect left/right + update parent map/start if necessary\n      if (this.left !== null) {\n        const right = this.left.right\n        this.right = right\n        this.left.right = this\n      } else {\n        let r\n        if (this.parentSub !== null) {\n          r = /** @type {AbstractType<any>} */ (this.parent)._map.get(this.parentSub) || null\n          while (r !== null && r.left !== null) {\n            r = r.left\n          }\n        } else {\n          r = /** @type {AbstractType<any>} */ (this.parent)._start\n          ;/** @type {AbstractType<any>} */ (this.parent)._start = this\n        }\n        this.right = r\n      }\n      if (this.right !== null) {\n        this.right.left = this\n      } else if (this.parentSub !== null) {\n        // set as current parent value if right === null and this is parentSub\n        /** @type {AbstractType<any>} */ (this.parent)._map.set(this.parentSub, this)\n        if (this.left !== null) {\n          // this is the current attribute value of parent. delete right\n          this.left.delete(transaction)\n        }\n      }\n      // adjust length of parent\n      if (this.parentSub === null && this.countable && !this.deleted) {\n        /** @type {AbstractType<any>} */ (this.parent)._length += this.length\n      }\n      addStruct(transaction.doc.store, this)\n      this.content.integrate(transaction, this)\n      // add parent to transaction.changed\n      addChangedTypeToTransaction(transaction, /** @type {AbstractType<any>} */ (this.parent), this.parentSub)\n      if ((/** @type {AbstractType<any>} */ (this.parent)._item !== null && /** @type {AbstractType<any>} */ (this.parent)._item.deleted) || (this.parentSub !== null && this.right !== null)) {\n        // delete if parent is deleted or if this is not the current attribute value of parent\n        this.delete(transaction)\n      }\n    } else {\n      // parent is not defined. Integrate GC struct instead\n      new GC(this.id, this.length).integrate(transaction, 0)\n    }\n  }\n\n  /**\n   * Returns the next non-deleted item\n   */\n  get next () {\n    let n = this.right\n    while (n !== null && n.deleted) {\n      n = n.right\n    }\n    return n\n  }\n\n  /**\n   * Returns the previous non-deleted item\n   */\n  get prev () {\n    let n = this.left\n    while (n !== null && n.deleted) {\n      n = n.left\n    }\n    return n\n  }\n\n  /**\n   * Computes the last content address of this Item.\n   */\n  get lastId () {\n    // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible\n    return this.length === 1 ? this.id : createID(this.id.client, this.id.clock + this.length - 1)\n  }\n\n  /**\n   * Try to merge two items\n   *\n   * @param {Item} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (\n      this.constructor === right.constructor &&\n      compareIDs(right.origin, this.lastId) &&\n      this.right === right &&\n      compareIDs(this.rightOrigin, right.rightOrigin) &&\n      this.id.client === right.id.client &&\n      this.id.clock + this.length === right.id.clock &&\n      this.deleted === right.deleted &&\n      this.redone === null &&\n      right.redone === null &&\n      this.content.constructor === right.content.constructor &&\n      this.content.mergeWith(right.content)\n    ) {\n      if (right.keep) {\n        this.keep = true\n      }\n      this.right = right.right\n      if (this.right !== null) {\n        this.right.left = this\n      }\n      this.length += right.length\n      return true\n    }\n    return false\n  }\n\n  /**\n   * Mark this Item as deleted.\n   *\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    if (!this.deleted) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent)\n      // adjust the length of parent\n      if (this.countable && this.parentSub === null) {\n        parent._length -= this.length\n      }\n      this.markDeleted()\n      addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length)\n      addChangedTypeToTransaction(transaction, parent, this.parentSub)\n      this.content.delete(transaction)\n    }\n  }\n\n  /**\n   * @param {StructStore} store\n   * @param {boolean} parentGCd\n   */\n  gc (store, parentGCd) {\n    if (!this.deleted) {\n      throw error.unexpectedCase()\n    }\n    this.content.gc(store)\n    if (parentGCd) {\n      replaceStruct(store, this, new GC(this.id, this.length))\n    } else {\n      this.content = new ContentDeleted(this.length)\n    }\n  }\n\n  /**\n   * Transform the properties of this type to binary and write it to an\n   * BinaryEncoder.\n   *\n   * This is called when this Item is sent to a remote peer.\n   *\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    const origin = offset > 0 ? createID(this.id.client, this.id.clock + offset - 1) : this.origin\n    const rightOrigin = this.rightOrigin\n    const parentSub = this.parentSub\n    const info = (this.content.getRef() & binary.BITS5) |\n      (origin === null ? 0 : binary.BIT8) | // origin is defined\n      (rightOrigin === null ? 0 : binary.BIT7) | // right origin is defined\n      (parentSub === null ? 0 : binary.BIT6) // parentSub is non-null\n    encoder.writeInfo(info)\n    if (origin !== null) {\n      encoder.writeLeftID(origin)\n    }\n    if (rightOrigin !== null) {\n      encoder.writeRightID(rightOrigin)\n    }\n    if (origin === null && rightOrigin === null) {\n      const parent = /** @type {AbstractType<any>} */ (this.parent)\n      if (parent._item !== undefined) {\n        const parentItem = parent._item\n        if (parentItem === null) {\n          // parent type on y._map\n          // find the correct key\n          const ykey = findRootTypeKey(parent)\n          encoder.writeParentInfo(true) // write parentYKey\n          encoder.writeString(ykey)\n        } else {\n          encoder.writeParentInfo(false) // write parent id\n          encoder.writeLeftID(parentItem.id)\n        }\n      } else if (parent.constructor === String) { // this edge case was added by differential updates\n        encoder.writeParentInfo(true) // write parentYKey\n        encoder.writeString(parent)\n      } else if (parent.constructor === ID) {\n        encoder.writeParentInfo(false) // write parent id\n        encoder.writeLeftID(parent)\n      } else {\n        error.unexpectedCase()\n      }\n      if (parentSub !== null) {\n        encoder.writeString(parentSub)\n      }\n    }\n    this.content.write(encoder, offset)\n  }\n}\n\n/**\n * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder\n * @param {number} info\n */\nexport const readItemContent = (decoder, info) => contentRefs[info & binary.BITS5](decoder)\n\n/**\n * A lookup map for reading Item content.\n *\n * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent>}\n */\nexport const contentRefs = [\n  () => { error.unexpectedCase() }, // GC is not ItemContent\n  readContentDeleted, // 1\n  readContentJSON, // 2\n  readContentBinary, // 3\n  readContentString, // 4\n  readContentEmbed, // 5\n  readContentFormat, // 6\n  readContentType, // 7\n  readContentAny, // 8\n  readContentDoc, // 9\n  () => { error.unexpectedCase() } // 10 - Skip is not ItemContent\n]\n\n/**\n * Do not implement this class!\n */\nexport class AbstractContent {\n  /**\n   * @return {number}\n   */\n  getLength () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @return {Array<any>}\n   */\n  getContent () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * Should return false if this Item is some kind of meta information\n   * (e.g. format information).\n   *\n   * * Whether this Item should be addressable via `yarray.get(i)`\n   * * Whether this Item should be counted when computing yarray.length\n   *\n   * @return {boolean}\n   */\n  isCountable () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @return {AbstractContent}\n   */\n  copy () {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {number} offset\n   * @return {AbstractContent}\n   */\n  splice (offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {AbstractContent} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {Item} item\n   */\n  integrate (transaction, item) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {Transaction} transaction\n   */\n  delete (transaction) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {StructStore} store\n   */\n  gc (store) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    throw error.methodUnimplemented()\n  }\n\n  /**\n   * @return {number}\n   */\n  getRef () {\n    throw error.methodUnimplemented()\n  }\n}\n","\nimport {\n  AbstractStruct,\n  UpdateEncoderV1, UpdateEncoderV2, StructStore, Transaction, ID // eslint-disable-line\n} from '../internals.js'\nimport * as error from 'lib0/error.js'\nimport * as encoding from 'lib0/encoding.js'\n\nexport const structSkipRefNumber = 10\n\n/**\n * @private\n */\nexport class Skip extends AbstractStruct {\n  get deleted () {\n    return true\n  }\n\n  delete () {}\n\n  /**\n   * @param {Skip} right\n   * @return {boolean}\n   */\n  mergeWith (right) {\n    if (this.constructor !== right.constructor) {\n      return false\n    }\n    this.length += right.length\n    return true\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {number} offset\n   */\n  integrate (transaction, offset) {\n    // skip structs cannot be integrated\n    error.unexpectedCase()\n  }\n\n  /**\n   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder\n   * @param {number} offset\n   */\n  write (encoder, offset) {\n    encoder.writeInfo(structSkipRefNumber)\n    // write as VarUint because Skips can't make use of predictable length-encoding\n    encoding.writeVarUint(encoder.restEncoder, this.length - offset)\n  }\n\n  /**\n   * @param {Transaction} transaction\n   * @param {StructStore} store\n   * @return {null | number}\n   */\n  getMissing (transaction, store) {\n    return null\n  }\n}\n","import objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nexport default function _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}","export default function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}","import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nimport toPrimitive from \"@babel/runtime/helpers/esm/toPrimitive\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import _typeof from \"@babel/runtime/helpers/esm/typeof\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n\n  return (hint === \"string\" ? String : Number)(input);\n}","/**\n * Utility module to work with key-value stores.\n *\n * @module map\n */\n\n/**\n * Creates a new Map instance.\n *\n * @function\n * @return {Map<any, any>}\n *\n * @function\n */\nexport const create = () => new Map()\n\n/**\n * Copy a Map object into a fresh Map object.\n *\n * @function\n * @template X,Y\n * @param {Map<X,Y>} m\n * @return {Map<X,Y>}\n */\nexport const copy = m => {\n  const r = create()\n  m.forEach((v, k) => { r.set(k, v) })\n  return r\n}\n\n/**\n * Get map property. Create T if property is undefined and set T on map.\n *\n * ```js\n * const listeners = map.setIfUndefined(events, 'eventName', set.create)\n * listeners.add(listener)\n * ```\n *\n * @function\n * @template T,K\n * @param {Map<K, T>} map\n * @param {K} key\n * @param {function():T} createT\n * @return {T}\n */\nexport const setIfUndefined = (map, key, createT) => {\n  let set = map.get(key)\n  if (set === undefined) {\n    map.set(key, set = createT())\n  }\n  return set\n}\n\n/**\n * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.\n *\n * @function\n * @template K\n * @template V\n * @template R\n * @param {Map<K,V>} m\n * @param {function(V,K):R} f\n * @return {Array<R>}\n */\nexport const map = (m, f) => {\n  const res = []\n  for (const [key, value] of m) {\n    res.push(f(value, key))\n  }\n  return res\n}\n\n/**\n * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @todo should rename to some - similarly to Array.some\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const any = (m, f) => {\n  for (const [key, value] of m) {\n    if (f(value, key)) {\n      return true\n    }\n  }\n  return false\n}\n\n/**\n * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.\n *\n * @function\n * @template K\n * @template V\n * @param {Map<K,V>} m\n * @param {function(V,K):boolean} f\n * @return {boolean}\n */\nexport const all = (m, f) => {\n  for (const [key, value] of m) {\n    if (!f(value, key)) {\n      return false\n    }\n  }\n  return true\n}\n","/* eslint-env browser */\n\n/**\n * Binary data constants.\n *\n * @module binary\n */\n\n/**\n * n-th bit activated.\n *\n * @type {number}\n */\nexport const BIT1 = 1\nexport const BIT2 = 2\nexport const BIT3 = 4\nexport const BIT4 = 8\nexport const BIT5 = 16\nexport const BIT6 = 32\nexport const BIT7 = 64\nexport const BIT8 = 128\nexport const BIT9 = 256\nexport const BIT10 = 512\nexport const BIT11 = 1024\nexport const BIT12 = 2048\nexport const BIT13 = 4096\nexport const BIT14 = 8192\nexport const BIT15 = 16384\nexport const BIT16 = 32768\nexport const BIT17 = 65536\nexport const BIT18 = 1 << 17\nexport const BIT19 = 1 << 18\nexport const BIT20 = 1 << 19\nexport const BIT21 = 1 << 20\nexport const BIT22 = 1 << 21\nexport const BIT23 = 1 << 22\nexport const BIT24 = 1 << 23\nexport const BIT25 = 1 << 24\nexport const BIT26 = 1 << 25\nexport const BIT27 = 1 << 26\nexport const BIT28 = 1 << 27\nexport const BIT29 = 1 << 28\nexport const BIT30 = 1 << 29\nexport const BIT31 = 1 << 30\nexport const BIT32 = 1 << 31\n\n/**\n * First n bits activated.\n *\n * @type {number}\n */\nexport const BITS0 = 0\nexport const BITS1 = 1\nexport const BITS2 = 3\nexport const BITS3 = 7\nexport const BITS4 = 15\nexport const BITS5 = 31\nexport const BITS6 = 63\nexport const BITS7 = 127\nexport const BITS8 = 255\nexport const BITS9 = 511\nexport const BITS10 = 1023\nexport const BITS11 = 2047\nexport const BITS12 = 4095\nexport const BITS13 = 8191\nexport const BITS14 = 16383\nexport const BITS15 = 32767\nexport const BITS16 = 65535\nexport const BITS17 = BIT18 - 1\nexport const BITS18 = BIT19 - 1\nexport const BITS19 = BIT20 - 1\nexport const BITS20 = BIT21 - 1\nexport const BITS21 = BIT22 - 1\nexport const BITS22 = BIT23 - 1\nexport const BITS23 = BIT24 - 1\nexport const BITS24 = BIT25 - 1\nexport const BITS25 = BIT26 - 1\nexport const BITS26 = BIT27 - 1\nexport const BITS27 = BIT28 - 1\nexport const BITS28 = BIT29 - 1\nexport const BITS29 = BIT30 - 1\nexport const BITS30 = BIT31 - 1\n/**\n * @type {number}\n */\nexport const BITS31 = 0x7FFFFFFF\n/**\n * @type {number}\n */\nexport const BITS32 = 0xFFFFFFFF\n","/**\n * Utility functions to work with buffers (Uint8Array).\n *\n * @module buffer\n */\n\nimport * as string from './string.js'\nimport * as env from './environment.js'\nimport * as encoding from './encoding.js'\nimport * as decoding from './decoding.js'\n\n/**\n * @param {number} len\n */\nexport const createUint8ArrayFromLen = len => new Uint8Array(len)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n * @param {number} byteOffset\n * @param {number} length\n */\nexport const createUint8ArrayViewFromArrayBuffer = (buffer, byteOffset, length) => new Uint8Array(buffer, byteOffset, length)\n\n/**\n * Create Uint8Array with initial content from buffer\n *\n * @param {ArrayBuffer} buffer\n */\nexport const createUint8ArrayFromArrayBuffer = buffer => new Uint8Array(buffer)\n\n/* istanbul ignore next */\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Browser = bytes => {\n  let s = ''\n  for (let i = 0; i < bytes.byteLength; i++) {\n    s += string.fromCharCode(bytes[i])\n  }\n  // eslint-disable-next-line no-undef\n  return btoa(s)\n}\n\n/**\n * @param {Uint8Array} bytes\n * @return {string}\n */\nconst toBase64Node = bytes => Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString('base64')\n\n/* istanbul ignore next */\n/**\n * @param {string} s\n * @return {Uint8Array}\n */\nconst fromBase64Browser = s => {\n  // eslint-disable-next-line no-undef\n  const a = atob(s)\n  const bytes = createUint8ArrayFromLen(a.length)\n  for (let i = 0; i < a.length; i++) {\n    bytes[i] = a.charCodeAt(i)\n  }\n  return bytes\n}\n\n/**\n * @param {string} s\n */\nconst fromBase64Node = s => {\n  const buf = Buffer.from(s, 'base64')\n  return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength)\n}\n\n/* istanbul ignore next */\nexport const toBase64 = env.isBrowser ? toBase64Browser : toBase64Node\n\n/* istanbul ignore next */\nexport const fromBase64 = env.isBrowser ? fromBase64Browser : fromBase64Node\n\n/**\n * Copy the content of an Uint8Array view to a new ArrayBuffer.\n *\n * @param {Uint8Array} uint8Array\n * @return {Uint8Array}\n */\nexport const copyUint8Array = uint8Array => {\n  const newBuf = createUint8ArrayFromLen(uint8Array.byteLength)\n  newBuf.set(uint8Array)\n  return newBuf\n}\n\n/**\n * Encode anything as a UInt8Array. It's a pun on typescripts's `any` type.\n * See encoding.writeAny for more information.\n *\n * @param {any} data\n * @return {Uint8Array}\n */\nexport const encodeAny = data => {\n  const encoder = encoding.createEncoder()\n  encoding.writeAny(encoder, data)\n  return encoding.toUint8Array(encoder)\n}\n\n/**\n * Decode an any-encoded value.\n *\n * @param {Uint8Array} buf\n * @return {any}\n */\nexport const decodeAny = buf => decoding.readAny(decoding.createDecoder(buf))\n","function _extends() {\n  module.exports = _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nmodule.exports = _extends;","var mapping = {\n  name: 'a',\n  unified: 'b',\n  non_qualified: 'c',\n  has_img_apple: 'd',\n  has_img_google: 'e',\n  has_img_twitter: 'f',\n  has_img_facebook: 'h',\n  keywords: 'j',\n  sheet: 'k',\n  emoticons: 'l',\n  text: 'm',\n  short_names: 'n',\n  added_in: 'o'\n};\n\nvar buildSearch = function buildSearch(emoji) {\n  var search = [];\n\n  var addToSearch = function addToSearch(strings, split) {\n    if (!strings) {\n      return;\n    }\n\n    ;\n    (Array.isArray(strings) ? strings : [strings]).forEach(function (string) {\n      ;\n      (split ? string.split(/[-|_|\\s]+/) : [string]).forEach(function (s) {\n        s = s.toLowerCase();\n\n        if (search.indexOf(s) == -1) {\n          search.push(s);\n        }\n      });\n    });\n  };\n\n  addToSearch(emoji.short_names, true);\n  addToSearch(emoji.name, true);\n  addToSearch(emoji.keywords, false);\n  addToSearch(emoji.emoticons, false);\n  return search.join(',');\n};\n\nvar compress = function compress(emoji) {\n  emoji.short_names = emoji.short_names.filter(function (short_name) {\n    return short_name !== emoji.short_name;\n  });\n  delete emoji.short_name;\n  emoji.sheet = [emoji.sheet_x, emoji.sheet_y];\n  delete emoji.sheet_x;\n  delete emoji.sheet_y;\n  emoji.added_in = parseInt(emoji.added_in);\n\n  if (emoji.added_in === 6) {\n    delete emoji.added_in;\n  }\n\n  for (var key in mapping) {\n    emoji[mapping[key]] = emoji[key];\n    delete emoji[key];\n  }\n\n  for (var _key in emoji) {\n    var value = emoji[_key];\n\n    if (Array.isArray(value) && !value.length) {\n      delete emoji[_key];\n    } else if (typeof value === 'string' && !value.length) {\n      delete emoji[_key];\n    } else if (value === null) {\n      delete emoji[_key];\n    }\n  }\n};\n\nvar uncompress = function uncompress(data) {\n  data.compressed = false;\n\n  for (var id in data.emojis) {\n    var emoji = data.emojis[id];\n\n    for (var key in mapping) {\n      emoji[key] = emoji[mapping[key]];\n      delete emoji[mapping[key]];\n    }\n\n    if (!emoji.short_names) emoji.short_names = [];\n    emoji.short_names.unshift(id);\n    emoji.sheet_x = emoji.sheet[0];\n    emoji.sheet_y = emoji.sheet[1];\n    delete emoji.sheet;\n    if (!emoji.text) emoji.text = '';\n    if (!emoji.added_in) emoji.added_in = 6;\n    emoji.added_in = emoji.added_in.toFixed(1);\n    emoji.search = buildSearch(emoji);\n  }\n};\n\nexport { buildSearch, compress, uncompress };","var _String = String;\nexport default _String.fromCodePoint || function stringFromCodePoint() {\n  var MAX_SIZE = 0x4000;\n  var codeUnits = [];\n  var highSurrogate;\n  var lowSurrogate;\n  var index = -1;\n  var length = arguments.length;\n\n  if (!length) {\n    return '';\n  }\n\n  var result = '';\n\n  while (++index < length) {\n    var codePoint = Number(arguments[index]);\n\n    if (!isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`\n    codePoint < 0 || // not a valid Unicode code point\n    codePoint > 0x10ffff || // not a valid Unicode code point\n    Math.floor(codePoint) != codePoint // not an integer\n    ) {\n        throw RangeError('Invalid code point: ' + codePoint);\n      }\n\n    if (codePoint <= 0xffff) {\n      // BMP code point\n      codeUnits.push(codePoint);\n    } else {\n      // Astral code point; split in surrogate halves\n      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n      codePoint -= 0x10000;\n      highSurrogate = (codePoint >> 10) + 0xd800;\n      lowSurrogate = codePoint % 0x400 + 0xdc00;\n      codeUnits.push(highSurrogate, lowSurrogate);\n    }\n\n    if (index + 1 === length || codeUnits.length > MAX_SIZE) {\n      result += String.fromCharCode.apply(null, codeUnits);\n      codeUnits.length = 0;\n    }\n  }\n\n  return result;\n};","import _typeof from \"@babel/runtime/helpers/typeof\";\nimport { buildSearch } from './data';\nimport stringFromCodePoint from '../polyfills/stringFromCodePoint';\nimport { uncompress } from './data';\nvar COLONS_REGEX = /^(?:\\:([^\\:]+)\\:)(?:\\:skin-tone-(\\d)\\:)?$/;\nvar SKINS = ['1F3FA', '1F3FB', '1F3FC', '1F3FD', '1F3FE', '1F3FF'];\n\nfunction unifiedToNative(unified) {\n  var unicodes = unified.split('-'),\n      codePoints = unicodes.map(function (u) {\n    return \"0x\".concat(u);\n  });\n  return stringFromCodePoint.apply(null, codePoints);\n}\n\nfunction sanitize(emoji) {\n  var name = emoji.name,\n      short_names = emoji.short_names,\n      skin_tone = emoji.skin_tone,\n      skin_variations = emoji.skin_variations,\n      emoticons = emoji.emoticons,\n      unified = emoji.unified,\n      custom = emoji.custom,\n      customCategory = emoji.customCategory,\n      imageUrl = emoji.imageUrl,\n      id = emoji.id || short_names[0],\n      colons = \":\".concat(id, \":\");\n\n  if (custom) {\n    return {\n      id: id,\n      name: name,\n      short_names: short_names,\n      colons: colons,\n      emoticons: emoticons,\n      custom: custom,\n      customCategory: customCategory,\n      imageUrl: imageUrl\n    };\n  }\n\n  if (skin_tone) {\n    colons += \":skin-tone-\".concat(skin_tone, \":\");\n  }\n\n  return {\n    id: id,\n    name: name,\n    short_names: short_names,\n    colons: colons,\n    emoticons: emoticons,\n    unified: unified.toLowerCase(),\n    skin: skin_tone || (skin_variations ? 1 : null),\n    \"native\": unifiedToNative(unified)\n  };\n}\n\nfunction getSanitizedData() {\n  return sanitize(getData.apply(void 0, arguments));\n}\n\nfunction getData(emoji, skin, set, data) {\n  var emojiData = {};\n\n  if (typeof emoji == 'string') {\n    var matches = emoji.match(COLONS_REGEX);\n\n    if (matches) {\n      emoji = matches[1];\n\n      if (matches[2]) {\n        skin = parseInt(matches[2], 10);\n      }\n    }\n\n    if (data.aliases.hasOwnProperty(emoji)) {\n      emoji = data.aliases[emoji];\n    }\n\n    if (data.emojis.hasOwnProperty(emoji)) {\n      emojiData = data.emojis[emoji];\n    } else {\n      return null;\n    }\n  } else if (emoji.id) {\n    if (data.aliases.hasOwnProperty(emoji.id)) {\n      emoji.id = data.aliases[emoji.id];\n    }\n\n    if (data.emojis.hasOwnProperty(emoji.id)) {\n      emojiData = data.emojis[emoji.id];\n      skin || (skin = emoji.skin);\n    }\n  }\n\n  if (!Object.keys(emojiData).length) {\n    emojiData = emoji;\n    emojiData.custom = true;\n\n    if (!emojiData.search) {\n      emojiData.search = buildSearch(emoji);\n    }\n  }\n\n  emojiData.emoticons || (emojiData.emoticons = []);\n  emojiData.variations || (emojiData.variations = []);\n\n  if (emojiData.skin_variations && skin > 1) {\n    emojiData = JSON.parse(JSON.stringify(emojiData));\n    var skinKey = SKINS[skin - 1],\n        variationData = emojiData.skin_variations[skinKey];\n\n    if (variationData) {\n      if (!variationData.variations && emojiData.variations) {\n        delete emojiData.variations;\n      }\n\n      if (set && (variationData[\"has_img_\".concat(set)] == undefined || variationData[\"has_img_\".concat(set)]) || !set) {\n        emojiData.skin_tone = skin;\n\n        for (var k in variationData) {\n          var v = variationData[k];\n          emojiData[k] = v;\n        }\n      }\n    }\n  }\n\n  if (emojiData.variations && emojiData.variations.length) {\n    emojiData = JSON.parse(JSON.stringify(emojiData));\n    emojiData.unified = emojiData.variations.shift();\n  }\n\n  return emojiData;\n}\n\nfunction getEmojiDataFromNative(nativeString, set, data) {\n  if (data.compressed) {\n    uncompress(data);\n  }\n\n  var skinTones = ['', '', '', '', ''];\n  var skinCodes = ['1F3FB', '1F3FC', '1F3FD', '1F3FE', '1F3FF'];\n  var skin;\n  var skinCode;\n  var baseNativeString = nativeString;\n  skinTones.forEach(function (skinTone, skinToneIndex) {\n    if (nativeString.indexOf(skinTone) > 0) {\n      skin = skinToneIndex + 2;\n      skinCode = skinCodes[skinToneIndex];\n    }\n  });\n  var emojiData;\n\n  for (var id in data.emojis) {\n    var emoji = data.emojis[id];\n    var emojiUnified = emoji.unified;\n\n    if (emoji.variations && emoji.variations.length) {\n      emojiUnified = emoji.variations.shift();\n    }\n\n    if (skin && emoji.skin_variations && emoji.skin_variations[skinCode]) {\n      emojiUnified = emoji.skin_variations[skinCode].unified;\n    }\n\n    if (unifiedToNative(emojiUnified) === baseNativeString) emojiData = emoji;\n  }\n\n  if (!emojiData) {\n    return null;\n  }\n\n  emojiData.id = emojiData.short_names[0];\n  return getSanitizedData(emojiData, skin, set, data);\n}\n\nfunction uniq(arr) {\n  return arr.reduce(function (acc, item) {\n    if (acc.indexOf(item) === -1) {\n      acc.push(item);\n    }\n\n    return acc;\n  }, []);\n}\n\nfunction intersect(a, b) {\n  var uniqA = uniq(a);\n  var uniqB = uniq(b);\n  return uniqA.filter(function (item) {\n    return uniqB.indexOf(item) >= 0;\n  });\n}\n\nfunction deepMerge(a, b) {\n  var o = {};\n\n  for (var key in a) {\n    var originalValue = a[key],\n        value = originalValue;\n\n    if (b.hasOwnProperty(key)) {\n      value = b[key];\n    }\n\n    if (_typeof(value) === 'object') {\n      value = deepMerge(originalValue, value);\n    }\n\n    o[key] = value;\n  }\n\n  return o;\n} // https://github.com/sonicdoe/measure-scrollbar\n\n\nfunction measureScrollbar() {\n  if (typeof document == 'undefined') return 0;\n  var div = document.createElement('div');\n  div.style.width = '100px';\n  div.style.height = '100px';\n  div.style.overflow = 'scroll';\n  div.style.position = 'absolute';\n  div.style.top = '-9999px';\n  document.body.appendChild(div);\n  var scrollbarWidth = div.offsetWidth - div.clientWidth;\n  document.body.removeChild(div);\n  return scrollbarWidth;\n} // Use requestIdleCallback() if available, else fall back to setTimeout().\n// Throttle so as not to run too frequently.\n\n\nfunction throttleIdleTask(func) {\n  var doIdleTask = typeof requestIdleCallback === 'function' ? requestIdleCallback : setTimeout;\n  var running = false;\n  return function throttled() {\n    if (running) {\n      return;\n    }\n\n    running = true;\n    doIdleTask(function () {\n      running = false;\n      func();\n    });\n  };\n}\n\nexport { getData, getEmojiDataFromNative, getSanitizedData, uniq, intersect, deepMerge, unifiedToNative, measureScrollbar, throttleIdleTask };","var NAMESPACE = 'emoji-mart';\nvar isLocalStorageSupported = typeof window !== 'undefined' && 'localStorage' in window;\nvar getter;\nvar setter;\n\nfunction setHandlers(handlers) {\n  handlers || (handlers = {});\n  getter = handlers.getter;\n  setter = handlers.setter;\n}\n\nfunction setNamespace(namespace) {\n  NAMESPACE = namespace;\n}\n\nfunction update(state) {\n  for (var key in state) {\n    var value = state[key];\n    set(key, value);\n  }\n}\n\nfunction set(key, value) {\n  if (setter) {\n    setter(key, value);\n  } else {\n    if (!isLocalStorageSupported) return;\n\n    try {\n      window.localStorage[\"\".concat(NAMESPACE, \".\").concat(key)] = JSON.stringify(value);\n    } catch (e) {}\n  }\n}\n\nfunction get(key) {\n  if (getter) {\n    return getter(key);\n  } else {\n    if (!isLocalStorageSupported) return;\n\n    try {\n      var value = window.localStorage[\"\".concat(NAMESPACE, \".\").concat(key)];\n\n      if (value) {\n        return JSON.parse(value);\n      }\n    } catch (e) {\n      return;\n    }\n  }\n}\n\nexport default {\n  update: update,\n  set: set,\n  get: get,\n  setNamespace: setNamespace,\n  setHandlers: setHandlers\n};","import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport { getData, getSanitizedData, intersect } from '..';\nimport { uncompress } from '../data';\nimport store from '../store';\n\nvar NimbleEmojiIndex =\n/*#__PURE__*/\nfunction () {\n  function NimbleEmojiIndex(data, set) {\n    _classCallCheck(this, NimbleEmojiIndex);\n\n    if (data.compressed) {\n      uncompress(data);\n    }\n\n    this.data = data || {};\n    this.set = set || null;\n    this.originalPool = {};\n    this.index = {};\n    this.emojis = {};\n    this.emoticons = {};\n    this.customEmojisList = [];\n    this.buildIndex();\n  }\n\n  _createClass(NimbleEmojiIndex, [{\n    key: \"buildIndex\",\n    value: function buildIndex() {\n      var _this = this;\n\n      var _loop = function _loop(emoji) {\n        var emojiData = _this.data.emojis[emoji],\n            short_names = emojiData.short_names,\n            emoticons = emojiData.emoticons,\n            skin_variations = emojiData.skin_variations,\n            id = short_names[0];\n\n        if (emoticons) {\n          emoticons.forEach(function (emoticon) {\n            if (_this.emoticons[emoticon]) {\n              return;\n            }\n\n            _this.emoticons[emoticon] = id;\n          });\n        } // If skin variations include them\n\n\n        if (skin_variations) {\n          _this.emojis[id] = {};\n\n          for (var skinTone = 1; skinTone <= 6; skinTone++) {\n            _this.emojis[id][skinTone] = getSanitizedData({\n              id: id,\n              skin: skinTone\n            }, skinTone, _this.set, _this.data);\n          }\n        } else {\n          _this.emojis[id] = getSanitizedData(id, null, _this.set, _this.data);\n        }\n\n        _this.originalPool[id] = emojiData;\n      };\n\n      for (var emoji in this.data.emojis) {\n        _loop(emoji);\n      }\n    }\n  }, {\n    key: \"clearCustomEmojis\",\n    value: function clearCustomEmojis(pool) {\n      var _this2 = this;\n\n      this.customEmojisList.forEach(function (emoji) {\n        var emojiId = emoji.id || emoji.short_names[0];\n        delete pool[emojiId];\n        delete _this2.emojis[emojiId];\n      });\n    }\n  }, {\n    key: \"addCustomToPool\",\n    value: function addCustomToPool(custom, pool) {\n      var _this3 = this;\n\n      if (this.customEmojisList.length) this.clearCustomEmojis(pool);\n      custom.forEach(function (emoji) {\n        var emojiId = emoji.id || emoji.short_names[0];\n\n        if (emojiId && !pool[emojiId]) {\n          pool[emojiId] = getData(emoji, null, null, _this3.data);\n          _this3.emojis[emojiId] = getSanitizedData(emoji, null, null, _this3.data);\n        }\n      });\n      this.customEmojisList = custom;\n      this.index = {};\n    }\n  }, {\n    key: \"search\",\n    value: function search(value) {\n      var _this4 = this;\n\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          emojisToShowFilter = _ref.emojisToShowFilter,\n          maxResults = _ref.maxResults,\n          include = _ref.include,\n          exclude = _ref.exclude,\n          _ref$custom = _ref.custom,\n          custom = _ref$custom === void 0 ? [] : _ref$custom;\n\n      if (this.customEmojisList != custom) this.addCustomToPool(custom, this.originalPool);\n      var skinTone = store.get('skin') || 1;\n      maxResults || (maxResults = 75);\n      include || (include = []);\n      exclude || (exclude = []);\n      var results = null,\n          pool = this.originalPool;\n\n      if (value.length) {\n        if (value == '-' || value == '-1') {\n          return [this.emojis['-1'][skinTone]];\n        }\n\n        var values = value.toLowerCase().split(/[\\s|,|\\-|_]+/),\n            allResults = [];\n\n        if (values.length > 2) {\n          values = [values[0], values[1]];\n        }\n\n        if (include.length || exclude.length) {\n          pool = {};\n          this.data.categories.forEach(function (category) {\n            var isIncluded = include && include.length ? include.indexOf(category.id) > -1 : true;\n            var isExcluded = exclude && exclude.length ? exclude.indexOf(category.id) > -1 : false;\n\n            if (!isIncluded || isExcluded) {\n              return;\n            }\n\n            category.emojis.forEach(function (emojiId) {\n              return pool[emojiId] = _this4.data.emojis[emojiId];\n            });\n          });\n\n          if (custom.length) {\n            var customIsIncluded = include && include.length ? include.indexOf('custom') > -1 : true;\n            var customIsExcluded = exclude && exclude.length ? exclude.indexOf('custom') > -1 : false;\n\n            if (customIsIncluded && !customIsExcluded) {\n              this.addCustomToPool(custom, pool);\n            }\n          }\n        }\n\n        allResults = values.map(function (value) {\n          var aPool = pool,\n              aIndex = _this4.index,\n              length = 0;\n\n          for (var charIndex = 0; charIndex < value.length; charIndex++) {\n            var _char = value[charIndex];\n            length++;\n            aIndex[_char] || (aIndex[_char] = {});\n            aIndex = aIndex[_char];\n\n            if (!aIndex.results) {\n              (function () {\n                var scores = {};\n                aIndex.results = [];\n                aIndex.pool = {};\n\n                for (var id in aPool) {\n                  var emoji = aPool[id],\n                      search = emoji.search,\n                      sub = value.substr(0, length),\n                      subIndex = search.indexOf(sub);\n\n                  if (subIndex != -1) {\n                    var score = subIndex + 1;\n                    if (sub == id) score = 0;\n\n                    if (_this4.emojis[id] && _this4.emojis[id][skinTone]) {\n                      aIndex.results.push(_this4.emojis[id][skinTone]);\n                    } else {\n                      aIndex.results.push(_this4.emojis[id]);\n                    }\n\n                    aIndex.pool[id] = emoji;\n                    scores[id] = score;\n                  }\n                }\n\n                aIndex.results.sort(function (a, b) {\n                  var aScore = scores[a.id],\n                      bScore = scores[b.id];\n\n                  if (aScore == bScore) {\n                    return a.id.localeCompare(b.id);\n                  } else {\n                    return aScore - bScore;\n                  }\n                });\n              })();\n            }\n\n            aPool = aIndex.pool;\n          }\n\n          return aIndex.results;\n        }).filter(function (a) {\n          return a;\n        });\n\n        if (allResults.length > 1) {\n          results = intersect.apply(null, allResults);\n        } else if (allResults.length) {\n          results = allResults[0];\n        } else {\n          results = [];\n        }\n      }\n\n      if (results) {\n        if (emojisToShowFilter) {\n          results = results.filter(function (result) {\n            return emojisToShowFilter(pool[result.id]);\n          });\n        }\n\n        if (results && results.length > maxResults) {\n          results = results.slice(0, maxResults);\n        }\n      }\n\n      return results;\n    }\n  }]);\n\n  return NimbleEmojiIndex;\n}();\n\nexport { NimbleEmojiIndex as default };","import data from '../../../data/all.json';\nimport NimbleEmojiIndex from './nimble-emoji-index';\nvar emojiIndex = new NimbleEmojiIndex(data);\nvar emojis = emojiIndex.emojis,\n    emoticons = emojiIndex.emoticons;\n\nfunction search() {\n  return emojiIndex.search.apply(emojiIndex, arguments);\n}\n\nexport default {\n  search: search,\n  emojis: emojis,\n  emoticons: emoticons\n};","import store from './store';\nvar DEFAULTS = ['+1', 'grinning', 'kissing_heart', 'heart_eyes', 'laughing', 'stuck_out_tongue_winking_eye', 'sweat_smile', 'joy', 'scream', 'disappointed', 'unamused', 'weary', 'sob', 'sunglasses', 'heart', 'poop'];\nvar frequently, initialized;\nvar defaults = {};\n\nfunction init() {\n  initialized = true;\n  frequently = store.get('frequently');\n}\n\nfunction add(emoji) {\n  if (!initialized) init();\n  var id = emoji.id;\n  frequently || (frequently = defaults);\n  frequently[id] || (frequently[id] = 0);\n  frequently[id] += 1;\n  store.set('last', id);\n  store.set('frequently', frequently);\n}\n\nfunction get(perLine) {\n  if (!initialized) init();\n\n  if (!frequently) {\n    defaults = {};\n    var result = [];\n\n    for (var i = 0; i < perLine; i++) {\n      defaults[DEFAULTS[i]] = perLine - i;\n      result.push(DEFAULTS[i]);\n    }\n\n    return result;\n  }\n\n  var quantity = perLine * 4;\n  var frequentlyKeys = [];\n\n  for (var key in frequently) {\n    if (frequently.hasOwnProperty(key)) {\n      frequentlyKeys.push(key);\n    }\n  }\n\n  var sorted = frequentlyKeys.sort(function (a, b) {\n    return frequently[a] - frequently[b];\n  }).reverse();\n  var sliced = sorted.slice(0, quantity);\n  var last = store.get('last');\n\n  if (last && sliced.indexOf(last) == -1) {\n    sliced.pop();\n    sliced.push(last);\n  }\n\n  return sliced;\n}\n\nexport default {\n  add: add,\n  get: get\n};","import React from 'react';\nvar categories = {\n  activity: function activity() {\n    return React.createElement(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      viewBox: \"0 0 24 24\",\n      width: \"24\",\n      height: \"24\"\n    }, React.createElement(\"path\", {\n      d: \"M12 0C5.373 0 0 5.372 0 12c0 6.627 5.373 12 12 12 6.628 0 12-5.373 12-12 0-6.628-5.372-12-12-12m9.949 11H17.05c.224-2.527 1.232-4.773 1.968-6.113A9.966 9.966 0 0 1 21.949 11M13 11V2.051a9.945 9.945 0 0 1 4.432 1.564c-.858 1.491-2.156 4.22-2.392 7.385H13zm-2 0H8.961c-.238-3.165-1.536-5.894-2.393-7.385A9.95 9.95 0 0 1 11 2.051V11zm0 2v8.949a9.937 9.937 0 0 1-4.432-1.564c.857-1.492 2.155-4.221 2.393-7.385H11zm4.04 0c.236 3.164 1.534 5.893 2.392 7.385A9.92 9.92 0 0 1 13 21.949V13h2.04zM4.982 4.887C5.718 6.227 6.726 8.473 6.951 11h-4.9a9.977 9.977 0 0 1 2.931-6.113M2.051 13h4.9c-.226 2.527-1.233 4.771-1.969 6.113A9.972 9.972 0 0 1 2.051 13m16.967 6.113c-.735-1.342-1.744-3.586-1.968-6.113h4.899a9.961 9.961 0 0 1-2.931 6.113\"\n    }));\n  },\n  custom: function custom() {\n    return React.createElement(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      viewBox: \"0 0 24 24\",\n      width: \"24\",\n      height: \"24\"\n    }, React.createElement(\"g\", {\n      transform: \"translate(2.000000, 1.000000)\"\n    }, React.createElement(\"rect\", {\n      id: \"Rectangle\",\n      x: \"8\",\n      y: \"0\",\n      width: \"3\",\n      height: \"21\",\n      rx: \"1.5\"\n    }), React.createElement(\"rect\", {\n      id: \"Rectangle\",\n      transform: \"translate(9.843, 10.549) rotate(60) translate(-9.843, -10.549) \",\n      x: \"8.343\",\n      y: \"0.049\",\n      width: \"3\",\n      height: \"21\",\n      rx: \"1.5\"\n    }), React.createElement(\"rect\", {\n      id: \"Rectangle\",\n      transform: \"translate(9.843, 10.549) rotate(-60) translate(-9.843, -10.549) \",\n      x: \"8.343\",\n      y: \"0.049\",\n      width: \"3\",\n      height: \"21\",\n      rx: \"1.5\"\n    })));\n  },\n  flags: function flags() {\n    return React.createElement(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      viewBox: \"0 0 24 24\",\n      width: \"24\",\n      height: \"24\"\n    }, React.createElement(\"path\", {\n      d: \"M0 0l6.084 24H8L1.916 0zM21 5h-4l-1-4H4l3 12h3l1 4h13L21 5zM6.563 3h7.875l2 8H8.563l-2-8zm8.832 10l-2.856 1.904L12.063 13h3.332zM19 13l-1.5-6h1.938l2 8H16l3-2z\"\n    }));\n  },\n  foods: function foods() {\n    return React.createElement(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      viewBox: \"0 0 24 24\",\n      width: \"24\",\n      height: \"24\"\n    }, React.createElement(\"path\", {\n      d: \"M17 4.978c-1.838 0-2.876.396-3.68.934.513-1.172 1.768-2.934 4.68-2.934a1 1 0 0 0 0-2c-2.921 0-4.629 1.365-5.547 2.512-.064.078-.119.162-.18.244C11.73 1.838 10.798.023 9.207.023 8.579.022 7.85.306 7 .978 5.027 2.54 5.329 3.902 6.492 4.999 3.609 5.222 0 7.352 0 12.969c0 4.582 4.961 11.009 9 11.009 1.975 0 2.371-.486 3-1 .629.514 1.025 1 3 1 4.039 0 9-6.418 9-11 0-5.953-4.055-8-7-8M8.242 2.546c.641-.508.943-.523.965-.523.426.169.975 1.405 1.357 3.055-1.527-.629-2.741-1.352-2.98-1.846.059-.112.241-.356.658-.686M15 21.978c-1.08 0-1.21-.109-1.559-.402l-.176-.146c-.367-.302-.816-.452-1.266-.452s-.898.15-1.266.452l-.176.146c-.347.292-.477.402-1.557.402-2.813 0-7-5.389-7-9.009 0-5.823 4.488-5.991 5-5.991 1.939 0 2.484.471 3.387 1.251l.323.276a1.995 1.995 0 0 0 2.58 0l.323-.276c.902-.78 1.447-1.251 3.387-1.251.512 0 5 .168 5 6 0 3.617-4.187 9-7 9\"\n    }));\n  },\n  nature: function nature() {\n    return React.createElement(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      viewBox: \"0 0 24 24\",\n      width: \"24\",\n      height: \"24\"\n    }, React.createElement(\"path\", {\n      d: \"M15.5 8a1.5 1.5 0 1 0 .001 3.001A1.5 1.5 0 0 0 15.5 8M8.5 8a1.5 1.5 0 1 0 .001 3.001A1.5 1.5 0 0 0 8.5 8\"\n    }), React.createElement(\"path\", {\n      d: \"M18.933 0h-.027c-.97 0-2.138.787-3.018 1.497-1.274-.374-2.612-.51-3.887-.51-1.285 0-2.616.133-3.874.517C7.245.79 6.069 0 5.093 0h-.027C3.352 0 .07 2.67.002 7.026c-.039 2.479.276 4.238 1.04 5.013.254.258.882.677 1.295.882.191 3.177.922 5.238 2.536 6.38.897.637 2.187.949 3.2 1.102C8.04 20.6 8 20.795 8 21c0 1.773 2.35 3 4 3 1.648 0 4-1.227 4-3 0-.201-.038-.393-.072-.586 2.573-.385 5.435-1.877 5.925-7.587.396-.22.887-.568 1.104-.788.763-.774 1.079-2.534 1.04-5.013C23.929 2.67 20.646 0 18.933 0M3.223 9.135c-.237.281-.837 1.155-.884 1.238-.15-.41-.368-1.349-.337-3.291.051-3.281 2.478-4.972 3.091-5.031.256.015.731.27 1.265.646-1.11 1.171-2.275 2.915-2.352 5.125-.133.546-.398.858-.783 1.313M12 22c-.901 0-1.954-.693-2-1 0-.654.475-1.236 1-1.602V20a1 1 0 1 0 2 0v-.602c.524.365 1 .947 1 1.602-.046.307-1.099 1-2 1m3-3.48v.02a4.752 4.752 0 0 0-1.262-1.02c1.092-.516 2.239-1.334 2.239-2.217 0-1.842-1.781-2.195-3.977-2.195-2.196 0-3.978.354-3.978 2.195 0 .883 1.148 1.701 2.238 2.217A4.8 4.8 0 0 0 9 18.539v-.025c-1-.076-2.182-.281-2.973-.842-1.301-.92-1.838-3.045-1.853-6.478l.023-.041c.496-.826 1.49-1.45 1.804-3.102 0-2.047 1.357-3.631 2.362-4.522C9.37 3.178 10.555 3 11.948 3c1.447 0 2.685.192 3.733.57 1 .9 2.316 2.465 2.316 4.48.313 1.651 1.307 2.275 1.803 3.102.035.058.068.117.102.178-.059 5.967-1.949 7.01-4.902 7.19m6.628-8.202c-.037-.065-.074-.13-.113-.195a7.587 7.587 0 0 0-.739-.987c-.385-.455-.648-.768-.782-1.313-.076-2.209-1.241-3.954-2.353-5.124.531-.376 1.004-.63 1.261-.647.636.071 3.044 1.764 3.096 5.031.027 1.81-.347 3.218-.37 3.235\"\n    }));\n  },\n  objects: function objects() {\n    return React.createElement(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      viewBox: \"0 0 24 24\",\n      width: \"24\",\n      height: \"24\"\n    }, React.createElement(\"path\", {\n      d: \"M12 0a9 9 0 0 0-5 16.482V21s2.035 3 5 3 5-3 5-3v-4.518A9 9 0 0 0 12 0zm0 2c3.86 0 7 3.141 7 7s-3.14 7-7 7-7-3.141-7-7 3.14-7 7-7zM9 17.477c.94.332 1.946.523 3 .523s2.06-.19 3-.523v.834c-.91.436-1.925.689-3 .689a6.924 6.924 0 0 1-3-.69v-.833zm.236 3.07A8.854 8.854 0 0 0 12 21c.965 0 1.888-.167 2.758-.451C14.155 21.173 13.153 22 12 22c-1.102 0-2.117-.789-2.764-1.453z\"\n    }), React.createElement(\"path\", {\n      d: \"M14.745 12.449h-.004c-.852-.024-1.188-.858-1.577-1.824-.421-1.061-.703-1.561-1.182-1.566h-.009c-.481 0-.783.497-1.235 1.537-.436.982-.801 1.811-1.636 1.791l-.276-.043c-.565-.171-.853-.691-1.284-1.794-.125-.313-.202-.632-.27-.913-.051-.213-.127-.53-.195-.634C7.067 9.004 7.039 9 6.99 9A1 1 0 0 1 7 7h.01c1.662.017 2.015 1.373 2.198 2.134.486-.981 1.304-2.058 2.797-2.075 1.531.018 2.28 1.153 2.731 2.141l.002-.008C14.944 8.424 15.327 7 16.979 7h.032A1 1 0 1 1 17 9h-.011c-.149.076-.256.474-.319.709a6.484 6.484 0 0 1-.311.951c-.429.973-.79 1.789-1.614 1.789\"\n    }));\n  },\n  people: function people() {\n    return React.createElement(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      viewBox: \"0 0 24 24\",\n      width: \"24\",\n      height: \"24\"\n    }, React.createElement(\"path\", {\n      d: \"M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0m0 22C6.486 22 2 17.514 2 12S6.486 2 12 2s10 4.486 10 10-4.486 10-10 10\"\n    }), React.createElement(\"path\", {\n      d: \"M8 7a2 2 0 1 0-.001 3.999A2 2 0 0 0 8 7M16 7a2 2 0 1 0-.001 3.999A2 2 0 0 0 16 7M15.232 15c-.693 1.195-1.87 2-3.349 2-1.477 0-2.655-.805-3.347-2H15m3-2H6a6 6 0 1 0 12 0\"\n    }));\n  },\n  places: function places() {\n    return React.createElement(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      viewBox: \"0 0 24 24\",\n      width: \"24\",\n      height: \"24\"\n    }, React.createElement(\"path\", {\n      d: \"M6.5 12C5.122 12 4 13.121 4 14.5S5.122 17 6.5 17 9 15.879 9 14.5 7.878 12 6.5 12m0 3c-.275 0-.5-.225-.5-.5s.225-.5.5-.5.5.225.5.5-.225.5-.5.5M17.5 12c-1.378 0-2.5 1.121-2.5 2.5s1.122 2.5 2.5 2.5 2.5-1.121 2.5-2.5-1.122-2.5-2.5-2.5m0 3c-.275 0-.5-.225-.5-.5s.225-.5.5-.5.5.225.5.5-.225.5-.5.5\"\n    }), React.createElement(\"path\", {\n      d: \"M22.482 9.494l-1.039-.346L21.4 9h.6c.552 0 1-.439 1-.992 0-.006-.003-.008-.003-.008H23c0-1-.889-2-1.984-2h-.642l-.731-1.717C19.262 3.012 18.091 2 16.764 2H7.236C5.909 2 4.738 3.012 4.357 4.283L3.626 6h-.642C1.889 6 1 7 1 8h.003S1 8.002 1 8.008C1 8.561 1.448 9 2 9h.6l-.043.148-1.039.346a2.001 2.001 0 0 0-1.359 2.097l.751 7.508a1 1 0 0 0 .994.901H3v1c0 1.103.896 2 2 2h2c1.104 0 2-.897 2-2v-1h6v1c0 1.103.896 2 2 2h2c1.104 0 2-.897 2-2v-1h1.096a.999.999 0 0 0 .994-.901l.751-7.508a2.001 2.001 0 0 0-1.359-2.097M6.273 4.857C6.402 4.43 6.788 4 7.236 4h9.527c.448 0 .834.43.963.857L19.313 9H4.688l1.585-4.143zM7 21H5v-1h2v1zm12 0h-2v-1h2v1zm2.189-3H2.811l-.662-6.607L3 11h18l.852.393L21.189 18z\"\n    }));\n  },\n  recent: function recent() {\n    return React.createElement(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      viewBox: \"0 0 24 24\",\n      width: \"24\",\n      height: \"24\"\n    }, React.createElement(\"path\", {\n      d: \"M13 4h-2l-.001 7H9v2h2v2h2v-2h4v-2h-4z\"\n    }), React.createElement(\"path\", {\n      d: \"M12 0C5.373 0 0 5.373 0 12s5.373 12 12 12 12-5.373 12-12S18.627 0 12 0m0 22C6.486 22 2 17.514 2 12S6.486 2 12 2s10 4.486 10 10-4.486 10-10 10\"\n    }));\n  },\n  symbols: function symbols() {\n    return React.createElement(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      viewBox: \"0 0 24 24\",\n      width: \"24\",\n      height: \"24\"\n    }, React.createElement(\"path\", {\n      d: \"M0 0h11v2H0zM4 11h3V6h4V4H0v2h4zM15.5 17c1.381 0 2.5-1.116 2.5-2.493s-1.119-2.493-2.5-2.493S13 13.13 13 14.507 14.119 17 15.5 17m0-2.986c.276 0 .5.222.5.493 0 .272-.224.493-.5.493s-.5-.221-.5-.493.224-.493.5-.493M21.5 19.014c-1.381 0-2.5 1.116-2.5 2.493S20.119 24 21.5 24s2.5-1.116 2.5-2.493-1.119-2.493-2.5-2.493m0 2.986a.497.497 0 0 1-.5-.493c0-.271.224-.493.5-.493s.5.222.5.493a.497.497 0 0 1-.5.493M22 13l-9 9 1.513 1.5 8.99-9.009zM17 11c2.209 0 4-1.119 4-2.5V2s.985-.161 1.498.949C23.01 4.055 23 6 23 6s1-1.119 1-3.135C24-.02 21 0 21 0h-2v6.347A5.853 5.853 0 0 0 17 6c-2.209 0-4 1.119-4 2.5s1.791 2.5 4 2.5M10.297 20.482l-1.475-1.585a47.54 47.54 0 0 1-1.442 1.129c-.307-.288-.989-1.016-2.045-2.183.902-.836 1.479-1.466 1.729-1.892s.376-.871.376-1.336c0-.592-.273-1.178-.818-1.759-.546-.581-1.329-.871-2.349-.871-1.008 0-1.79.293-2.344.879-.556.587-.832 1.181-.832 1.784 0 .813.419 1.748 1.256 2.805-.847.614-1.444 1.208-1.794 1.784a3.465 3.465 0 0 0-.523 1.833c0 .857.308 1.56.924 2.107.616.549 1.423.823 2.42.823 1.173 0 2.444-.379 3.813-1.137L8.235 24h2.819l-2.09-2.383 1.333-1.135zm-6.736-6.389a1.02 1.02 0 0 1 .73-.286c.31 0 .559.085.747.254a.849.849 0 0 1 .283.659c0 .518-.419 1.112-1.257 1.784-.536-.651-.805-1.231-.805-1.742a.901.901 0 0 1 .302-.669M3.74 22c-.427 0-.778-.116-1.057-.349-.279-.232-.418-.487-.418-.766 0-.594.509-1.288 1.527-2.083.968 1.134 1.717 1.946 2.248 2.438-.921.507-1.686.76-2.3.76\"\n    }));\n  }\n};\nvar search = {\n  search: function search() {\n    return React.createElement(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: \"13\",\n      height: \"13\",\n      viewBox: \"0 0 20 20\",\n      opacity: \"0.5\"\n    }, React.createElement(\"path\", {\n      d: \"M12.9 14.32a8 8 0 1 1 1.41-1.41l5.35 5.33-1.42 1.42-5.33-5.34zM8 14A6 6 0 1 0 8 2a6 6 0 0 0 0 12z\"\n    }));\n  },\n  \"delete\": function _delete() {\n    return React.createElement(\"svg\", {\n      xmlns: \"http://www.w3.org/2000/svg\",\n      width: \"13\",\n      height: \"13\",\n      viewBox: \"0 0 20 20\",\n      opacity: \"0.5\"\n    }, React.createElement(\"path\", {\n      d: \"M10 8.586L2.929 1.515 1.515 2.929 8.586 10l-7.071 7.071 1.414 1.414L10 11.414l7.071 7.071 1.414-1.414L11.414 10l7.071-7.071-1.414-1.414L10 8.586z\"\n    }));\n  }\n};\nexport { categories, search };","import PropTypes from 'prop-types';\nvar EmojiPropTypes = {\n  data: PropTypes.object.isRequired,\n  onOver: PropTypes.func,\n  onLeave: PropTypes.func,\n  onClick: PropTypes.func,\n  fallback: PropTypes.func,\n  backgroundImageFn: PropTypes.func,\n  \"native\": PropTypes.bool,\n  forceSize: PropTypes.bool,\n  tooltip: PropTypes.bool,\n  useButton: PropTypes.bool,\n  skin: PropTypes.oneOf([1, 2, 3, 4, 5, 6]),\n  sheetSize: PropTypes.oneOf([16, 20, 32, 64]),\n  sheetColumns: PropTypes.number,\n  sheetRows: PropTypes.number,\n  set: PropTypes.oneOf(['apple', 'google', 'twitter', 'facebook']),\n  size: PropTypes.number.isRequired,\n  emoji: PropTypes.oneOfType([PropTypes.string, PropTypes.object]).isRequired\n};\nvar PickerPropTypes = {\n  onClick: PropTypes.func,\n  onSelect: PropTypes.func,\n  onSkinChange: PropTypes.func,\n  perLine: PropTypes.number,\n  emojiSize: PropTypes.number,\n  i18n: PropTypes.object,\n  style: PropTypes.object,\n  title: PropTypes.string,\n  emoji: PropTypes.string,\n  color: PropTypes.string,\n  set: EmojiPropTypes.set,\n  skin: EmojiPropTypes.skin,\n  \"native\": PropTypes.bool,\n  backgroundImageFn: EmojiPropTypes.backgroundImageFn,\n  sheetSize: EmojiPropTypes.sheetSize,\n  emojisToShowFilter: PropTypes.func,\n  showPreview: PropTypes.bool,\n  showSkinTones: PropTypes.bool,\n  emojiTooltip: EmojiPropTypes.tooltip,\n  useButton: EmojiPropTypes.useButton,\n  theme: PropTypes.oneOf(['auto', 'light', 'dark']),\n  include: PropTypes.arrayOf(PropTypes.string),\n  exclude: PropTypes.arrayOf(PropTypes.string),\n  recent: PropTypes.arrayOf(PropTypes.string),\n  autoFocus: PropTypes.bool,\n  enableFrequentEmojiSort: PropTypes.bool,\n  custom: PropTypes.arrayOf(PropTypes.shape({\n    name: PropTypes.string.isRequired,\n    short_names: PropTypes.arrayOf(PropTypes.string).isRequired,\n    emoticons: PropTypes.arrayOf(PropTypes.string),\n    keywords: PropTypes.arrayOf(PropTypes.string),\n    imageUrl: PropTypes.string,\n    spriteUrl: PropTypes.string,\n    sheet_x: PropTypes.number,\n    sheet_y: PropTypes.number,\n    size: PropTypes.number,\n    sheetColumns: PropTypes.number,\n    sheetRows: PropTypes.number\n  })),\n  skinEmoji: PropTypes.string,\n  notFound: PropTypes.func,\n  notFoundEmoji: PropTypes.string,\n  icons: PropTypes.object\n};\nexport { EmojiPropTypes, PickerPropTypes };","import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nvar Anchors =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(Anchors, _React$PureComponent);\n\n  function Anchors(props) {\n    var _this;\n\n    _classCallCheck(this, Anchors);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Anchors).call(this, props));\n    var defaultCategory = props.categories.filter(function (category) {\n      return category.first;\n    })[0];\n    _this.state = {\n      selected: defaultCategory.name\n    };\n    _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(Anchors, [{\n    key: \"handleClick\",\n    value: function handleClick(e) {\n      var index = e.currentTarget.getAttribute('data-index');\n      var _this$props = this.props,\n          categories = _this$props.categories,\n          onAnchorClick = _this$props.onAnchorClick;\n      onAnchorClick(categories[index], index);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$props2 = this.props,\n          categories = _this$props2.categories,\n          color = _this$props2.color,\n          i18n = _this$props2.i18n,\n          icons = _this$props2.icons,\n          selected = this.state.selected;\n      return React.createElement(\"nav\", {\n        className: \"emoji-mart-anchors\",\n        \"aria-label\": i18n.categorieslabel\n      }, categories.map(function (category, i) {\n        var id = category.id,\n            name = category.name,\n            anchor = category.anchor,\n            isSelected = name == selected;\n\n        if (anchor === false) {\n          return null;\n        }\n\n        var iconId = id.startsWith('custom-') ? 'custom' : id;\n        return React.createElement(\"button\", {\n          key: id,\n          \"aria-label\": i18n.categories[iconId],\n          title: i18n.categories[iconId],\n          \"data-index\": i,\n          type: 'button',\n          onClick: _this2.handleClick,\n          className: \"emoji-mart-anchor \".concat(isSelected ? 'emoji-mart-anchor-selected' : ''),\n          style: {\n            color: isSelected ? color : null\n          }\n        }, React.createElement(\"div\", {\n          className: \"emoji-mart-anchor-icon\"\n        }, icons.categories[iconId]()), React.createElement(\"span\", {\n          className: \"emoji-mart-anchor-bar\",\n          style: {\n            backgroundColor: color\n          }\n        }));\n      }));\n    }\n  }]);\n\n  return Anchors;\n}(React.PureComponent);\n\nexport { Anchors as default };\nAnchors.propTypes\n/* remove-proptypes */\n= {\n  categories: PropTypes.array,\n  onAnchorClick: PropTypes.func,\n  icons: PropTypes.object\n};\nAnchors.defaultProps = {\n  categories: [],\n  onAnchorClick: function onAnchorClick() {},\n  icons: {}\n};","var EmojiDefaultProps = {\n  skin: 1,\n  set: 'apple',\n  sheetSize: 64,\n  sheetColumns: 57,\n  sheetRows: 57,\n  \"native\": false,\n  forceSize: false,\n  tooltip: false,\n  useButton: true,\n  backgroundImageFn: function backgroundImageFn(set, sheetSize) {\n    return \"https://unpkg.com/emoji-datasource-\".concat(set, \"@\").concat(\"5.0.1\", \"/img/\").concat(set, \"/sheets-256/\").concat(sheetSize, \".png\");\n  }\n};\nvar PickerDefaultProps = {\n  onClick: function onClick() {},\n  onSelect: function onSelect() {},\n  onSkinChange: function onSkinChange() {},\n  emojiSize: 24,\n  perLine: 9,\n  i18n: {},\n  style: {},\n  title: 'Emoji Mart',\n  emoji: 'department_store',\n  color: '#ae65c5',\n  set: EmojiDefaultProps.set,\n  theme: 'light',\n  skin: null,\n  defaultSkin: EmojiDefaultProps.skin,\n  \"native\": EmojiDefaultProps[\"native\"],\n  sheetSize: EmojiDefaultProps.sheetSize,\n  backgroundImageFn: EmojiDefaultProps.backgroundImageFn,\n  emojisToShowFilter: null,\n  showPreview: true,\n  showSkinTones: true,\n  emojiTooltip: EmojiDefaultProps.tooltip,\n  useButton: EmojiDefaultProps.useButton,\n  autoFocus: false,\n  enableFrequentEmojiSort: false,\n  custom: [],\n  skinEmoji: '',\n  notFound: function notFound() {},\n  notFoundEmoji: 'sleuth_or_spy',\n  icons: {}\n};\nexport { PickerDefaultProps, EmojiDefaultProps };","import _extends from \"@babel/runtime/helpers/extends\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { getData, getSanitizedData, unifiedToNative } from '../../utils';\nimport { uncompress } from '../../utils/data';\nimport { EmojiPropTypes } from '../../utils/shared-props';\nimport { EmojiDefaultProps } from '../../utils/shared-default-props';\n\nvar _getData = function _getData(props) {\n  var emoji = props.emoji,\n      skin = props.skin,\n      set = props.set,\n      data = props.data;\n  return getData(emoji, skin, set, data);\n};\n\nvar _getPosition = function _getPosition(props) {\n  var _getData2 = _getData(props),\n      sheet_x = _getData2.sheet_x,\n      sheet_y = _getData2.sheet_y,\n      multiplyX = 100 / (props.sheetColumns - 1),\n      multiplyY = 100 / (props.sheetRows - 1);\n\n  return \"\".concat(multiplyX * sheet_x, \"% \").concat(multiplyY * sheet_y, \"%\");\n};\n\nvar _getSanitizedData = function _getSanitizedData(props) {\n  var emoji = props.emoji,\n      skin = props.skin,\n      set = props.set,\n      data = props.data;\n  return getSanitizedData(emoji, skin, set, data);\n};\n\nvar _handleClick = function _handleClick(e, props) {\n  if (!props.onClick) {\n    return;\n  }\n\n  var onClick = props.onClick,\n      emoji = _getSanitizedData(props);\n\n  onClick(emoji, e);\n};\n\nvar _handleOver = function _handleOver(e, props) {\n  if (!props.onOver) {\n    return;\n  }\n\n  var onOver = props.onOver,\n      emoji = _getSanitizedData(props);\n\n  onOver(emoji, e);\n};\n\nvar _handleLeave = function _handleLeave(e, props) {\n  if (!props.onLeave) {\n    return;\n  }\n\n  var onLeave = props.onLeave,\n      emoji = _getSanitizedData(props);\n\n  onLeave(emoji, e);\n};\n\nvar _isNumeric = function _isNumeric(value) {\n  return !isNaN(value - parseFloat(value));\n};\n\nvar _convertStyleToCSS = function _convertStyleToCSS(style) {\n  var div = document.createElement('div');\n\n  for (var key in style) {\n    var value = style[key];\n\n    if (_isNumeric(value)) {\n      value += 'px';\n    }\n\n    div.style[key] = value;\n  }\n\n  return div.getAttribute('style');\n};\n\nvar NimbleEmoji = function NimbleEmoji(props) {\n  if (props.data.compressed) {\n    uncompress(props.data);\n  }\n\n  for (var k in NimbleEmoji.defaultProps) {\n    if (props[k] == undefined && NimbleEmoji.defaultProps[k] != undefined) {\n      props[k] = NimbleEmoji.defaultProps[k];\n    }\n  }\n\n  var data = _getData(props);\n\n  if (!data) {\n    if (props.fallback) {\n      return props.fallback(null, props);\n    } else {\n      return null;\n    }\n  }\n\n  var unified = data.unified,\n      custom = data.custom,\n      short_names = data.short_names,\n      imageUrl = data.imageUrl,\n      style = {},\n      children = props.children,\n      className = 'emoji-mart-emoji',\n      nativeEmoji = unified && unifiedToNative(unified),\n      label = [nativeEmoji].concat(short_names).filter(Boolean).join(', '),\n      title = null;\n\n  if (!unified && !custom) {\n    if (props.fallback) {\n      return props.fallback(data, props);\n    } else {\n      return null;\n    }\n  }\n\n  if (props.tooltip) {\n    title = short_names[0];\n  }\n\n  if (props[\"native\"] && unified) {\n    className += ' emoji-mart-emoji-native';\n    style = {\n      fontSize: props.size\n    };\n    children = nativeEmoji;\n\n    if (props.forceSize) {\n      style.display = 'inline-block';\n      style.width = props.size;\n      style.height = props.size;\n      style.wordBreak = 'keep-all';\n    }\n  } else if (custom) {\n    className += ' emoji-mart-emoji-custom';\n    style = {\n      width: props.size,\n      height: props.size,\n      display: 'inline-block'\n    };\n\n    if (data.spriteUrl) {\n      style = _objectSpread({}, style, {\n        backgroundImage: \"url(\".concat(data.spriteUrl, \")\"),\n        backgroundSize: \"\".concat(100 * props.sheetColumns, \"% \").concat(100 * props.sheetRows, \"%\"),\n        backgroundPosition: _getPosition(props)\n      });\n    } else {\n      style = _objectSpread({}, style, {\n        backgroundImage: \"url(\".concat(imageUrl, \")\"),\n        backgroundSize: 'contain',\n        backgroundRepeat: 'no-repeat',\n        backgroundPosition: 'center'\n      });\n    }\n  } else {\n    var setHasEmoji = data[\"has_img_\".concat(props.set)] == undefined || data[\"has_img_\".concat(props.set)];\n\n    if (!setHasEmoji) {\n      if (props.fallback) {\n        return props.fallback(data, props);\n      } else {\n        return null;\n      }\n    } else {\n      style = {\n        width: props.size,\n        height: props.size,\n        display: 'inline-block',\n        backgroundImage: \"url(\".concat(props.backgroundImageFn(props.set, props.sheetSize), \")\"),\n        backgroundSize: \"\".concat(100 * props.sheetColumns, \"% \").concat(100 * props.sheetRows, \"%\"),\n        backgroundPosition: _getPosition(props)\n      };\n    }\n  }\n\n  var Tag = {\n    name: 'span',\n    props: {}\n  };\n\n  if (props.onClick && props.useButton) {\n    Tag.name = 'button';\n    Tag.props = {\n      type: 'button'\n    };\n  }\n\n  if (props.html) {\n    style = _convertStyleToCSS(style);\n    return \"<\".concat(Tag.name, \" style='\").concat(style, \"' aria-label='\").concat(label, \"' \").concat(title ? \"title='\".concat(title, \"'\") : '', \" class='\").concat(className, \"'>\").concat(children || '', \"</\").concat(Tag.name, \">\");\n  } else {\n    return React.createElement(Tag.name, _extends({\n      onClick: function onClick(e) {\n        return _handleClick(e, props);\n      },\n      onMouseEnter: function onMouseEnter(e) {\n        return _handleOver(e, props);\n      },\n      onMouseLeave: function onMouseLeave(e) {\n        return _handleLeave(e, props);\n      },\n      \"aria-label\": label,\n      title: title,\n      className: className\n    }, Tag.props), React.createElement(\"span\", {\n      style: style\n    }, children));\n  }\n};\n\nNimbleEmoji.propTypes\n/* remove-proptypes */\n= _objectSpread({}, EmojiPropTypes, {\n  data: PropTypes.object.isRequired\n});\nNimbleEmoji.defaultProps = EmojiDefaultProps;\nexport default NimbleEmoji;","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport NimbleEmoji from './emoji/nimble-emoji';\n\nvar NotFound =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(NotFound, _React$PureComponent);\n\n  function NotFound() {\n    _classCallCheck(this, NotFound);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(NotFound).apply(this, arguments));\n  }\n\n  _createClass(NotFound, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          data = _this$props.data,\n          emojiProps = _this$props.emojiProps,\n          i18n = _this$props.i18n,\n          notFound = _this$props.notFound,\n          notFoundEmoji = _this$props.notFoundEmoji;\n      var component = notFound && notFound() || React.createElement(\"div\", {\n        className: \"emoji-mart-no-results\"\n      }, NimbleEmoji(_objectSpread({\n        data: data\n      }, emojiProps, {\n        size: 38,\n        emoji: notFoundEmoji,\n        onOver: null,\n        onLeave: null,\n        onClick: null\n      })), React.createElement(\"div\", {\n        className: \"emoji-mart-no-results-label\"\n      }, i18n.notfound));\n      return component;\n    }\n  }]);\n\n  return NotFound;\n}(React.PureComponent);\n\nexport { NotFound as default };\nNotFound.propTypes\n/* remove-proptypes */\n= {\n  notFound: PropTypes.func.isRequired,\n  emojiProps: PropTypes.object.isRequired\n};","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport frequently from '../utils/frequently';\nimport { getData } from '../utils';\nimport NimbleEmoji from './emoji/nimble-emoji';\nimport NotFound from './not-found';\n\nvar Category =\n/*#__PURE__*/\nfunction (_React$Component) {\n  _inherits(Category, _React$Component);\n\n  function Category(props) {\n    var _this;\n\n    _classCallCheck(this, Category);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Category).call(this, props));\n    _this.data = props.data;\n    _this.setContainerRef = _this.setContainerRef.bind(_assertThisInitialized(_this));\n    _this.setLabelRef = _this.setLabelRef.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(Category, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.margin = 0;\n      this.minMargin = 0;\n      this.memoizeSize();\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      var _this$props = this.props,\n          name = _this$props.name,\n          perLine = _this$props.perLine,\n          _native = _this$props[\"native\"],\n          hasStickyPosition = _this$props.hasStickyPosition,\n          emojis = _this$props.emojis,\n          emojiProps = _this$props.emojiProps,\n          skin = emojiProps.skin,\n          size = emojiProps.size,\n          set = emojiProps.set,\n          nextPerLine = nextProps.perLine,\n          nextNative = nextProps[\"native\"],\n          nextHasStickyPosition = nextProps.hasStickyPosition,\n          nextEmojis = nextProps.emojis,\n          nextEmojiProps = nextProps.emojiProps,\n          nextSkin = nextEmojiProps.skin,\n          nextSize = nextEmojiProps.size,\n          nextSet = nextEmojiProps.set,\n          shouldUpdate = false;\n\n      if (name == 'Recent' && perLine != nextPerLine) {\n        shouldUpdate = true;\n      }\n\n      if (name == 'Search') {\n        shouldUpdate = !(emojis == nextEmojis);\n      }\n\n      if (skin != nextSkin || size != nextSize || _native != nextNative || set != nextSet || hasStickyPosition != nextHasStickyPosition) {\n        shouldUpdate = true;\n      }\n\n      return shouldUpdate;\n    }\n  }, {\n    key: \"memoizeSize\",\n    value: function memoizeSize() {\n      if (!this.container) {\n        // probably this is a test environment, e.g. jest\n        this.top = 0;\n        this.maxMargin = 0;\n        return;\n      }\n\n      var parent = this.container.parentElement;\n\n      var _this$container$getBo = this.container.getBoundingClientRect(),\n          top = _this$container$getBo.top,\n          height = _this$container$getBo.height;\n\n      var _parent$getBoundingCl = parent.getBoundingClientRect(),\n          parentTop = _parent$getBoundingCl.top;\n\n      var _this$label$getBoundi = this.label.getBoundingClientRect(),\n          labelHeight = _this$label$getBoundi.height;\n\n      this.top = top - parentTop + parent.scrollTop;\n\n      if (height == 0) {\n        this.maxMargin = 0;\n      } else {\n        this.maxMargin = height - labelHeight;\n      }\n    }\n  }, {\n    key: \"handleScroll\",\n    value: function handleScroll(scrollTop) {\n      var margin = scrollTop - this.top;\n      margin = margin < this.minMargin ? this.minMargin : margin;\n      margin = margin > this.maxMargin ? this.maxMargin : margin;\n      if (margin == this.margin) return;\n\n      if (!this.props.hasStickyPosition) {\n        this.label.style.top = \"\".concat(margin, \"px\");\n      }\n\n      this.margin = margin;\n      return true;\n    }\n  }, {\n    key: \"getEmojis\",\n    value: function getEmojis() {\n      var _this2 = this;\n\n      var _this$props2 = this.props,\n          name = _this$props2.name,\n          emojis = _this$props2.emojis,\n          recent = _this$props2.recent,\n          perLine = _this$props2.perLine;\n\n      if (name == 'Recent') {\n        var custom = this.props.custom;\n        var frequentlyUsed = recent || frequently.get(perLine);\n\n        if (frequentlyUsed.length) {\n          emojis = frequentlyUsed.map(function (id) {\n            var emoji = custom.filter(function (e) {\n              return e.id === id;\n            })[0];\n\n            if (emoji) {\n              return emoji;\n            }\n\n            return id;\n          }).filter(function (id) {\n            return !!getData(id, null, null, _this2.data);\n          });\n        }\n\n        if (emojis.length === 0 && frequentlyUsed.length > 0) {\n          return null;\n        }\n      }\n\n      if (emojis) {\n        emojis = emojis.slice(0);\n      }\n\n      return emojis;\n    }\n  }, {\n    key: \"updateDisplay\",\n    value: function updateDisplay(display) {\n      var emojis = this.getEmojis();\n\n      if (!emojis || !this.container) {\n        return;\n      }\n\n      this.container.style.display = display;\n    }\n  }, {\n    key: \"setContainerRef\",\n    value: function setContainerRef(c) {\n      this.container = c;\n    }\n  }, {\n    key: \"setLabelRef\",\n    value: function setLabelRef(c) {\n      this.label = c;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      var _this$props3 = this.props,\n          id = _this$props3.id,\n          name = _this$props3.name,\n          hasStickyPosition = _this$props3.hasStickyPosition,\n          emojiProps = _this$props3.emojiProps,\n          i18n = _this$props3.i18n,\n          notFound = _this$props3.notFound,\n          notFoundEmoji = _this$props3.notFoundEmoji,\n          emojis = this.getEmojis(),\n          labelStyles = {},\n          labelSpanStyles = {},\n          containerStyles = {};\n\n      if (!emojis) {\n        containerStyles = {\n          display: 'none'\n        };\n      }\n\n      if (!hasStickyPosition) {\n        labelStyles = {\n          height: 28\n        };\n        labelSpanStyles = {\n          position: 'absolute'\n        };\n      }\n\n      var label = i18n.categories[id] || name;\n      return React.createElement(\"section\", {\n        ref: this.setContainerRef,\n        className: \"emoji-mart-category\",\n        \"aria-label\": label,\n        style: containerStyles\n      }, React.createElement(\"div\", {\n        style: labelStyles,\n        \"data-name\": name,\n        className: \"emoji-mart-category-label\"\n      }, React.createElement(\"span\", {\n        style: labelSpanStyles,\n        ref: this.setLabelRef,\n        \"aria-hidden\": true\n        /* already labeled by the section aria-label */\n\n      }, label)), React.createElement(\"ul\", {\n        className: \"emoji-mart-category-list\"\n      }, emojis && emojis.map(function (emoji) {\n        return React.createElement(\"li\", {\n          key: emoji.short_names && emoji.short_names.join('_') || emoji\n        }, NimbleEmoji(_objectSpread({\n          emoji: emoji,\n          data: _this3.data\n        }, emojiProps)));\n      })), emojis && !emojis.length && React.createElement(NotFound, {\n        i18n: i18n,\n        notFound: notFound,\n        notFoundEmoji: notFoundEmoji,\n        data: this.data,\n        emojiProps: emojiProps\n      }));\n    }\n  }]);\n\n  return Category;\n}(React.Component);\n\nexport { Category as default };\nCategory.propTypes\n/* remove-proptypes */\n= {\n  emojis: PropTypes.array,\n  hasStickyPosition: PropTypes.bool,\n  name: PropTypes.string.isRequired,\n  \"native\": PropTypes.bool.isRequired,\n  perLine: PropTypes.number.isRequired,\n  emojiProps: PropTypes.object.isRequired,\n  recent: PropTypes.arrayOf(PropTypes.string),\n  notFound: PropTypes.func,\n  notFoundEmoji: PropTypes.string.isRequired\n};\nCategory.defaultProps = {\n  emojis: [],\n  hasStickyPosition: true\n};","import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\n\nvar Skins =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(Skins, _React$PureComponent);\n\n  function Skins(props) {\n    var _this;\n\n    _classCallCheck(this, Skins);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Skins).call(this, props));\n    _this.state = {\n      opened: false\n    };\n    return _this;\n  }\n\n  _createClass(Skins, [{\n    key: \"handleClick\",\n    value: function handleClick(e) {\n      var skin = parseInt(e.currentTarget.getAttribute('data-skin'));\n      var onChange = this.props.onChange;\n\n      if (!this.state.opened) {\n        this.setState({\n          opened: true\n        });\n      } else {\n        this.setState({\n          opened: false\n        });\n\n        if (skin != this.props.skin) {\n          onChange(skin);\n        }\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return null;\n    }\n  }]);\n\n  return Skins;\n}(React.PureComponent);\n\nexport { Skins as default };\nSkins.propTypes\n/* remove-proptypes */\n= {\n  onChange: PropTypes.func,\n  skin: PropTypes.number.isRequired\n};\nSkins.defaultProps = {\n  onChange: function onChange() {}\n};","import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport NimbleEmoji from './emoji/nimble-emoji';\nimport Skins from './skins';\n\nvar SkinsEmoji =\n/*#__PURE__*/\nfunction (_Skins) {\n  _inherits(SkinsEmoji, _Skins);\n\n  function SkinsEmoji(props) {\n    var _this;\n\n    _classCallCheck(this, SkinsEmoji);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SkinsEmoji).call(this, props));\n    _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(SkinsEmoji, [{\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          skin = _this$props.skin,\n          emojiProps = _this$props.emojiProps,\n          data = _this$props.data,\n          skinEmoji = _this$props.skinEmoji,\n          i18n = _this$props.i18n;\n      var opened = this.state.opened;\n      var skinToneNodes = [];\n\n      for (var skinTone = 1; skinTone <= 6; skinTone++) {\n        var selected = skinTone === skin;\n        skinToneNodes.push(React.createElement(\"span\", {\n          key: \"skin-tone-\".concat(skinTone),\n          className: \"emoji-mart-skin-swatch custom\".concat(selected ? ' selected' : '')\n        }, React.createElement(\"span\", {\n          onClick: this.handleClick,\n          \"data-skin\": skinTone,\n          className: \"emoji-mart-skin-tone-\".concat(skinTone)\n        }, NimbleEmoji({\n          emoji: skinEmoji,\n          data: data,\n          skin: skinTone,\n          backgroundImageFn: emojiProps.backgroundImageFn,\n          \"native\": emojiProps[\"native\"],\n          set: emojiProps.set,\n          sheetSize: emojiProps.sheetSize,\n          size: 23\n        }))));\n      }\n\n      return React.createElement(\"div\", {\n        className: \"emoji-mart-skin-swatches custom\".concat(opened ? ' opened' : '')\n      }, React.createElement(\"div\", {\n        className: \"emoji-mart-skin-text\".concat(opened ? ' opened' : '')\n      }, i18n.skintext), skinToneNodes);\n    }\n  }]);\n\n  return SkinsEmoji;\n}(Skins);\n\nexport { SkinsEmoji as default };\nSkinsEmoji.propTypes\n/* remove-proptypes */\n= {\n  onChange: PropTypes.func,\n  skin: PropTypes.number.isRequired,\n  emojiProps: PropTypes.object.isRequired,\n  skinTone: PropTypes.number,\n  skinEmoji: PropTypes.string.isRequired,\n  i18n: PropTypes.object\n};\nSkinsEmoji.defaultProps = {\n  onChange: function onChange() {},\n  skinTone: null\n};","import _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport Skins from './skins';\n\nvar SkinsDot =\n/*#__PURE__*/\nfunction (_Skins) {\n  _inherits(SkinsDot, _Skins);\n\n  function SkinsDot(props) {\n    var _this;\n\n    _classCallCheck(this, SkinsDot);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(SkinsDot).call(this, props));\n    _this.handleClick = _this.handleClick.bind(_assertThisInitialized(_this));\n    _this.handleKeyDown = _this.handleKeyDown.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(SkinsDot, [{\n    key: \"handleKeyDown\",\n    value: function handleKeyDown(event) {\n      // if either enter or space is pressed, then execute\n      if (event.keyCode === 13 || event.keyCode === 32) {\n        event.preventDefault();\n        this.handleClick(event);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          skin = _this$props.skin,\n          i18n = _this$props.i18n;\n      var opened = this.state.opened;\n      var skinToneNodes = [];\n\n      for (var skinTone = 1; skinTone <= 6; skinTone++) {\n        var selected = skinTone === skin;\n        var visible = opened || selected;\n        skinToneNodes.push(React.createElement(\"span\", _extends({\n          key: \"skin-tone-\".concat(skinTone),\n          className: \"emoji-mart-skin-swatch\".concat(selected ? ' selected' : ''),\n          \"aria-label\": i18n.skintones[skinTone],\n          \"aria-hidden\": !visible\n        }, opened ? {\n          role: 'menuitem'\n        } : {}), React.createElement(\"span\", _extends({\n          onClick: this.handleClick,\n          onKeyDown: this.handleKeyDown,\n          role: \"button\"\n        }, selected ? {\n          'aria-haspopup': true,\n          'aria-expanded': !!opened\n        } : {}, opened ? {\n          'aria-pressed': !!selected\n        } : {}, {\n          tabIndex: visible ? '0' : '',\n          \"aria-label\": i18n.skintones[skinTone],\n          title: i18n.skintones[skinTone],\n          \"data-skin\": skinTone,\n          className: \"emoji-mart-skin emoji-mart-skin-tone-\".concat(skinTone)\n        }))));\n      }\n\n      return React.createElement(\"section\", {\n        className: \"emoji-mart-skin-swatches\".concat(opened ? ' opened' : ''),\n        \"aria-label\": i18n.skintext\n      }, React.createElement(\"div\", opened ? {\n        role: 'menubar'\n      } : {}, skinToneNodes));\n    }\n  }]);\n\n  return SkinsDot;\n}(Skins);\n\nexport { SkinsDot as default };\nSkinsDot.propTypes\n/* remove-proptypes */\n= {\n  onChange: PropTypes.func,\n  skin: PropTypes.number.isRequired,\n  i18n: PropTypes.object\n};\nSkinsDot.defaultProps = {\n  onChange: function onChange() {}\n};","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { getData } from '../utils';\nimport NimbleEmoji from './emoji/nimble-emoji';\nimport SkinsEmoji from './skins-emoji';\nimport SkinsDot from './skins-dot';\n\nvar Preview =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(Preview, _React$PureComponent);\n\n  function Preview(props) {\n    var _this;\n\n    _classCallCheck(this, Preview);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Preview).call(this, props));\n    _this.data = props.data;\n    _this.state = {\n      emoji: null\n    };\n    return _this;\n  }\n\n  _createClass(Preview, [{\n    key: \"render\",\n    value: function render() {\n      var emoji = this.state.emoji,\n          _this$props = this.props,\n          emojiProps = _this$props.emojiProps,\n          skinsProps = _this$props.skinsProps,\n          showSkinTones = _this$props.showSkinTones,\n          title = _this$props.title,\n          idleEmoji = _this$props.emoji,\n          i18n = _this$props.i18n,\n          showPreview = _this$props.showPreview;\n\n      if (emoji && showPreview) {\n        var emojiData = getData(emoji, null, null, this.data),\n            _emojiData$emoticons = emojiData.emoticons,\n            emoticons = _emojiData$emoticons === void 0 ? [] : _emojiData$emoticons,\n            knownEmoticons = [],\n            listedEmoticons = [];\n        emoticons.forEach(function (emoticon) {\n          if (knownEmoticons.indexOf(emoticon.toLowerCase()) >= 0) {\n            return;\n          }\n\n          knownEmoticons.push(emoticon.toLowerCase());\n          listedEmoticons.push(emoticon);\n        });\n        return React.createElement(\"div\", {\n          className: \"emoji-mart-preview\"\n        }, React.createElement(\"div\", {\n          className: \"emoji-mart-preview-emoji\",\n          \"aria-hidden\": \"true\"\n        }, NimbleEmoji(_objectSpread({\n          key: emoji.id,\n          emoji: emoji,\n          data: this.data\n        }, emojiProps))), React.createElement(\"div\", {\n          className: \"emoji-mart-preview-data\",\n          \"aria-hidden\": \"true\"\n        }, React.createElement(\"div\", {\n          className: \"emoji-mart-preview-name\"\n        }, emoji.name), React.createElement(\"div\", {\n          className: \"emoji-mart-preview-shortnames\"\n        }, emojiData.short_names.map(function (short_name) {\n          return React.createElement(\"span\", {\n            key: short_name,\n            className: \"emoji-mart-preview-shortname\"\n          }, \":\", short_name, \":\");\n        })), React.createElement(\"div\", {\n          className: \"emoji-mart-preview-emoticons\"\n        }, listedEmoticons.map(function (emoticon) {\n          return React.createElement(\"span\", {\n            key: emoticon,\n            className: \"emoji-mart-preview-emoticon\"\n          }, emoticon);\n        }))));\n      } else {\n        return React.createElement(\"div\", {\n          className: \"emoji-mart-preview\"\n        }, React.createElement(\"div\", {\n          className: \"emoji-mart-preview-emoji\",\n          \"aria-hidden\": \"true\"\n        }, idleEmoji && idleEmoji.length && NimbleEmoji(_objectSpread({\n          emoji: idleEmoji,\n          data: this.data\n        }, emojiProps))), React.createElement(\"div\", {\n          className: \"emoji-mart-preview-data\",\n          \"aria-hidden\": \"true\"\n        }, React.createElement(\"span\", {\n          className: \"emoji-mart-title-label\"\n        }, title)), showSkinTones && React.createElement(\"div\", {\n          className: \"emoji-mart-preview-skins\".concat(skinsProps.skinEmoji ? ' custom' : '')\n        }, skinsProps.skinEmoji ? React.createElement(SkinsEmoji, {\n          skin: skinsProps.skin,\n          emojiProps: emojiProps,\n          data: this.data,\n          skinEmoji: skinsProps.skinEmoji,\n          i18n: i18n,\n          onChange: skinsProps.onChange\n        }) : React.createElement(SkinsDot, {\n          skin: skinsProps.skin,\n          i18n: i18n,\n          onChange: skinsProps.onChange\n        })));\n      }\n    }\n  }]);\n\n  return Preview;\n}(React.PureComponent);\n\nexport { Preview as default };\nPreview.propTypes\n/* remove-proptypes */\n= {\n  showSkinTones: PropTypes.bool,\n  title: PropTypes.string.isRequired,\n  emoji: PropTypes.string.isRequired,\n  emojiProps: PropTypes.object.isRequired,\n  skinsProps: PropTypes.object.isRequired\n};\nPreview.defaultProps = {\n  showSkinTones: true,\n  onChange: function onChange() {}\n};","import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { search as icons } from '../svgs';\nimport NimbleEmojiIndex from '../utils/emoji-index/nimble-emoji-index';\nimport { throttleIdleTask } from '../utils/index';\nvar id = 0;\n\nvar Search =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(Search, _React$PureComponent);\n\n  function Search(props) {\n    var _this;\n\n    _classCallCheck(this, Search);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Search).call(this, props));\n    _this.state = {\n      icon: icons.search,\n      isSearching: false,\n      id: ++id\n    };\n    _this.data = props.data;\n    _this.emojiIndex = new NimbleEmojiIndex(_this.data);\n    _this.setRef = _this.setRef.bind(_assertThisInitialized(_this));\n    _this.clear = _this.clear.bind(_assertThisInitialized(_this));\n    _this.handleKeyUp = _this.handleKeyUp.bind(_assertThisInitialized(_this)); // throttle keyboard input so that typing isn't delayed\n\n    _this.handleChange = throttleIdleTask(_this.handleChange.bind(_assertThisInitialized(_this)));\n    return _this;\n  }\n\n  _createClass(Search, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      // in some cases (e.g. preact) the input may already be pre-populated\n      // this.input is undefined in Jest tests\n      if (this.input && this.input.value) {\n        this.search(this.input.value);\n      }\n    }\n  }, {\n    key: \"search\",\n    value: function search(value) {\n      if (value == '') this.setState({\n        icon: icons.search,\n        isSearching: false\n      });else this.setState({\n        icon: icons[\"delete\"],\n        isSearching: true\n      });\n      this.props.onSearch(this.emojiIndex.search(value, {\n        emojisToShowFilter: this.props.emojisToShowFilter,\n        maxResults: this.props.maxResults,\n        include: this.props.include,\n        exclude: this.props.exclude,\n        custom: this.props.custom\n      }));\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      if (this.input.value == '') return;\n      this.input.value = '';\n      this.input.focus();\n      this.search('');\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange() {\n      if (this.input) {\n        this.search(this.input.value);\n      }\n    }\n  }, {\n    key: \"handleKeyUp\",\n    value: function handleKeyUp(e) {\n      if (e.keyCode === 13) {\n        this.clear();\n      }\n    }\n  }, {\n    key: \"setRef\",\n    value: function setRef(c) {\n      this.input = c;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          i18n = _this$props.i18n,\n          autoFocus = _this$props.autoFocus;\n      var _this$state = this.state,\n          icon = _this$state.icon,\n          isSearching = _this$state.isSearching,\n          id = _this$state.id;\n      var inputId = \"emoji-mart-search-\".concat(id);\n      return React.createElement(\"section\", {\n        className: \"emoji-mart-search\",\n        \"aria-label\": i18n.search\n      }, React.createElement(\"input\", {\n        id: inputId,\n        ref: this.setRef,\n        type: \"search\",\n        onChange: this.handleChange,\n        placeholder: i18n.search,\n        autoFocus: autoFocus\n      }), React.createElement(\"label\", {\n        className: \"emoji-mart-sr-only\",\n        htmlFor: inputId\n      }, i18n.search), React.createElement(\"button\", {\n        className: \"emoji-mart-search-icon\",\n        onClick: this.clear,\n        onKeyUp: this.handleKeyUp,\n        \"aria-label\": i18n.clear,\n        disabled: !isSearching\n      }, icon()));\n    }\n  }]);\n\n  return Search;\n}(React.PureComponent);\n\nexport { Search as default };\nSearch.propTypes\n/* remove-proptypes */\n= {\n  onSearch: PropTypes.func,\n  maxResults: PropTypes.number,\n  emojisToShowFilter: PropTypes.func,\n  autoFocus: PropTypes.bool\n};\nSearch.defaultProps = {\n  onSearch: function onSearch() {},\n  maxResults: 75,\n  emojisToShowFilter: null,\n  autoFocus: false\n};","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport * as icons from '../../svgs';\nimport store from '../../utils/store';\nimport frequently from '../../utils/frequently';\nimport { deepMerge, measureScrollbar, getSanitizedData } from '../../utils';\nimport { uncompress } from '../../utils/data';\nimport { PickerPropTypes } from '../../utils/shared-props';\nimport Anchors from '../anchors';\nimport Category from '../category';\nimport Preview from '../preview';\nimport Search from '../search';\nimport { PickerDefaultProps } from '../../utils/shared-default-props';\nvar I18N = {\n  search: 'Search',\n  clear: 'Clear',\n  // Accessible label on \"clear\" button\n  notfound: 'No Emoji Found',\n  skintext: 'Choose your default skin tone',\n  categories: {\n    search: 'Search Results',\n    recent: 'Frequently Used',\n    people: 'Smileys & People',\n    nature: 'Animals & Nature',\n    foods: 'Food & Drink',\n    activity: 'Activity',\n    places: 'Travel & Places',\n    objects: 'Objects',\n    symbols: 'Symbols',\n    flags: 'Flags',\n    custom: 'Custom'\n  },\n  categorieslabel: 'Emoji categories',\n  // Accessible title for the list of categories\n  skintones: {\n    1: 'Default Skin Tone',\n    2: 'Light Skin Tone',\n    3: 'Medium-Light Skin Tone',\n    4: 'Medium Skin Tone',\n    5: 'Medium-Dark Skin Tone',\n    6: 'Dark Skin Tone'\n  }\n};\n\nvar NimblePicker =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(NimblePicker, _React$PureComponent);\n\n  function NimblePicker(props) {\n    var _this;\n\n    _classCallCheck(this, NimblePicker);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(NimblePicker).call(this, props));\n    _this.CUSTOM = [];\n    _this.RECENT_CATEGORY = {\n      id: 'recent',\n      name: 'Recent',\n      emojis: null\n    };\n    _this.SEARCH_CATEGORY = {\n      id: 'search',\n      name: 'Search',\n      emojis: null,\n      anchor: false\n    };\n\n    if (props.data.compressed) {\n      uncompress(props.data);\n    }\n\n    _this.data = props.data;\n    _this.i18n = deepMerge(I18N, props.i18n);\n    _this.icons = deepMerge(icons, props.icons);\n    _this.state = {\n      firstRender: true\n    };\n    _this.categories = [];\n    var allCategories = [].concat(_this.data.categories);\n\n    if (props.custom.length > 0) {\n      var customCategories = {};\n      var customCategoriesCreated = 0;\n      props.custom.forEach(function (emoji) {\n        if (!customCategories[emoji.customCategory]) {\n          customCategories[emoji.customCategory] = {\n            id: emoji.customCategory ? \"custom-\".concat(emoji.customCategory) : 'custom',\n            name: emoji.customCategory || 'Custom',\n            emojis: [],\n            anchor: customCategoriesCreated === 0\n          };\n          customCategoriesCreated++;\n        }\n\n        var category = customCategories[emoji.customCategory];\n\n        var customEmoji = _objectSpread({}, emoji, {\n          // `<Category />` expects emoji to have an `id`.\n          id: emoji.short_names[0],\n          custom: true\n        });\n\n        category.emojis.push(customEmoji);\n\n        _this.CUSTOM.push(customEmoji);\n      });\n      allCategories = allCategories.concat(Object.keys(customCategories).map(function (key) {\n        return customCategories[key];\n      }));\n    }\n\n    _this.hideRecent = true;\n\n    if (props.include != undefined) {\n      allCategories.sort(function (a, b) {\n        if (props.include.indexOf(a.id) > props.include.indexOf(b.id)) {\n          return 1;\n        }\n\n        return -1;\n      });\n    }\n\n    for (var categoryIndex = 0; categoryIndex < allCategories.length; categoryIndex++) {\n      var category = allCategories[categoryIndex];\n      var isIncluded = props.include && props.include.length ? props.include.indexOf(category.id) > -1 : true;\n      var isExcluded = props.exclude && props.exclude.length ? props.exclude.indexOf(category.id) > -1 : false;\n\n      if (!isIncluded || isExcluded) {\n        continue;\n      }\n\n      if (props.emojisToShowFilter) {\n        var newEmojis = [];\n        var emojis = category.emojis;\n\n        for (var emojiIndex = 0; emojiIndex < emojis.length; emojiIndex++) {\n          var emoji = emojis[emojiIndex];\n\n          if (props.emojisToShowFilter(_this.data.emojis[emoji] || emoji)) {\n            newEmojis.push(emoji);\n          }\n        }\n\n        if (newEmojis.length) {\n          var newCategory = {\n            emojis: newEmojis,\n            name: category.name,\n            id: category.id\n          };\n\n          _this.categories.push(newCategory);\n        }\n      } else {\n        _this.categories.push(category);\n      }\n    }\n\n    var includeRecent = props.include && props.include.length ? props.include.indexOf(_this.RECENT_CATEGORY.id) > -1 : true;\n    var excludeRecent = props.exclude && props.exclude.length ? props.exclude.indexOf(_this.RECENT_CATEGORY.id) > -1 : false;\n\n    if (includeRecent && !excludeRecent) {\n      _this.hideRecent = false;\n\n      _this.categories.unshift(_this.RECENT_CATEGORY);\n    }\n\n    if (_this.categories[0]) {\n      _this.categories[0].first = true;\n    }\n\n    _this.categories.unshift(_this.SEARCH_CATEGORY);\n\n    _this.setAnchorsRef = _this.setAnchorsRef.bind(_assertThisInitialized(_this));\n    _this.handleAnchorClick = _this.handleAnchorClick.bind(_assertThisInitialized(_this));\n    _this.setSearchRef = _this.setSearchRef.bind(_assertThisInitialized(_this));\n    _this.handleSearch = _this.handleSearch.bind(_assertThisInitialized(_this));\n    _this.setScrollRef = _this.setScrollRef.bind(_assertThisInitialized(_this));\n    _this.handleScroll = _this.handleScroll.bind(_assertThisInitialized(_this));\n    _this.handleScrollPaint = _this.handleScrollPaint.bind(_assertThisInitialized(_this));\n    _this.handleEmojiOver = _this.handleEmojiOver.bind(_assertThisInitialized(_this));\n    _this.handleEmojiLeave = _this.handleEmojiLeave.bind(_assertThisInitialized(_this));\n    _this.handleEmojiClick = _this.handleEmojiClick.bind(_assertThisInitialized(_this));\n    _this.handleEmojiSelect = _this.handleEmojiSelect.bind(_assertThisInitialized(_this));\n    _this.setPreviewRef = _this.setPreviewRef.bind(_assertThisInitialized(_this));\n    _this.handleSkinChange = _this.handleSkinChange.bind(_assertThisInitialized(_this));\n    _this.handleKeyDown = _this.handleKeyDown.bind(_assertThisInitialized(_this));\n    _this.handleDarkMatchMediaChange = _this.handleDarkMatchMediaChange.bind(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(NimblePicker, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      if (this.state.firstRender) {\n        this.testStickyPosition();\n        this.firstRenderTimeout = setTimeout(function () {\n          _this2.setState({\n            firstRender: false\n          });\n        }, 60);\n      }\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.updateCategoriesSize();\n      this.handleScroll();\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.SEARCH_CATEGORY.emojis = null;\n      clearTimeout(this.leaveTimeout);\n      clearTimeout(this.firstRenderTimeout);\n\n      if (this.darkMatchMedia) {\n        this.darkMatchMedia.removeListener(this.handleDarkMatchMediaChange);\n      }\n    }\n  }, {\n    key: \"testStickyPosition\",\n    value: function testStickyPosition() {\n      var stickyTestElement = document.createElement('div');\n      var prefixes = ['', '-webkit-', '-ms-', '-moz-', '-o-'];\n      prefixes.forEach(function (prefix) {\n        return stickyTestElement.style.position = \"\".concat(prefix, \"sticky\");\n      });\n      this.hasStickyPosition = !!stickyTestElement.style.position.length;\n    }\n  }, {\n    key: \"getPreferredTheme\",\n    value: function getPreferredTheme() {\n      if (this.props.theme != 'auto') return this.props.theme;\n      if (this.state.theme) return this.state.theme;\n      if (typeof matchMedia !== 'function') return PickerDefaultProps.theme;\n\n      if (!this.darkMatchMedia) {\n        this.darkMatchMedia = matchMedia('(prefers-color-scheme: dark)');\n        this.darkMatchMedia.addListener(this.handleDarkMatchMediaChange);\n      }\n\n      if (this.darkMatchMedia.media.match(/^not/)) return PickerDefaultProps.theme;\n      return this.darkMatchMedia.matches ? 'dark' : 'light';\n    }\n  }, {\n    key: \"handleDarkMatchMediaChange\",\n    value: function handleDarkMatchMediaChange() {\n      this.setState({\n        theme: this.darkMatchMedia.matches ? 'dark' : 'light'\n      });\n    }\n  }, {\n    key: \"handleEmojiOver\",\n    value: function handleEmojiOver(emoji) {\n      var preview = this.preview;\n\n      if (!preview) {\n        return;\n      } // Use Array.prototype.find() when it is more widely supported.\n\n\n      var emojiData = this.CUSTOM.filter(function (customEmoji) {\n        return customEmoji.id === emoji.id;\n      })[0];\n\n      for (var key in emojiData) {\n        if (emojiData.hasOwnProperty(key)) {\n          emoji[key] = emojiData[key];\n        }\n      }\n\n      preview.setState({\n        emoji: emoji\n      });\n      clearTimeout(this.leaveTimeout);\n    }\n  }, {\n    key: \"handleEmojiLeave\",\n    value: function handleEmojiLeave(emoji) {\n      var preview = this.preview;\n\n      if (!preview) {\n        return;\n      }\n\n      this.leaveTimeout = setTimeout(function () {\n        preview.setState({\n          emoji: null\n        });\n      }, 16);\n    }\n  }, {\n    key: \"handleEmojiClick\",\n    value: function handleEmojiClick(emoji, e) {\n      this.props.onClick(emoji, e);\n      this.handleEmojiSelect(emoji);\n    }\n  }, {\n    key: \"handleEmojiSelect\",\n    value: function handleEmojiSelect(emoji) {\n      var _this3 = this;\n\n      this.props.onSelect(emoji);\n      if (!this.hideRecent && !this.props.recent) frequently.add(emoji);\n      var component = this.categoryRefs['category-1'];\n\n      if (component) {\n        var maxMargin = component.maxMargin;\n\n        if (this.props.enableFrequentEmojiSort) {\n          component.forceUpdate();\n        }\n\n        requestAnimationFrame(function () {\n          if (!_this3.scroll) return;\n          component.memoizeSize();\n          if (maxMargin == component.maxMargin) return;\n\n          _this3.updateCategoriesSize();\n\n          _this3.handleScrollPaint();\n\n          if (_this3.SEARCH_CATEGORY.emojis) {\n            component.updateDisplay('none');\n          }\n        });\n      }\n    }\n  }, {\n    key: \"handleScroll\",\n    value: function handleScroll() {\n      if (!this.waitingForPaint) {\n        this.waitingForPaint = true;\n        requestAnimationFrame(this.handleScrollPaint);\n      }\n    }\n  }, {\n    key: \"handleScrollPaint\",\n    value: function handleScrollPaint() {\n      this.waitingForPaint = false;\n\n      if (!this.scroll) {\n        return;\n      }\n\n      var activeCategory = null;\n\n      if (this.SEARCH_CATEGORY.emojis) {\n        activeCategory = this.SEARCH_CATEGORY;\n      } else {\n        var target = this.scroll,\n            scrollTop = target.scrollTop,\n            scrollingDown = scrollTop > (this.scrollTop || 0),\n            minTop = 0;\n\n        for (var i = 0, l = this.categories.length; i < l; i++) {\n          var ii = scrollingDown ? this.categories.length - 1 - i : i,\n              category = this.categories[ii],\n              component = this.categoryRefs[\"category-\".concat(ii)];\n\n          if (component) {\n            var active = component.handleScroll(scrollTop);\n\n            if (!minTop || component.top < minTop) {\n              if (component.top > 0) {\n                minTop = component.top;\n              }\n            }\n\n            if (active && !activeCategory) {\n              activeCategory = category;\n            }\n          }\n        }\n\n        if (scrollTop < minTop) {\n          activeCategory = this.categories.filter(function (category) {\n            return !(category.anchor === false);\n          })[0];\n        } else if (scrollTop + this.clientHeight >= this.scrollHeight) {\n          activeCategory = this.categories[this.categories.length - 1];\n        }\n      }\n\n      if (activeCategory) {\n        var anchors = this.anchors,\n            _activeCategory = activeCategory,\n            categoryName = _activeCategory.name;\n\n        if (anchors.state.selected != categoryName) {\n          anchors.setState({\n            selected: categoryName\n          });\n        }\n      }\n\n      this.scrollTop = scrollTop;\n    }\n  }, {\n    key: \"handleSearch\",\n    value: function handleSearch(emojis) {\n      this.SEARCH_CATEGORY.emojis = emojis;\n\n      for (var i = 0, l = this.categories.length; i < l; i++) {\n        var component = this.categoryRefs[\"category-\".concat(i)];\n\n        if (component && component.props.name != 'Search') {\n          var display = emojis ? 'none' : 'inherit';\n          component.updateDisplay(display);\n        }\n      }\n\n      this.forceUpdate();\n\n      if (this.scroll) {\n        this.scroll.scrollTop = 0;\n      }\n\n      this.handleScroll();\n    }\n  }, {\n    key: \"handleAnchorClick\",\n    value: function handleAnchorClick(category, i) {\n      var component = this.categoryRefs[\"category-\".concat(i)],\n          scroll = this.scroll,\n          anchors = this.anchors,\n          scrollToComponent = null;\n\n      scrollToComponent = function scrollToComponent() {\n        if (component) {\n          var top = component.top;\n\n          if (category.first) {\n            top = 0;\n          } else {\n            top += 1;\n          }\n\n          scroll.scrollTop = top;\n        }\n      };\n\n      if (this.SEARCH_CATEGORY.emojis) {\n        this.handleSearch(null);\n        this.search.clear();\n        requestAnimationFrame(scrollToComponent);\n      } else {\n        scrollToComponent();\n      }\n    }\n  }, {\n    key: \"handleSkinChange\",\n    value: function handleSkinChange(skin) {\n      var newState = {\n        skin: skin\n      },\n          onSkinChange = this.props.onSkinChange;\n      this.setState(newState);\n      store.update(newState);\n      onSkinChange(skin);\n    }\n  }, {\n    key: \"handleKeyDown\",\n    value: function handleKeyDown(e) {\n      var handled = false;\n\n      switch (e.keyCode) {\n        case 13:\n          var emoji;\n\n          if (this.SEARCH_CATEGORY.emojis && this.SEARCH_CATEGORY.emojis.length && (emoji = getSanitizedData(this.SEARCH_CATEGORY.emojis[0], this.state.skin, this.props.set, this.props.data))) {\n            this.handleEmojiSelect(emoji);\n            handled = true;\n          }\n\n          break;\n      }\n\n      if (handled) {\n        e.preventDefault();\n      }\n    }\n  }, {\n    key: \"updateCategoriesSize\",\n    value: function updateCategoriesSize() {\n      for (var i = 0, l = this.categories.length; i < l; i++) {\n        var component = this.categoryRefs[\"category-\".concat(i)];\n        if (component) component.memoizeSize();\n      }\n\n      if (this.scroll) {\n        var target = this.scroll;\n        this.scrollHeight = target.scrollHeight;\n        this.clientHeight = target.clientHeight;\n      }\n    }\n  }, {\n    key: \"getCategories\",\n    value: function getCategories() {\n      return this.state.firstRender ? this.categories.slice(0, 3) : this.categories;\n    }\n  }, {\n    key: \"setAnchorsRef\",\n    value: function setAnchorsRef(c) {\n      this.anchors = c;\n    }\n  }, {\n    key: \"setSearchRef\",\n    value: function setSearchRef(c) {\n      this.search = c;\n    }\n  }, {\n    key: \"setPreviewRef\",\n    value: function setPreviewRef(c) {\n      this.preview = c;\n    }\n  }, {\n    key: \"setScrollRef\",\n    value: function setScrollRef(c) {\n      this.scroll = c;\n    }\n  }, {\n    key: \"setCategoryRef\",\n    value: function setCategoryRef(name, c) {\n      if (!this.categoryRefs) {\n        this.categoryRefs = {};\n      }\n\n      this.categoryRefs[name] = c;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this4 = this;\n\n      var _this$props = this.props,\n          perLine = _this$props.perLine,\n          emojiSize = _this$props.emojiSize,\n          set = _this$props.set,\n          sheetSize = _this$props.sheetSize,\n          sheetColumns = _this$props.sheetColumns,\n          sheetRows = _this$props.sheetRows,\n          style = _this$props.style,\n          title = _this$props.title,\n          emoji = _this$props.emoji,\n          color = _this$props.color,\n          _native = _this$props[\"native\"],\n          backgroundImageFn = _this$props.backgroundImageFn,\n          emojisToShowFilter = _this$props.emojisToShowFilter,\n          showPreview = _this$props.showPreview,\n          showSkinTones = _this$props.showSkinTones,\n          emojiTooltip = _this$props.emojiTooltip,\n          useButton = _this$props.useButton,\n          include = _this$props.include,\n          exclude = _this$props.exclude,\n          recent = _this$props.recent,\n          autoFocus = _this$props.autoFocus,\n          skinEmoji = _this$props.skinEmoji,\n          notFound = _this$props.notFound,\n          notFoundEmoji = _this$props.notFoundEmoji;\n      var width = perLine * (emojiSize + 12) + 12 + 2 + measureScrollbar();\n      var theme = this.getPreferredTheme();\n      var skin = this.props.skin || this.state.skin || store.get('skin') || this.props.defaultSkin;\n      return React.createElement(\"section\", {\n        style: _objectSpread({\n          width: width\n        }, style),\n        className: \"emoji-mart emoji-mart-\".concat(theme),\n        \"aria-label\": title,\n        onKeyDown: this.handleKeyDown\n      }, React.createElement(\"div\", {\n        className: \"emoji-mart-bar\"\n      }, React.createElement(Anchors, {\n        ref: this.setAnchorsRef,\n        data: this.data,\n        i18n: this.i18n,\n        color: color,\n        categories: this.categories,\n        onAnchorClick: this.handleAnchorClick,\n        icons: this.icons\n      })), React.createElement(Search, {\n        ref: this.setSearchRef,\n        onSearch: this.handleSearch,\n        data: this.data,\n        i18n: this.i18n,\n        emojisToShowFilter: emojisToShowFilter,\n        include: include,\n        exclude: exclude,\n        custom: this.CUSTOM,\n        autoFocus: autoFocus\n      }), React.createElement(\"div\", {\n        ref: this.setScrollRef,\n        className: \"emoji-mart-scroll\",\n        onScroll: this.handleScroll\n      }, this.getCategories().map(function (category, i) {\n        return React.createElement(Category, {\n          ref: _this4.setCategoryRef.bind(_this4, \"category-\".concat(i)),\n          key: category.name,\n          id: category.id,\n          name: category.name,\n          emojis: category.emojis,\n          perLine: perLine,\n          \"native\": _native,\n          hasStickyPosition: _this4.hasStickyPosition,\n          data: _this4.data,\n          i18n: _this4.i18n,\n          recent: category.id == _this4.RECENT_CATEGORY.id ? recent : undefined,\n          custom: category.id == _this4.RECENT_CATEGORY.id ? _this4.CUSTOM : undefined,\n          emojiProps: {\n            \"native\": _native,\n            skin: skin,\n            size: emojiSize,\n            set: set,\n            sheetSize: sheetSize,\n            sheetColumns: sheetColumns,\n            sheetRows: sheetRows,\n            forceSize: _native,\n            tooltip: emojiTooltip,\n            backgroundImageFn: backgroundImageFn,\n            useButton: useButton,\n            onOver: _this4.handleEmojiOver,\n            onLeave: _this4.handleEmojiLeave,\n            onClick: _this4.handleEmojiClick\n          },\n          notFound: notFound,\n          notFoundEmoji: notFoundEmoji\n        });\n      })), (showPreview || showSkinTones) && React.createElement(\"div\", {\n        className: \"emoji-mart-bar\"\n      }, React.createElement(Preview, {\n        ref: this.setPreviewRef,\n        data: this.data,\n        title: title,\n        emoji: emoji,\n        showSkinTones: showSkinTones,\n        showPreview: showPreview,\n        emojiProps: {\n          \"native\": _native,\n          size: 38,\n          skin: skin,\n          set: set,\n          sheetSize: sheetSize,\n          sheetColumns: sheetColumns,\n          sheetRows: sheetRows,\n          backgroundImageFn: backgroundImageFn\n        },\n        skinsProps: {\n          skin: skin,\n          onChange: this.handleSkinChange,\n          skinEmoji: skinEmoji\n        },\n        i18n: this.i18n\n      })));\n    }\n  }]);\n\n  return NimblePicker;\n}(React.PureComponent);\n\nexport { NimblePicker as default };\nNimblePicker.propTypes\n/* remove-proptypes */\n= _objectSpread({}, PickerPropTypes, {\n  data: PropTypes.object.isRequired\n});\nNimblePicker.defaultProps = _objectSpread({}, PickerDefaultProps);","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nimport data from '../../../data/all.json';\nimport NimblePicker from './nimble-picker';\nimport { PickerPropTypes } from '../../utils/shared-props';\nimport { PickerDefaultProps } from '../../utils/shared-default-props';\n\nvar Picker =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inherits(Picker, _React$PureComponent);\n\n  function Picker() {\n    _classCallCheck(this, Picker);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Picker).apply(this, arguments));\n  }\n\n  _createClass(Picker, [{\n    key: \"render\",\n    value: function render() {\n      return React.createElement(NimblePicker, _extends({}, this.props, this.state));\n    }\n  }]);\n\n  return Picker;\n}(React.PureComponent);\n\nexport { Picker as default };\nPicker.propTypes\n/* remove-proptypes */\n= PickerPropTypes;\nPicker.defaultProps = _objectSpread({}, PickerDefaultProps, {\n  data: data\n});","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nimport data from '../../../data/all.json';\nimport NimbleEmoji from './nimble-emoji';\nimport { EmojiPropTypes } from '../../utils/shared-props';\nimport { EmojiDefaultProps } from '../../utils/shared-default-props';\n\nvar Emoji = function Emoji(props) {\n  for (var k in Emoji.defaultProps) {\n    if (props[k] == undefined && Emoji.defaultProps[k] != undefined) {\n      props[k] = Emoji.defaultProps[k];\n    }\n  }\n\n  return NimbleEmoji(_objectSpread({}, props));\n};\n\nEmoji.propTypes\n/* remove-proptypes */\n= EmojiPropTypes;\nEmoji.defaultProps = _objectSpread({}, EmojiDefaultProps, {\n  data: data\n});\nexport default Emoji;","/**\n * Utility module to work with strings.\n *\n * @module string\n */\n\nexport const fromCharCode = String.fromCharCode\nexport const fromCodePoint = String.fromCodePoint\n\n/**\n * @param {string} s\n * @return {string}\n */\nconst toLowerCase = s => s.toLowerCase()\n\nconst trimLeftRegex = /^\\s*/g\n\n/**\n * @param {string} s\n * @return {string}\n */\nexport const trimLeft = s => s.replace(trimLeftRegex, '')\n\nconst fromCamelCaseRegex = /([A-Z])/g\n\n/**\n * @param {string} s\n * @param {string} separator\n * @return {string}\n */\nexport const fromCamelCase = (s, separator) => trimLeft(s.replace(fromCamelCaseRegex, match => `${separator}${toLowerCase(match)}`))\n\n/**\n * Compute the utf8ByteLength\n * @param {string} str\n * @return {number}\n */\nexport const utf8ByteLength = str => unescape(encodeURIComponent(str)).length\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Polyfill = str => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  const buf = new Uint8Array(len)\n  for (let i = 0; i < len; i++) {\n    buf[i] = /** @type {number} */ (encodedString.codePointAt(i))\n  }\n  return buf\n}\n\n/* istanbul ignore next */\nexport const utf8TextEncoder = /** @type {TextEncoder} */ (typeof TextEncoder !== 'undefined' ? new TextEncoder() : null)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\nexport const _encodeUtf8Native = str => utf8TextEncoder.encode(str)\n\n/**\n * @param {string} str\n * @return {Uint8Array}\n */\n/* istanbul ignore next */\nexport const encodeUtf8 = utf8TextEncoder ? _encodeUtf8Native : _encodeUtf8Polyfill\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Polyfill = buf => {\n  let remainingLen = buf.length\n  let encodedString = ''\n  let bufPos = 0\n  while (remainingLen > 0) {\n    const nextLen = remainingLen < 10000 ? remainingLen : 10000\n    const bytes = buf.subarray(bufPos, bufPos + nextLen)\n    bufPos += nextLen\n    // Starting with ES5.1 we can supply a generic array-like object as arguments\n    encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n    remainingLen -= nextLen\n  }\n  return decodeURIComponent(escape(encodedString))\n}\n\n/* istanbul ignore next */\nexport let utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', { fatal: true, ignoreBOM: true })\n\n/* istanbul ignore next */\nif (utf8TextDecoder && utf8TextDecoder.decode(new Uint8Array()).length === 1) {\n  // Safari doesn't handle BOM correctly.\n  // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and\n  // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call\n  // Another issue is that from then on no BOM chars are recognized anymore\n  /* istanbul ignore next */\n  utf8TextDecoder = null\n}\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\nexport const _decodeUtf8Native = buf => /** @type {TextDecoder} */ (utf8TextDecoder).decode(buf)\n\n/**\n * @param {Uint8Array} buf\n * @return {string}\n */\n/* istanbul ignore next */\nexport const decodeUtf8 = utf8TextDecoder ? _decodeUtf8Native : _decodeUtf8Polyfill\n","/**\n * Isomorphic module to work access the environment (query params, env variables).\n *\n * @module map\n */\n\nimport * as map from './map.js'\nimport * as string from './string.js'\nimport * as conditions from './conditions.js'\nimport * as storage from './storage.js'\n\n/* istanbul ignore next */\n// @ts-ignore\nexport const isNode = typeof process !== 'undefined' && process.release && /node|io\\.js/.test(process.release.name)\n/* istanbul ignore next */\nexport const isBrowser = typeof window !== 'undefined' && !isNode\n/* istanbul ignore next */\nexport const isMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false\n\n/**\n * @type {Map<string,string>}\n */\nlet params\nconst args = []\n\n/* istanbul ignore next */\nconst computeParams = () => {\n  if (params === undefined) {\n    if (isNode) {\n      params = map.create()\n      const pargs = process.argv\n      let currParamName = null\n      /* istanbul ignore next */\n      for (let i = 0; i < pargs.length; i++) {\n        const parg = pargs[i]\n        if (parg[0] === '-') {\n          if (currParamName !== null) {\n            params.set(currParamName, '')\n          }\n          currParamName = parg\n        } else {\n          if (currParamName !== null) {\n            params.set(currParamName, parg)\n            currParamName = null\n          } else {\n            args.push(parg)\n          }\n        }\n      }\n      if (currParamName !== null) {\n        params.set(currParamName, '')\n      }\n    // in ReactNative for example this would not be true (unless connected to the Remote Debugger)\n    } else if (typeof location === 'object') {\n      params = map.create()\n      // eslint-disable-next-line no-undef\n      ;(location.search || '?').slice(1).split('&').forEach(kv => {\n        if (kv.length !== 0) {\n          const [key, value] = kv.split('=')\n          params.set(`--${string.fromCamelCase(key, '-')}`, value)\n          params.set(`-${string.fromCamelCase(key, '-')}`, value)\n        }\n      })\n    } else {\n      params = map.create()\n    }\n  }\n  return params\n}\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* istanbul ignore next */\nexport const hasParam = name => computeParams().has(name)\n\n/**\n * @param {string} name\n * @param {string} defaultVal\n * @return {string}\n */\n/* istanbul ignore next */\nexport const getParam = (name, defaultVal) => computeParams().get(name) || defaultVal\n// export const getArgs = name => computeParams() && args\n\n/**\n * @param {string} name\n * @return {string|null}\n */\n/* istanbul ignore next */\nexport const getVariable = name => isNode ? conditions.undefinedToNull(process.env[name.toUpperCase()]) : conditions.undefinedToNull(storage.varStorage.getItem(name))\n\n/**\n * @param {string} name\n * @return {string|null}\n */\nexport const getConf = name => computeParams().get('--' + name) || getVariable(name)\n\n/**\n * @param {string} name\n * @return {boolean}\n */\n/* istanbul ignore next */\nexport const hasConf = name => hasParam('--' + name) || getVariable(name) !== null\n\n/* istanbul ignore next */\nexport const production = hasConf('production')\n","/**\n * Efficient schema-less binary decoding with support for variable length encoding.\n *\n * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module decoding\n */\n\nimport * as buffer from './buffer.js'\nimport * as binary from './binary.js'\nimport * as math from './math.js'\n\n/**\n * A Decoder handles the decoding of an Uint8Array.\n */\nexport class Decoder {\n  /**\n   * @param {Uint8Array} uint8Array Binary data to decode\n   */\n  constructor (uint8Array) {\n    /**\n     * Decoding target.\n     *\n     * @type {Uint8Array}\n     */\n    this.arr = uint8Array\n    /**\n     * Current decoding position.\n     *\n     * @type {number}\n     */\n    this.pos = 0\n  }\n}\n\n/**\n * @function\n * @param {Uint8Array} uint8Array\n * @return {Decoder}\n */\nexport const createDecoder = uint8Array => new Decoder(uint8Array)\n\n/**\n * @function\n * @param {Decoder} decoder\n * @return {boolean}\n */\nexport const hasContent = decoder => decoder.pos !== decoder.arr.length\n\n/**\n * Clone a decoder instance.\n * Optionally set a new position parameter.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} [newPos] Defaults to current position\n * @return {Decoder} A clone of `decoder`\n */\nexport const clone = (decoder, newPos = decoder.pos) => {\n  const _decoder = createDecoder(decoder.arr)\n  _decoder.pos = newPos\n  return _decoder\n}\n\n/**\n * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder The decoder instance\n * @param {number} len The length of bytes to read\n * @return {Uint8Array}\n */\nexport const readUint8Array = (decoder, len) => {\n  const view = buffer.createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len)\n  decoder.pos += len\n  return view\n}\n\n/**\n * Read variable length Uint8Array.\n *\n * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.\n *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.\n *\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readVarUint8Array = decoder => readUint8Array(decoder, readVarUint(decoder))\n\n/**\n * Read the rest of the content as an ArrayBuffer\n * @function\n * @param {Decoder} decoder\n * @return {Uint8Array}\n */\nexport const readTailAsUint8Array = decoder => readUint8Array(decoder, decoder.arr.length - decoder.pos)\n\n/**\n * Skip one byte, jump to the next position.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} The next position\n */\nexport const skip8 = decoder => decoder.pos++\n\n/**\n * Read one byte as unsigned integer.\n * @function\n * @param {Decoder} decoder The decoder instance\n * @return {number} Unsigned 8-bit integer\n */\nexport const readUint8 = decoder => decoder.arr[decoder.pos++]\n\n/**\n * Read 2 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint16 = decoder => {\n  const uint =\n    decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8)\n  decoder.pos += 2\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32 = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos] +\n    (decoder.arr[decoder.pos + 1] << 8) +\n    (decoder.arr[decoder.pos + 2] << 16) +\n    (decoder.arr[decoder.pos + 3] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Read 4 bytes as unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const readUint32BigEndian = decoder => {\n  const uint =\n    (decoder.arr[decoder.pos + 3] +\n    (decoder.arr[decoder.pos + 2] << 8) +\n    (decoder.arr[decoder.pos + 1] << 16) +\n    (decoder.arr[decoder.pos] << 24)) >>> 0\n  decoder.pos += 4\n  return uint\n}\n\n/**\n * Look ahead without incrementing position.\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint8 = decoder => decoder.arr[decoder.pos]\n\n/**\n * Look ahead without incrementing position.\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint16 = decoder =>\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8)\n\n/**\n * Look ahead without incrementing position.\n * to the next byte and read it as unsigned integer.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.\n */\nexport const peekUint32 = decoder => (\n  decoder.arr[decoder.pos] +\n  (decoder.arr[decoder.pos + 1] << 8) +\n  (decoder.arr[decoder.pos + 2] << 16) +\n  (decoder.arr[decoder.pos + 3] << 24)\n) >>> 0\n\n/**\n * Read unsigned integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarUint = decoder => {\n  let num = 0\n  let len = 0\n  while (true) {\n    const r = decoder.arr[decoder.pos++]\n    num = num | ((r & binary.BITS7) << len)\n    len += 7\n    if (r < binary.BIT8) {\n      return num >>> 0 // return unsigned number!\n    }\n    /* istanbul ignore if */\n    if (len > 35) {\n      throw new Error('Integer out of range!')\n    }\n  }\n}\n\n/**\n * Read signed integer (32bit) with variable length.\n * 1/8th of the storage is used as encoding overhead.\n *  * numbers < 2^7 is stored in one bytlength\n *  * numbers < 2^14 is stored in two bylength\n * @todo This should probably create the inverse ~num if unmber is negative - but this would be a breaking change.\n *\n * @function\n * @param {Decoder} decoder\n * @return {number} An unsigned integer.length\n */\nexport const readVarInt = decoder => {\n  let r = decoder.arr[decoder.pos++]\n  let num = r & binary.BITS6\n  let len = 6\n  const sign = (r & binary.BIT7) > 0 ? -1 : 1\n  if ((r & binary.BIT8) === 0) {\n    // don't continue reading\n    return sign * num\n  }\n  while (true) {\n    r = decoder.arr[decoder.pos++]\n    num = num | ((r & binary.BITS7) << len)\n    len += 7\n    if (r < binary.BIT8) {\n      return sign * (num >>> 0)\n    }\n    /* istanbul ignore if */\n    if (len > 41) {\n      throw new Error('Integer out of range!')\n    }\n  }\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarUint = decoder => {\n  const pos = decoder.pos\n  const s = readVarUint(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Look ahead and read varUint without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {number}\n */\nexport const peekVarInt = decoder => {\n  const pos = decoder.pos\n  const s = readVarInt(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * Read string of variable length\n * * varUint is used to store the length of the string\n *\n * Transforming utf8 to a string is pretty expensive. The code performs 10x better\n * when String.fromCodePoint is fed with all characters as arguments.\n * But most environments have a maximum number of arguments per functions.\n * For effiency reasons we apply a maximum of 10000 characters at once.\n *\n * @function\n * @param {Decoder} decoder\n * @return {String} The read String.\n */\nexport const readVarString = decoder => {\n  let remainingLen = readVarUint(decoder)\n  if (remainingLen === 0) {\n    return ''\n  } else {\n    let encodedString = String.fromCodePoint(readUint8(decoder)) // remember to decrease remainingLen\n    if (--remainingLen < 100) { // do not create a Uint8Array for small strings\n      while (remainingLen--) {\n        encodedString += String.fromCodePoint(readUint8(decoder))\n      }\n    } else {\n      while (remainingLen > 0) {\n        const nextLen = remainingLen < 10000 ? remainingLen : 10000\n        // this is dangerous, we create a fresh array view from the existing buffer\n        const bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen)\n        decoder.pos += nextLen\n        // Starting with ES5.1 we can supply a generic array-like object as arguments\n        encodedString += String.fromCodePoint.apply(null, /** @type {any} */ (bytes))\n        remainingLen -= nextLen\n      }\n    }\n    return decodeURIComponent(escape(encodedString))\n  }\n}\n\n/**\n * Look ahead and read varString without incrementing position\n *\n * @function\n * @param {Decoder} decoder\n * @return {string}\n */\nexport const peekVarString = decoder => {\n  const pos = decoder.pos\n  const s = readVarString(decoder)\n  decoder.pos = pos\n  return s\n}\n\n/**\n * @param {Decoder} decoder\n * @param {number} len\n * @return {DataView}\n */\nexport const readFromDataView = (decoder, len) => {\n  const dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len)\n  decoder.pos += len\n  return dv\n}\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat32 = decoder => readFromDataView(decoder, 4).getFloat32(0)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readFloat64 = decoder => readFromDataView(decoder, 8).getFloat64(0)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigInt64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigInt64(0)\n\n/**\n * @param {Decoder} decoder\n */\nexport const readBigUint64 = decoder => /** @type {any} */ (readFromDataView(decoder, 8)).getBigUint64(0)\n\n/**\n * @type {Array<function(Decoder):any>}\n */\nconst readAnyLookupTable = [\n  decoder => undefined, // CASE 127: undefined\n  decoder => null, // CASE 126: null\n  readVarInt, // CASE 125: integer\n  readFloat32, // CASE 124: float32\n  readFloat64, // CASE 123: float64\n  readBigInt64, // CASE 122: bigint\n  decoder => false, // CASE 121: boolean (false)\n  decoder => true, // CASE 120: boolean (true)\n  readVarString, // CASE 119: string\n  decoder => { // CASE 118: object<string,any>\n    const len = readVarUint(decoder)\n    /**\n     * @type {Object<string,any>}\n     */\n    const obj = {}\n    for (let i = 0; i < len; i++) {\n      const key = readVarString(decoder)\n      obj[key] = readAny(decoder)\n    }\n    return obj\n  },\n  decoder => { // CASE 117: array<any>\n    const len = readVarUint(decoder)\n    const arr = []\n    for (let i = 0; i < len; i++) {\n      arr.push(readAny(decoder))\n    }\n    return arr\n  },\n  readVarUint8Array // CASE 116: Uint8Array\n]\n\n/**\n * @param {Decoder} decoder\n */\nexport const readAny = decoder => readAnyLookupTable[127 - readUint8(decoder)](decoder)\n\n/**\n * T must not be null.\n *\n * @template T\n */\nexport class RleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {function(Decoder):T} reader\n   */\n  constructor (uint8Array, reader) {\n    super(uint8Array)\n    /**\n     * The reader\n     */\n    this.reader = reader\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = this.reader(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {T} */ (this.s)\n  }\n}\n\nexport class IntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    this.s += readVarInt(this)\n    return this.s\n  }\n}\n\nexport class RleIntDiffDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   * @param {number} start\n   */\n  constructor (uint8Array, start) {\n    super(uint8Array)\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      this.s += readVarInt(this)\n      if (hasContent(this)) {\n        this.count = readVarUint(this) + 1 // see encoder implementation for the reason why this is incremented\n      } else {\n        this.count = -1 // read the current value forever\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class UintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s)\n  }\n}\n\nexport class IncUintOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  read () {\n    if (this.count === 0) {\n      this.s = readVarInt(this)\n      // if the sign is negative, we read the count too, otherwise count is 1\n      const isNegative = math.isNegativeZero(this.s)\n      this.count = 1\n      if (isNegative) {\n        this.s = -this.s\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.count--\n    return /** @type {number} */ (this.s++)\n  }\n}\n\nexport class IntDiffOptRleDecoder extends Decoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    super(uint8Array)\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @return {number}\n   */\n  read () {\n    if (this.count === 0) {\n      const diff = readVarInt(this)\n      // if the first bit is set, we read more data\n      const hasCount = diff & 1\n      this.diff = diff >> 1\n      this.count = 1\n      if (hasCount) {\n        this.count = readVarUint(this) + 2\n      }\n    }\n    this.s += this.diff\n    this.count--\n    return this.s\n  }\n}\n\nexport class StringDecoder {\n  /**\n   * @param {Uint8Array} uint8Array\n   */\n  constructor (uint8Array) {\n    this.decoder = new UintOptRleDecoder(uint8Array)\n    this.str = readVarString(this.decoder)\n    /**\n     * @type {number}\n     */\n    this.spos = 0\n  }\n\n  /**\n   * @return {string}\n   */\n  read () {\n    const end = this.spos + this.decoder.read()\n    const res = this.str.slice(this.spos, end)\n    this.spos = end\n    return res\n  }\n}\n","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","/**\n * Utility helpers for working with numbers.\n *\n * @module number\n */\n\nimport * as math from './math.js'\nimport * as binary from './binary.js'\n\nexport const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER\nexport const MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER\n\nexport const LOWEST_INT32 = 1 << 31\n/**\n * @type {number}\n */\nexport const HIGHEST_INT32 = binary.BITS31\n\n/**\n * @module number\n */\n\n/* istanbul ignore next */\nexport const isInteger = Number.isInteger || (num => typeof num === 'number' && isFinite(num) && math.floor(num) === num)\nexport const isNaN = Number.isNaN\n","/**\n * Efficient schema-less binary encoding with support for variable length encoding.\n *\n * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.\n *\n * Encodes numbers in little-endian order (least to most significant byte order)\n * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)\n * which is also used in Protocol Buffers.\n *\n * ```js\n * // encoding step\n * const encoder = new encoding.createEncoder()\n * encoding.writeVarUint(encoder, 256)\n * encoding.writeVarString(encoder, 'Hello world!')\n * const buf = encoding.toUint8Array(encoder)\n * ```\n *\n * ```js\n * // decoding step\n * const decoder = new decoding.createDecoder(buf)\n * decoding.readVarUint(decoder) // => 256\n * decoding.readVarString(decoder) // => 'Hello world!'\n * decoding.hasContent(decoder) // => false - all data is read\n * ```\n *\n * @module encoding\n */\n\nimport * as buffer from './buffer.js'\nimport * as math from './math.js'\nimport * as number from './number.js'\nimport * as binary from './binary.js'\n\n/**\n * A BinaryEncoder handles the encoding to an Uint8Array.\n */\nexport class Encoder {\n  constructor () {\n    this.cpos = 0\n    this.cbuf = new Uint8Array(100)\n    /**\n     * @type {Array<Uint8Array>}\n     */\n    this.bufs = []\n  }\n}\n\n/**\n * @function\n * @return {Encoder}\n */\nexport const createEncoder = () => new Encoder()\n\n/**\n * The current length of the encoded data.\n *\n * @function\n * @param {Encoder} encoder\n * @return {number}\n */\nexport const length = encoder => {\n  let len = encoder.cpos\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    len += encoder.bufs[i].length\n  }\n  return len\n}\n\n/**\n * Transform to Uint8Array.\n *\n * @function\n * @param {Encoder} encoder\n * @return {Uint8Array} The created ArrayBuffer.\n */\nexport const toUint8Array = encoder => {\n  const uint8arr = new Uint8Array(length(encoder))\n  let curPos = 0\n  for (let i = 0; i < encoder.bufs.length; i++) {\n    const d = encoder.bufs[i]\n    uint8arr.set(d, curPos)\n    curPos += d.length\n  }\n  uint8arr.set(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos)\n  return uint8arr\n}\n\n/**\n * Verify that it is possible to write `len` bytes wtihout checking. If\n * necessary, a new Buffer with the required length is attached.\n *\n * @param {Encoder} encoder\n * @param {number} len\n */\nconst verifyLen = (encoder, len) => {\n  const bufferLen = encoder.cbuf.length\n  if (bufferLen - encoder.cpos < len) {\n    encoder.bufs.push(buffer.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos))\n    encoder.cbuf = new Uint8Array(math.max(bufferLen, len) * 2)\n    encoder.cpos = 0\n  }\n}\n\n/**\n * Write one byte to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The byte that is to be encoded.\n */\nexport const write = (encoder, num) => {\n  const bufferLen = encoder.cbuf.length\n  if (encoder.cpos === bufferLen) {\n    encoder.bufs.push(encoder.cbuf)\n    encoder.cbuf = new Uint8Array(bufferLen * 2)\n    encoder.cpos = 0\n  }\n  encoder.cbuf[encoder.cpos++] = num\n}\n\n/**\n * Write one byte at a specific position.\n * Position must already be written (i.e. encoder.length > pos)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos Position to which to write data\n * @param {number} num Unsigned 8-bit integer\n */\nexport const set = (encoder, pos, num) => {\n  let buffer = null\n  // iterate all buffers and adjust position\n  for (let i = 0; i < encoder.bufs.length && buffer === null; i++) {\n    const b = encoder.bufs[i]\n    if (pos < b.length) {\n      buffer = b // found buffer\n    } else {\n      pos -= b.length\n    }\n  }\n  if (buffer === null) {\n    // use current buffer\n    buffer = encoder.cbuf\n  }\n  buffer[pos] = num\n}\n\n/**\n * Write one byte as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint8 = write\n\n/**\n * Write one byte as an unsigned Integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint8 = set\n\n/**\n * Write two bytes as an unsigned integer.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint16 = (encoder, num) => {\n  write(encoder, num & binary.BITS8)\n  write(encoder, (num >>> 8) & binary.BITS8)\n}\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint16 = (encoder, pos, num) => {\n  set(encoder, pos, num & binary.BITS8)\n  set(encoder, pos + 1, (num >>> 8) & binary.BITS8)\n}\n\n/**\n * Write two bytes as an unsigned integer\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32 = (encoder, num) => {\n  for (let i = 0; i < 4; i++) {\n    write(encoder, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer in big endian order.\n * (most significant byte first)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeUint32BigEndian = (encoder, num) => {\n  for (let i = 3; i >= 0; i--) {\n    write(encoder, (num >>> (8 * i)) & binary.BITS8)\n  }\n}\n\n/**\n * Write two bytes as an unsigned integer at a specific location.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} pos The location where the data will be written.\n * @param {number} num The number that is to be encoded.\n */\nexport const setUint32 = (encoder, pos, num) => {\n  for (let i = 0; i < 4; i++) {\n    set(encoder, pos + i, num & binary.BITS8)\n    num >>>= 8\n  }\n}\n\n/**\n * Write a variable length unsigned integer.\n *\n * Encodes integers in the range from [0, 4294967295] / [0, 0xffffffff]. (max 32 bit unsigned integer)\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarUint = (encoder, num) => {\n  while (num > binary.BITS7) {\n    write(encoder, binary.BIT8 | (binary.BITS7 & num))\n    num >>>= 7\n  }\n  write(encoder, binary.BITS7 & num)\n}\n\n/**\n * Write a variable length integer.\n *\n * Encodes integers in the range from [-2147483648, -2147483647].\n *\n * We don't use zig-zag encoding because we want to keep the option open\n * to use the same function for BigInt and 53bit integers (doubles).\n *\n * We use the 7th bit instead for signaling that this is a negative number.\n *\n * @function\n * @param {Encoder} encoder\n * @param {number} num The number that is to be encoded.\n */\nexport const writeVarInt = (encoder, num) => {\n  const isNegative = math.isNegativeZero(num)\n  if (isNegative) {\n    num = -num\n  }\n  //             |- whether to continue reading         |- whether is negative     |- number\n  write(encoder, (num > binary.BITS6 ? binary.BIT8 : 0) | (isNegative ? binary.BIT7 : 0) | (binary.BITS6 & num))\n  num >>>= 6\n  // We don't need to consider the case of num === 0 so we can use a different\n  // pattern here than above.\n  while (num > 0) {\n    write(encoder, (num > binary.BITS7 ? binary.BIT8 : 0) | (binary.BITS7 & num))\n    num >>>= 7\n  }\n}\n\n/**\n * Write a variable length string.\n *\n * @function\n * @param {Encoder} encoder\n * @param {String} str The string that is to be encoded.\n */\nexport const writeVarString = (encoder, str) => {\n  const encodedString = unescape(encodeURIComponent(str))\n  const len = encodedString.length\n  writeVarUint(encoder, len)\n  for (let i = 0; i < len; i++) {\n    write(encoder, /** @type {number} */ (encodedString.codePointAt(i)))\n  }\n}\n\n/**\n * Write the content of another Encoder.\n *\n * @TODO: can be improved!\n *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.\n *                Encoders start with a rather big initial buffer.\n *\n * @function\n * @param {Encoder} encoder The enUint8Arr\n * @param {Encoder} append The BinaryEncoder to be written.\n */\nexport const writeBinaryEncoder = (encoder, append) => writeUint8Array(encoder, toUint8Array(append))\n\n/**\n * Append fixed-length Uint8Array to the encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeUint8Array = (encoder, uint8Array) => {\n  const bufferLen = encoder.cbuf.length\n  const cpos = encoder.cpos\n  const leftCopyLen = math.min(bufferLen - cpos, uint8Array.length)\n  const rightCopyLen = uint8Array.length - leftCopyLen\n  encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos)\n  encoder.cpos += leftCopyLen\n  if (rightCopyLen > 0) {\n    // Still something to write, write right half..\n    // Append new buffer\n    encoder.bufs.push(encoder.cbuf)\n    // must have at least size of remaining buffer\n    encoder.cbuf = new Uint8Array(math.max(bufferLen * 2, rightCopyLen))\n    // copy array\n    encoder.cbuf.set(uint8Array.subarray(leftCopyLen))\n    encoder.cpos = rightCopyLen\n  }\n}\n\n/**\n * Append an Uint8Array to Encoder.\n *\n * @function\n * @param {Encoder} encoder\n * @param {Uint8Array} uint8Array\n */\nexport const writeVarUint8Array = (encoder, uint8Array) => {\n  writeVarUint(encoder, uint8Array.byteLength)\n  writeUint8Array(encoder, uint8Array)\n}\n\n/**\n * Create an DataView of the next `len` bytes. Use it to write data after\n * calling this function.\n *\n * ```js\n * // write float32 using DataView\n * const dv = writeOnDataView(encoder, 4)\n * dv.setFloat32(0, 1.1)\n * // read float32 using DataView\n * const dv = readFromDataView(encoder, 4)\n * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)\n * ```\n *\n * @param {Encoder} encoder\n * @param {number} len\n * @return {DataView}\n */\nexport const writeOnDataView = (encoder, len) => {\n  verifyLen(encoder, len)\n  const dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len)\n  encoder.cpos += len\n  return dview\n}\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat32 = (encoder, num) => writeOnDataView(encoder, 4).setFloat32(0, num)\n\n/**\n * @param {Encoder} encoder\n * @param {number} num\n */\nexport const writeFloat64 = (encoder, num) => writeOnDataView(encoder, 8).setFloat64(0, num)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigInt64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigInt64(0, num)\n\n/**\n * @param {Encoder} encoder\n * @param {bigint} num\n */\nexport const writeBigUint64 = (encoder, num) => /** @type {any} */ (writeOnDataView(encoder, 8)).setBigUint64(0, num)\n\nconst floatTestBed = new DataView(new ArrayBuffer(4))\n/**\n * Check if a number can be encoded as a 32 bit float.\n *\n * @param {number} num\n * @return {boolean}\n */\nconst isFloat32 = num => {\n  floatTestBed.setFloat32(0, num)\n  return floatTestBed.getFloat32(0) === num\n}\n\n/**\n * Encode data with efficient binary format.\n *\n * Differences to JSON:\n *  Transforms data to a binary format (not to a string)\n *  Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)\n *  Numbers are efficiently encoded either as a variable length integer, as a\n *   32 bit float, as a 64 bit float, or as a 64 bit bigint.\n *\n * Encoding table:\n *\n * | Data Type           | Prefix   | Encoding Method    | Comment |\n * | ------------------- | -------- | ------------------ | ------- |\n * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |\n * | null                | 126      |                    | |\n * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |\n * | float32             | 124      | writeFloat32       | |\n * | float64             | 123      | writeFloat64       | |\n * | bigint              | 122      | writeBigInt64      | |\n * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |\n * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |\n * | string              | 119      | writeVarString     | |\n * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |\n * | array<any>          | 117      | custom             | Writes {length} then {length} json values |\n * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |\n *\n * Reasons for the decreasing prefix:\n * We need the first bit for extendability (later we may want to encode the\n * prefix with writeVarUint). The remaining 7 bits are divided as follows:\n * [0-30]   the beginning of the data range is used for custom purposes\n *          (defined by the function that uses this library)\n * [31-127] the end of the data range is used for data encoding by\n *          lib0/encoding.js\n *\n * @param {Encoder} encoder\n * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data\n */\nexport const writeAny = (encoder, data) => {\n  switch (typeof data) {\n    case 'string':\n      // TYPE 119: STRING\n      write(encoder, 119)\n      writeVarString(encoder, data)\n      break\n    case 'number':\n      if (number.isInteger(data) && data <= binary.BITS31) {\n        // TYPE 125: INTEGER\n        write(encoder, 125)\n        writeVarInt(encoder, data)\n      } else if (isFloat32(data)) {\n        // TYPE 124: FLOAT32\n        write(encoder, 124)\n        writeFloat32(encoder, data)\n      } else {\n        // TYPE 123: FLOAT64\n        write(encoder, 123)\n        writeFloat64(encoder, data)\n      }\n      break\n    case 'bigint':\n      // TYPE 122: BigInt\n      write(encoder, 122)\n      writeBigInt64(encoder, data)\n      break\n    case 'object':\n      if (data === null) {\n        // TYPE 126: null\n        write(encoder, 126)\n      } else if (data instanceof Array) {\n        // TYPE 117: Array\n        write(encoder, 117)\n        writeVarUint(encoder, data.length)\n        for (let i = 0; i < data.length; i++) {\n          writeAny(encoder, data[i])\n        }\n      } else if (data instanceof Uint8Array) {\n        // TYPE 116: ArrayBuffer\n        write(encoder, 116)\n        writeVarUint8Array(encoder, data)\n      } else {\n        // TYPE 118: Object\n        write(encoder, 118)\n        const keys = Object.keys(data)\n        writeVarUint(encoder, keys.length)\n        for (let i = 0; i < keys.length; i++) {\n          const key = keys[i]\n          writeVarString(encoder, key)\n          writeAny(encoder, data[key])\n        }\n      }\n      break\n    case 'boolean':\n      // TYPE 120/121: boolean (true/false)\n      write(encoder, data ? 120 : 121)\n      break\n    default:\n      // TYPE 127: undefined\n      write(encoder, 127)\n  }\n}\n\n/**\n * Now come a few stateful encoder that have their own classes.\n */\n\n/**\n * Basic Run Length Encoder - a basic compression implementation.\n *\n * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.\n *\n * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf\n *\n * @note T must not be null!\n *\n * @template T\n */\nexport class RleEncoder extends Encoder {\n  /**\n   * @param {function(Encoder, T):void} writer\n   */\n  constructor (writer) {\n    super()\n    /**\n     * The writer\n     */\n    this.w = writer\n    /**\n     * Current state\n     * @type {T|null}\n     */\n    this.s = null\n    this.count = 0\n  }\n\n  /**\n   * @param {T} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      this.w(this, v)\n      this.s = v\n    }\n  }\n}\n\n/**\n * Basic diff decoder using variable length encoding.\n *\n * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.\n */\nexport class IntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    writeVarInt(this, v - this.s)\n    this.s = v\n  }\n}\n\n/**\n * A combination of IntDiffEncoder and RleEncoder.\n *\n * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.\n *\n * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1])  RleIntDiff[1,1,0,2,1,5])\n */\nexport class RleIntDiffEncoder extends Encoder {\n  /**\n   * @param {number} start\n   */\n  constructor (start) {\n    super()\n    /**\n     * Current state\n     * @type {number}\n     */\n    this.s = start\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v && this.count > 0) {\n      this.count++\n    } else {\n      if (this.count > 0) {\n        // flush counter, unless this is the first value (count = 0)\n        writeVarUint(this, this.count - 1) // since count is always > 0, we can decrement by one. non-standard encoding ftw\n      }\n      this.count = 1\n      // write first value\n      writeVarInt(this, v - this.s)\n      this.s = v\n    }\n  }\n}\n\n/**\n * @param {UintOptRleEncoder} encoder\n */\nconst flushUintOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set sign to positive\n    // case 2: write several values. set sign to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.\n *\n * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write\n * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.\n *\n * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)\n */\nexport class UintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Increasing Uint Optimized RLE Encoder\n *\n * The RLE encoder counts the number of same occurences of the same value.\n * The IncUintOptRle encoder counts if the value increases.\n * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded\n * as [1, 3, 5].\n */\nexport class IncUintOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.s + this.count === v) {\n      this.count++\n    } else {\n      flushUintOptRleEncoder(this)\n      this.count = 1\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushUintOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * @param {IntDiffOptRleEncoder} encoder\n */\nconst flushIntDiffOptRleEncoder = encoder => {\n  if (encoder.count > 0) {\n    //          31 bit making up the diff | wether to write the counter\n    const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)\n    // flush counter, unless this is the first value (count = 0)\n    // case 1: just a single value. set first bit to positive\n    // case 2: write several values. set first bit to negative to indicate that there is a length coming\n    writeVarInt(encoder.encoder, encodedDiff)\n    if (encoder.count > 1) {\n      writeVarUint(encoder.encoder, encoder.count - 2) // since count is always > 1, we can decrement by one. non-standard encoding ftw\n    }\n  }\n}\n\n/**\n * A combination of the IntDiffEncoder and the UintOptRleEncoder.\n *\n * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes\n * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!\n *\n * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])\n *\n * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:\n * * 1 bit that denotes whether the next value is a count (LSB)\n * * 1 bit that denotes whether this value is negative (MSB - 1)\n * * 1 bit that denotes whether to continue reading the variable length integer (MSB)\n *\n * Therefore, only five bits remain to encode diff ranges.\n *\n * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.\n */\nexport class IntDiffOptRleEncoder {\n  constructor () {\n    this.encoder = new Encoder()\n    /**\n     * @type {number}\n     */\n    this.s = 0\n    this.count = 0\n    this.diff = 0\n  }\n\n  /**\n   * @param {number} v\n   */\n  write (v) {\n    if (this.diff === v - this.s) {\n      this.s = v\n      this.count++\n    } else {\n      flushIntDiffOptRleEncoder(this)\n      this.count = 1\n      this.diff = v - this.s\n      this.s = v\n    }\n  }\n\n  toUint8Array () {\n    flushIntDiffOptRleEncoder(this)\n    return toUint8Array(this.encoder)\n  }\n}\n\n/**\n * Optimized String Encoder.\n *\n * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.\n * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).\n *\n * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.\n *\n * The lengths are encoded using a UintOptRleEncoder.\n */\nexport class StringEncoder {\n  constructor () {\n    /**\n     * @type {Array<string>}\n     */\n    this.sarr = []\n    this.s = ''\n    this.lensE = new UintOptRleEncoder()\n  }\n\n  /**\n   * @param {string} string\n   */\n  write (string) {\n    this.s += string\n    if (this.s.length > 19) {\n      this.sarr.push(this.s)\n      this.s = ''\n    }\n    this.lensE.write(string.length)\n  }\n\n  toUint8Array () {\n    const encoder = new Encoder()\n    this.sarr.push(this.s)\n    this.s = ''\n    writeVarString(encoder, this.sarr.join(''))\n    writeUint8Array(encoder, this.lensE.toUint8Array())\n    return toUint8Array(encoder)\n  }\n}\n","/**\n * Often used conditions.\n *\n * @module conditions\n */\n\n/**\n * @template T\n * @param {T|null|undefined} v\n * @return {T|null}\n */\n/* istanbul ignore next */\nexport const undefinedToNull = v => v === undefined ? null : v\n","/* global localStorage */\n\n/**\n * Isomorphic variable storage.\n *\n * Uses LocalStorage in the browser and falls back to in-memory storage.\n *\n * @module storage\n */\n\n/* istanbul ignore next */\nclass VarStoragePolyfill {\n  constructor () {\n    this.map = new Map()\n  }\n\n  /**\n   * @param {string} key\n   * @param {any} value\n   */\n  setItem (key, value) {\n    this.map.set(key, value)\n  }\n\n  /**\n   * @param {string} key\n   */\n  getItem (key) {\n    return this.map.get(key)\n  }\n}\n\n/* istanbul ignore next */\n/**\n * @type {any}\n */\nlet _localStorage = new VarStoragePolyfill()\n\ntry {\n  // if the same-origin rule is violated, accessing localStorage might thrown an error\n  /* istanbul ignore next */\n  if (typeof localStorage !== 'undefined') {\n    _localStorage = localStorage\n  }\n} catch (e) { }\n\n/* istanbul ignore next */\n/**\n * This is basically localStorage in browser, or a polyfill in nodejs\n */\nexport const varStorage = _localStorage\n","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');\n\nfunction emptyFunction() {}\nfunction emptyFunctionWithReset() {}\nemptyFunctionWithReset.resetWarningCache = emptyFunction;\n\nmodule.exports = function() {\n  function shim(props, propName, componentName, location, propFullName, secret) {\n    if (secret === ReactPropTypesSecret) {\n      // It is still safe when called from React.\n      return;\n    }\n    var err = new Error(\n      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +\n      'Use PropTypes.checkPropTypes() to call them. ' +\n      'Read more at http://fb.me/use-check-prop-types'\n    );\n    err.name = 'Invariant Violation';\n    throw err;\n  };\n  shim.isRequired = shim;\n  function getShim() {\n    return shim;\n  };\n  // Important!\n  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.\n  var ReactPropTypes = {\n    array: shim,\n    bool: shim,\n    func: shim,\n    number: shim,\n    object: shim,\n    string: shim,\n    symbol: shim,\n\n    any: shim,\n    arrayOf: getShim,\n    element: shim,\n    elementType: shim,\n    instanceOf: getShim,\n    node: shim,\n    objectOf: getShim,\n    oneOf: getShim,\n    oneOfType: getShim,\n    shape: getShim,\n    exact: getShim,\n\n    checkPropTypes: emptyFunctionWithReset,\n    resetWarningCache: emptyFunction\n  };\n\n  ReactPropTypes.PropTypes = ReactPropTypes;\n\n  return ReactPropTypes;\n};\n","/**\n * Copyright (c) 2013-present, Facebook, Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nvar ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';\n\nmodule.exports = ReactPropTypesSecret;\n"],"sourceRoot":""}