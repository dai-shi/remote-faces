{"version":3,"sources":["components/ErrorFallback.tsx","components/SuspenseFallback.tsx","components/SingleRoomEntrance.tsx","components/GitHubCorner.tsx","components/App.tsx","serviceWorker.ts","index.tsx","network/common.ts","network/peerjsUtils.ts","network/trackUtils.ts","network/peerjsRoom.ts","network/ipfsUtils.ts","network/ipfsRoom.ts","network/room.ts","../../node_modules/peerjs/dist sync","utils/sleep.ts","utils/crypto.ts","utils/types.ts","utils/url.ts"],"names":["ErrorFallback","React","memo","err","useState","waitSec","setWaitSec","useEffect","setTimeout","window","location","reload","name","message","SuspenseFallback","className","Landing","lazy","SingleRoom","roomIdFromUrl","getRoomIdFromUrl","userId","secureRandomId","SingleRoomEntrance","roomId","setRoomId","linkShown","setLinkShown","linkText","setLinkText","onCreateNew","a","ROOM_ID_PREFIX_LEN","generateCryptoKey","type","onClick","value","onChange","e","target","placeholder","copyHashFromLink","extractRoomIdFromLink","disabled","GitHubCorner","size","fill","color","href","aria-label","rel","width","height","viewBox","style","position","top","border","right","aria-hidden","d","transformOrigin","ErrorBoundary","state","children","this","props","PureComponent","App","fallback","Boolean","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","console","generatePeerId","peerIndex","slice","getPeerIndexFromPeerId","peerId","Number","split","getPeerIndexFromConn","conn","peer","setupMap","WeakMap","setupTrackStopOnLongMute","track","pc","has","set","onmute","sleep","transceiver","getTransceivers","find","t","receiver","currentDirection","stop","dispatchEvent","Event","addEventListener","guessSeed","id","createRoom","updateNetworkStatus","notifyNewPeer","receiveData","receiveTrack","disposed","myPeer","connMap","map","Map","addConn","get","close","mediaTypes","markConnected","connected","isConnected","setUserId","getUserId","setMediaTypes","getMediaTypes","hasConn","getConn","delConn","delete","getConnectedPeerIds","Array","from","keys","filter","k","forEachConnectedConns","callback","values","forEach","forEachConnsAcceptingMedia","mediaType","includes","clearAll","log","clear","createConnectionMap","localStream","showConnectedStatus","peerIndexList","connectPeer","disconnected","connect","initConnection","broadcastData","data","peers","sendPayload","sendSDP","sdp","SDP","handlePayloadSDP","isObject","offer","peerConnection","setRemoteDescription","syncAllTracks","createAnswer","answer","setLocalDescription","info","Math","random","removeAllTracks","warn","handlePayloadUserId","payloadUserId","handlePayloadMediaTypes","payloadMediaTypes","isArray","every","x","handlePayloadPeers","startsWith","isValidPeerId","handlePayloadData","connUserId","handlePayload","encrypted","JSON","decrypt","payload","parse","encrypt","stringify","send","scheduledNegotiation","on","buf","iceGatheringState","onicecandidate","createOffer","event","length","reInitMyPeer","floor","initMyPeer","index","isSeed","rand4","Peer","getPeerJsConfigFromUrl","i","seedId","destroy","destroyed","reconnect","force","existsAllSeeds","oldPeer","trackMediaTypeMap","senders","getSenders","mTypes","getTracks","mType","sender","addTrack","removeTrack","some","transport","sendData","acceptMediaTypes","MediaStream","getReceivers","readyState","s","dispose","peerIndexCounter","DEFAULT_CONFIG","iceServers","urls","username","credential","sdpSemantics","myIpfs","myPeerId","Error","sendPc","RTCPeerConnection","recvPc","findConn","v","getPeerIndexList","forEachConns","roomTopic","parsePayload","undefined","topic","byteLength","pubsub","publish","to","handlePayloadIceCandidate","iceCandidate","addIceCandidate","evt","candidate","sendIceCandidate","getToFromPayload","Object","payloadTo","getUserIdFromPayload","pubsubHandler","msg","checkPeers","prevConnMapSize","prevIpfs","closeIpfs","initIpfs","Ipfs","create","repo","config","Addresses","Swarm","ipfs","subscribe","unsubscribe","hasPeerJsConfigInUrl","peerjsCreateRoom","ipfsCreateRoom","webpackEmptyContext","req","code","resolve","module","exports","ms","Promise","len","crypto","getRandomValues","Uint8Array","arr","hex","b","toString","padStart","join","Uint16Array","subtle","generateKey","key","exportKey","importCryptoKey","usages","parseInt","importKey","cryptoKey","encoder","TextEncoder","encoded","encode","compressed","pako","deflate","iv","decrypted","decompressed","inflate","decoder","TextDecoder","decode","link","srcHash","URL","hash","srcSearchParams","URLSearchParams","dstHash","dstSearchParams","setRoomIdToUrl","searchParams","server","url","secure","protocol","defaultPort","host","port","path","pathname"],"mappings":"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","file":"static/js/main.652d8472.chunk.js","sourcesContent":["import React, { useEffect, useState } from \"react\";\n\nexport const ErrorFallback = React.memo<{\n  err: Error;\n}>(({ err }) => {\n  const [waitSec, setWaitSec] = useState(30);\n\n  useEffect(() => {\n    if (waitSec > 0) {\n      setTimeout(() => {\n        setWaitSec(waitSec - 1);\n      }, 1000);\n    } else {\n      window.location.reload();\n    }\n  });\n\n  return (\n    <div>\n      <h1>Unrecoverable error occurred.</h1>\n      {err && (\n        <h6>\n          {err.name}: {err.message}\n        </h6>\n      )}\n      <p>Will auto reload in {waitSec} sec.</p>\n    </div>\n  );\n});\n","import React from \"react\";\n\nimport \"./SuspenseFallback.css\";\n\nexport const SuspenseFallback = React.memo(() => (\n  <div className=\"Loading-container\">\n    <div>Loading...</div>\n  </div>\n));\n","import React, { useState } from \"react\";\n\nimport \"./SingleRoomEntrance.css\";\nimport { secureRandomId, generateCryptoKey } from \"../utils/crypto\";\nimport { ROOM_ID_PREFIX_LEN } from \"../network/room\";\nimport {\n  getRoomIdFromUrl,\n  extractRoomIdFromLink,\n  copyHashFromLink,\n} from \"../utils/url\";\n\nconst Landing = React.lazy(() => import(\"./Landing\"));\nconst SingleRoom = React.lazy(() => import(\"./SingleRoom\"));\n\nconst roomIdFromUrl = getRoomIdFromUrl();\nconst userId = secureRandomId();\n\nexport const SingleRoomEntrance = React.memo(() => {\n  const [roomId, setRoomId] = useState<string | null>(roomIdFromUrl);\n  const [linkShown, setLinkShown] = useState(false);\n  const [linkText, setLinkText] = useState(\"\");\n\n  const onCreateNew = async () => {\n    setRoomId(\n      secureRandomId(ROOM_ID_PREFIX_LEN / 2) + (await generateCryptoKey())\n    );\n  };\n\n  const onEnter = () => {\n    copyHashFromLink(linkText);\n    setRoomId(extractRoomIdFromLink(linkText));\n  };\n\n  if (roomId) {\n    return <SingleRoom roomId={roomId} userId={userId} />;\n  }\n\n  return (\n    <div className=\"SingleRoomEntrance-container\">\n      <Landing>\n        <div className=\"SingleRoomEntrance-input\">\n          {!linkShown && (\n            <>\n              <div>\n                <button type=\"button\" onClick={onCreateNew}>\n                  Create a new room\n                </button>\n              </div>\n              <div className=\"SingleRoomEntrance-or\">OR</div>\n              <div>\n                <button type=\"button\" onClick={() => setLinkShown(true)}>\n                  Enter an existing room link\n                </button>\n              </div>\n            </>\n          )}\n          {linkShown && (\n            <div>\n              <input\n                value={linkText}\n                onChange={(e) => setLinkText(e.target.value)}\n                placeholder=\"Enter room link...\"\n              />\n              <button\n                type=\"button\"\n                onClick={onEnter}\n                disabled={!extractRoomIdFromLink(linkText)}\n              >\n                Enter room\n              </button>\n              <button type=\"button\" onClick={() => setLinkShown(false)}>\n                Cancel\n              </button>\n            </div>\n          )}\n        </div>\n      </Landing>\n    </div>\n  );\n});\n","import React from \"react\";\n\nimport \"./GitHubCorner.css\";\n\n// http://tholman.com/github-corners/\nexport const GitHubCorner = React.memo<{\n  size?: number;\n  fill?: string;\n  color?: string;\n}>(({ size, fill, color }) => (\n  <a\n    href=\"https://github.com/dai-shi/remote-faces\"\n    className=\"GitHubCorner-container\"\n    aria-label=\"View source on GitHub\"\n    target=\"_blank\"\n    rel=\"noopener noreferrer\"\n  >\n    <svg\n      width={size || 80}\n      height={size || 80}\n      viewBox=\"0 0 250 250\"\n      style={{\n        fill: fill || \"#151513\",\n        color: color || \"#fff\",\n        position: \"absolute\",\n        top: 0,\n        border: 0,\n        right: 0,\n      }}\n      aria-hidden=\"true\"\n    >\n      <path d=\"M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z\" />\n      <path\n        d=\"M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2\"\n        fill=\"currentColor\"\n        style={{ transformOrigin: \"130px 106px\" }}\n        className=\"GitHubCorner-octo-arm\"\n      />\n      <path\n        d=\"M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z\"\n        fill=\"currentColor\"\n        className=\"GitHubCorner-octo-body\"\n      />\n    </svg>\n  </a>\n));\n","import React, { Suspense } from \"react\";\n\nimport \"./App.css\";\nimport { ErrorFallback } from \"./ErrorFallback\";\nimport { SuspenseFallback } from \"./SuspenseFallback\";\nimport { SingleRoomEntrance } from \"./SingleRoomEntrance\";\nimport { GitHubCorner } from \"./GitHubCorner\";\n\nclass ErrorBoundary extends React.PureComponent {\n  state: { err?: Error } = {};\n\n  static getDerivedStateFromError(err: Error) {\n    return { err };\n  }\n\n  render() {\n    const { children } = this.props;\n    const { err } = this.state;\n    if (err) return <ErrorFallback err={err} />;\n    return children;\n  }\n}\n\nexport const App = React.memo(() => (\n  <div className=\"App\">\n    <ErrorBoundary>\n      <Suspense fallback={<SuspenseFallback />}>\n        <SingleRoomEntrance />\n        <GitHubCorner size={40} fill=\"gray\" />\n      </Suspense>\n    </ErrorBoundary>\n  </div>\n));\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport { App } from \"./components/App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","export const ROOM_ID_PREFIX_LEN = 32;\n\nexport type NetworkStatus =\n  | { type: \"CONNECTING_SEED_PEERS\" }\n  | { type: \"NEW_CONNECTION\"; peerIndex: number }\n  | { type: \"CONNECTION_CLOSED\"; peerIndex: number }\n  | { type: \"INITIALIZING_PEER\"; peerIndex: number }\n  | { type: \"RECONNECTING\" }\n  | { type: \"SERVER_ERROR\" }\n  | { type: \"UNKNOWN_ERROR\"; err: Error }\n  | { type: \"CONNECTED_PEERS\"; peerIndexList: number[] };\n\ntype UpdateNetworkStatus = (status: NetworkStatus) => void;\n\nexport type PeerInfo = {\n  userId: string;\n  peerIndex: number;\n  mediaTypes: string[];\n};\ntype NotifyNewPeer = (peerIndex: number) => void;\ntype ReceiveData = (data: unknown, info: PeerInfo) => void;\ntype ReceiveTrack = (track: MediaStreamTrack, info: PeerInfo) => void;\n\nexport type CreateRoom = (\n  roomId: string,\n  userId: string,\n  updateNetworkStatus: UpdateNetworkStatus,\n  notifyNewPeer: NotifyNewPeer,\n  receiveData: ReceiveData,\n  receiveTrack: ReceiveTrack\n) => {\n  broadcastData: (data: unknown) => void;\n  sendData: (data: unknown, peerIndex: number) => void;\n  acceptMediaTypes: (mediaTypes: string[]) => void;\n  addTrack: (mediaType: string, track: MediaStreamTrack) => void;\n  removeTrack: (mediaType: string, track: MediaStreamTrack) => void;\n  dispose: () => void;\n};\n","import Peer from \"peerjs\";\n\nimport { ROOM_ID_PREFIX_LEN } from \"./common\";\n\nexport const isValidPeerId = (\n  roomId: string,\n  peerId: unknown\n): peerId is string =>\n  typeof peerId === \"string\" &&\n  peerId.startsWith(`${roomId.slice(0, ROOM_ID_PREFIX_LEN)} `);\n\nexport const generatePeerId = (roomId: string, peerIndex: number) =>\n  `${roomId.slice(0, ROOM_ID_PREFIX_LEN)} ${peerIndex}`;\n\nexport const getPeerIndexFromPeerId = (peerId: string) =>\n  Number(peerId.split(\" \")[1]);\n\nexport const getPeerIndexFromConn = (conn: Peer.DataConnection) =>\n  getPeerIndexFromPeerId(conn.peer);\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Peer.DataConnection;\n    connected?: boolean;\n    userId?: string;\n    mediaTypes: string[];\n  };\n  const map = new Map<string, Value>();\n\n  const addConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.conn.close();\n    }\n    map.set(conn.peer, { conn, mediaTypes: [] });\n  };\n\n  const markConnected = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.connected = true;\n    }\n  };\n\n  const isConnected = (peerId: string) => {\n    const value = map.get(peerId);\n    return (value && value.connected) || false;\n  };\n\n  const setUserId = (conn: Peer.DataConnection, userId: string) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.userId = userId;\n    }\n  };\n\n  const getUserId = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    return value && value.userId;\n  };\n\n  const setMediaTypes = (conn: Peer.DataConnection, mediaTypes: string[]) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.mediaTypes = mediaTypes;\n    }\n  };\n\n  const getMediaTypes = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    return (value && value.mediaTypes) || [];\n  };\n\n  const hasConn = (peerId: string) => map.has(peerId);\n\n  const getConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return null;\n    return value.conn;\n  };\n\n  const delConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n    }\n  };\n\n  const getConnectedPeerIds = () =>\n    Array.from(map.keys()).filter((k) => map.get(k)?.connected);\n\n  const forEachConnectedConns = (\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.connected) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const forEachConnsAcceptingMedia = (\n    mediaType: string,\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (\n        value.connected &&\n        value.mediaTypes &&\n        value.mediaTypes.includes(mediaType)\n      ) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const clearAll = () => {\n    if (map.size) {\n      console.log(\"connectionMap garbage:\", map);\n    }\n    map.clear();\n  };\n\n  return {\n    addConn,\n    markConnected,\n    isConnected,\n    setUserId,\n    getUserId,\n    setMediaTypes,\n    getMediaTypes,\n    hasConn,\n    getConn,\n    delConn,\n    getConnectedPeerIds,\n    forEachConnectedConns,\n    forEachConnsAcceptingMedia,\n    clearAll,\n  };\n};\n","import { sleep } from \"../utils/sleep\";\n\nconst setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = async () => {\n    await sleep(5000);\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    }\n  };\n  track.addEventListener(\"mute\", onmute);\n  return track;\n};\n","import Peer from \"peerjs\";\n\nimport { sleep } from \"../utils/sleep\";\nimport { rand4, encrypt, decrypt } from \"../utils/crypto\";\nimport { getPeerJsConfigFromUrl } from \"../utils/url\";\nimport { isObject } from \"../utils/types\";\nimport { ROOM_ID_PREFIX_LEN, PeerInfo, CreateRoom } from \"./common\";\nimport {\n  isValidPeerId,\n  generatePeerId,\n  getPeerIndexFromPeerId,\n  getPeerIndexFromConn,\n  createConnectionMap,\n} from \"./peerjsUtils\";\nimport { setupTrackStopOnLongMute } from \"./trackUtils\";\n\nconst MIN_SEED_PEER_INDEX = 10; // config\nconst MAX_SEED_PEER_INDEX = 14; // config\nconst guessSeed = (id: string) => {\n  const peerIndex = getPeerIndexFromPeerId(id);\n  return MIN_SEED_PEER_INDEX <= peerIndex && peerIndex <= MAX_SEED_PEER_INDEX;\n};\n\nexport const createRoom: CreateRoom = (\n  roomId,\n  userId,\n  updateNetworkStatus,\n  notifyNewPeer,\n  receiveData,\n  receiveTrack\n) => {\n  let disposed = false;\n  let myPeer: Peer | null = null;\n  const connMap = createConnectionMap();\n  let mediaTypes: string[] = [];\n  let localStream: MediaStream | null = null;\n\n  const showConnectedStatus = () => {\n    if (disposed) return;\n    const peerIndexList = connMap\n      .getConnectedPeerIds()\n      .map(getPeerIndexFromPeerId);\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const connectPeer = (id: string) => {\n    if (disposed) return;\n    if (!myPeer || myPeer.id === id || myPeer.disconnected) return;\n    if (connMap.hasConn(id)) return;\n    console.log(\"connectPeer\", id);\n    const conn = myPeer.connect(id);\n    initConnection(conn);\n  };\n\n  const broadcastData = (data: unknown) => {\n    if (disposed) return;\n    const peers = connMap.getConnectedPeerIds();\n    connMap.forEachConnectedConns((conn) => {\n      sendPayload(conn, { userId, data, peers, mediaTypes });\n    });\n  };\n\n  const sendData = (data: unknown, peerIndex: number) => {\n    if (disposed) return;\n    const conn = connMap.getConn(generatePeerId(roomId, peerIndex));\n    if (!conn) return;\n    const peers = connMap.getConnectedPeerIds();\n    sendPayload(conn, { userId, data, peers, mediaTypes });\n  };\n\n  const sendSDP = (conn: Peer.DataConnection, sdp: unknown) => {\n    sendPayload(conn, { SDP: sdp });\n  };\n\n  const handlePayloadSDP = async (conn: Peer.DataConnection, sdp: unknown) => {\n    if (!isObject(sdp)) return;\n    if (isObject((sdp as { offer: unknown }).offer)) {\n      const { offer } = sdp as { offer: object };\n      try {\n        await conn.peerConnection.setRemoteDescription(offer as any);\n        syncAllTracks(conn);\n        const answer = await conn.peerConnection.createAnswer();\n        await conn.peerConnection.setLocalDescription(answer);\n        sendSDP(conn, { answer });\n      } catch (e) {\n        console.info(\"handleSDP offer failed\", e);\n      }\n    } else if (isObject((sdp as { answer: unknown }).answer)) {\n      const { answer } = sdp as { answer: object };\n      try {\n        await conn.peerConnection.setRemoteDescription(answer as any);\n      } catch (e) {\n        console.info(\"handleSDP answer failed\", e);\n        await sleep(Math.random() * 30 * 1000);\n        removeAllTracks(conn);\n        syncAllTracks(conn);\n      }\n    } else {\n      console.warn(\"unknown SDP\", sdp);\n    }\n  };\n\n  const handlePayloadUserId = (\n    conn: Peer.DataConnection,\n    payloadUserId: unknown\n  ) => {\n    if (typeof payloadUserId === \"string\") {\n      connMap.setUserId(conn, payloadUserId);\n    }\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Peer.DataConnection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setMediaTypes(conn, payloadMediaTypes as string[]);\n      await sleep(5000);\n      syncAllTracks(conn);\n    }\n  };\n\n  const handlePayloadPeers = (peers: unknown) => {\n    if (Array.isArray(peers)) {\n      peers.forEach((peer) => {\n        if (isValidPeerId(roomId, peer)) {\n          connectPeer(peer);\n        }\n      });\n    }\n  };\n\n  const handlePayloadData = (conn: Peer.DataConnection, data: unknown) => {\n    const connUserId = connMap.getUserId(conn);\n    if (connUserId) {\n      const info: PeerInfo = {\n        userId: connUserId,\n        peerIndex: getPeerIndexFromConn(conn),\n        mediaTypes: connMap.getMediaTypes(conn),\n      };\n      try {\n        receiveData(data, info);\n      } catch (e) {\n        console.warn(\"receiveData\", e);\n      }\n    }\n  };\n\n  const handlePayload = async (\n    conn: Peer.DataConnection,\n    encrypted: ArrayBuffer\n  ) => {\n    if (disposed) return;\n    try {\n      const payload = JSON.parse(\n        await decrypt(encrypted, roomId.slice(ROOM_ID_PREFIX_LEN))\n      );\n      console.log(\"decrypted payload\", conn.peer, payload);\n      if (!isObject(payload)) return;\n\n      handlePayloadSDP(conn, (payload as { SDP?: unknown }).SDP);\n      handlePayloadUserId(conn, (payload as { userId?: unknown }).userId);\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadPeers((payload as { peers?: unknown }).peers);\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, encrypted);\n    }\n  };\n\n  const sendPayload = async (conn: Peer.DataConnection, payload: unknown) => {\n    try {\n      const encrypted = await encrypt(\n        JSON.stringify(payload),\n        roomId.slice(ROOM_ID_PREFIX_LEN)\n      );\n      conn.send(encrypted);\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const scheduledNegotiation = new WeakMap<Peer.DataConnection, boolean>();\n  const initConnection = (conn: Peer.DataConnection) => {\n    if (connMap.isConnected(conn.peer)) {\n      conn.close();\n      return;\n    }\n    connMap.addConn(conn);\n    conn.on(\"open\", () => {\n      connMap.markConnected(conn);\n      console.log(\"dataConnection open\", conn);\n      showConnectedStatus();\n      const peerIndex = getPeerIndexFromPeerId(conn.peer);\n      notifyNewPeer(peerIndex);\n    });\n    conn.on(\"data\", (buf: ArrayBuffer) => handlePayload(conn, buf));\n    conn.peerConnection.addEventListener(\"icegatheringstatechange\", () => {\n      const pc = conn.peerConnection;\n      if (pc.iceGatheringState === \"complete\") {\n        pc.onicecandidate = () => undefined;\n      }\n    });\n    conn.peerConnection.addEventListener(\"negotiationneeded\", async () => {\n      if (scheduledNegotiation.has(conn)) return;\n      scheduledNegotiation.set(conn, true);\n      await sleep(2000);\n      scheduledNegotiation.delete(conn);\n      if (!connMap.isConnected(conn.peer)) return;\n      const offer = await conn.peerConnection.createOffer();\n      await conn.peerConnection.setLocalDescription(offer);\n      sendSDP(conn, { offer });\n    });\n    conn.peerConnection.addEventListener(\"track\", (event: RTCTrackEvent) => {\n      const connUserId = connMap.getUserId(conn);\n      if (connUserId) {\n        const info: PeerInfo = {\n          userId: connUserId,\n          peerIndex: getPeerIndexFromPeerId(conn.peer),\n          mediaTypes: connMap.getMediaTypes(conn),\n        };\n        receiveTrack(\n          setupTrackStopOnLongMute(event.track, conn.peerConnection),\n          info\n        );\n      }\n    });\n    conn.on(\"close\", () => {\n      connMap.delConn(conn);\n      console.log(\"dataConnection closed\", conn);\n      updateNetworkStatus({\n        type: \"CONNECTION_CLOSED\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      showConnectedStatus();\n      if (connMap.getConnectedPeerIds().length === 0) {\n        reInitMyPeer(true);\n      } else if (\n        guessSeed(conn.peer) &&\n        myPeer &&\n        !myPeer.disconnected &&\n        !guessSeed(myPeer.id)\n      ) {\n        const waitSec = 30 + Math.floor(Math.random() * 60);\n        console.log(\n          `Disconnected seed peer: ${getPeerIndexFromPeerId(\n            conn.peer\n          )}, reinit in ${waitSec}sec...`\n        );\n        setTimeout(reInitMyPeer, waitSec * 1000);\n      }\n    });\n  };\n\n  const initMyPeer = (index = MIN_SEED_PEER_INDEX) => {\n    if (disposed) return;\n    if (myPeer) return;\n    connMap.clearAll();\n    const isSeed = MIN_SEED_PEER_INDEX <= index && index <= MAX_SEED_PEER_INDEX;\n    const peerIndex = isSeed ? index : rand4();\n    updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex });\n    const id = generatePeerId(roomId, peerIndex);\n    console.log(\"initMyPeer start\", index, id);\n    const peer = new Peer(id, getPeerJsConfigFromUrl());\n    myPeer = peer;\n    peer.on(\"open\", () => {\n      myPeer = peer;\n      if (process.env.NODE_ENV !== \"production\") {\n        (window as any).myPeer = myPeer;\n      }\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const seedId = generatePeerId(roomId, i);\n        connectPeer(seedId);\n      }\n    });\n    peer.on(\"error\", (err) => {\n      if (err.type === \"unavailable-id\") {\n        myPeer = null;\n        peer.destroy();\n        initMyPeer(index + 1);\n      } else if (err.type === \"peer-unavailable\") {\n        // ignore\n      } else if (err.type === \"disconnected\") {\n        console.log(\"initMyPeer disconnected error\", index, err);\n        peer.destroy();\n      } else if (err.type === \"network\") {\n        console.log(\"initMyPeer network error\", index, err);\n      } else if (err.type === \"server-error\") {\n        console.log(\"initMyPeer server error\", index, err);\n        updateNetworkStatus({ type: \"SERVER_ERROR\" });\n      } else {\n        console.error(\"initMyPeer unknown error\", index, err.type, err);\n        updateNetworkStatus({ type: \"UNKNOWN_ERROR\", err });\n      }\n    });\n    peer.on(\"connection\", (conn) => {\n      if (myPeer !== peer) {\n        conn.close();\n        return;\n      }\n      console.log(\"new connection received\", conn);\n      updateNetworkStatus({\n        type: \"NEW_CONNECTION\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      initConnection(conn);\n    });\n    peer.on(\"disconnected\", () => {\n      console.log(\"initMyPeer disconnected\", index);\n      setTimeout(() => {\n        if (myPeer === peer && !peer.destroyed) {\n          console.log(\"initMyPeer reconnecting\", index);\n          updateNetworkStatus({ type: \"RECONNECTING\" });\n          peer.reconnect();\n        }\n      }, 5 * 1000);\n    });\n    peer.on(\"close\", () => {\n      if (myPeer === peer) {\n        console.log(\"initMyPeer closed, re-initializing\", index);\n        myPeer = null;\n        setTimeout(initMyPeer, 20 * 1000);\n      } else {\n        console.log(\"initMyPeer closed, ignoring\", index);\n      }\n    });\n  };\n  initMyPeer();\n\n  const reInitMyPeer = (force?: boolean) => {\n    if (!myPeer) return;\n    if (myPeer.disconnected) return; // should already be handled\n    if (!force) {\n      if (guessSeed(myPeer.id)) return;\n      let existsAllSeeds = true;\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const id = generatePeerId(roomId, i);\n        if (!connMap.isConnected(id)) {\n          existsAllSeeds = false;\n          break;\n        }\n      }\n      if (existsAllSeeds) {\n        showConnectedStatus();\n        return;\n      }\n    }\n    const oldPeer = myPeer;\n    myPeer = null;\n    oldPeer.destroy();\n    initMyPeer();\n  };\n\n  const acceptMediaTypes = (mTypes: string[]) => {\n    mediaTypes = mTypes;\n    if (mediaTypes.length) {\n      if (!localStream) {\n        localStream = new MediaStream();\n        connMap.forEachConnectedConns((conn) => {\n          const connUserId = connMap.getUserId(conn);\n          if (connUserId) {\n            const info: PeerInfo = {\n              userId: connUserId,\n              peerIndex: getPeerIndexFromPeerId(conn.peer),\n              mediaTypes: connMap.getMediaTypes(conn),\n            };\n            conn.peerConnection.getReceivers().forEach((receiver) => {\n              if (receiver.track.readyState !== \"live\") return;\n              receiveTrack(\n                setupTrackStopOnLongMute(receiver.track, conn.peerConnection),\n                info\n              );\n            });\n          }\n        });\n      }\n    } else {\n      localStream = null;\n    }\n    broadcastData(null);\n  };\n\n  const trackMediaTypeMap = new WeakMap<MediaStreamTrack, string>();\n\n  const addTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (!localStream) return;\n    trackMediaTypeMap.set(track, mediaType);\n    localStream.addTrack(track);\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      try {\n        if (!localStream) return;\n        conn.peerConnection.addTrack(track, localStream);\n      } catch (e) {\n        if (e.name === \"InvalidAccessError\") {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n    });\n  };\n\n  const removeTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (localStream) {\n      localStream.removeTrack(track);\n    }\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      const senders = conn.peerConnection.getSenders();\n      const sender = senders.find((s) => s.track === track);\n      if (sender) {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const syncAllTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection.getSenders();\n    const mTypes = connMap.getMediaTypes(conn);\n    if (localStream) {\n      localStream.getTracks().forEach((track) => {\n        const mType = trackMediaTypeMap.get(track);\n        if (\n          localStream &&\n          mType &&\n          mTypes.includes(mType) &&\n          senders.every((sender) => sender.track !== track)\n        ) {\n          conn.peerConnection.addTrack(track, localStream);\n        }\n      });\n    }\n    senders.forEach((sender) => {\n      if (sender.track) {\n        const mType = trackMediaTypeMap.get(sender.track);\n        if (!mType || !mTypes.includes(mType)) {\n          conn.peerConnection.removeTrack(sender);\n        }\n      }\n    });\n    if (senders.some((sender) => sender.track && !sender.transport)) {\n      conn.peerConnection.dispatchEvent(new Event(\"negotiationneeded\"));\n    }\n  };\n\n  const removeAllTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection.getSenders();\n    senders.forEach((sender) => {\n      if (sender.track) {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const dispose = () => {\n    disposed = true;\n    if (myPeer) {\n      myPeer.destroy();\n    }\n  };\n\n  return {\n    broadcastData,\n    sendData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n","let peerIndexCounter = 0;\n\nconst getNextPeerIndex = () => {\n  peerIndexCounter += 1;\n  return peerIndexCounter;\n};\n\nexport type Connection = {\n  peerIndex: number;\n  peer: string; // ipfsId\n  userId: string;\n  sendPc: RTCPeerConnection;\n  recvPc: RTCPeerConnection;\n};\n\nconst DEFAULT_CONFIG = {\n  iceServers: [\n    { urls: \"stun:stun.l.google.com:19302\" },\n    {\n      urls: \"turn:0.peerjs.com:3478\",\n      username: \"peerjs\",\n      credential: \"peerjsp\",\n    },\n  ],\n  sdpSemantics: \"unified-plan\",\n};\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Connection;\n    mediaTypes: string[];\n  };\n  const map = new Map<string, Value>();\n\n  const setMediaTypes = (conn: Connection, mediaTypes: string[]) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.mediaTypes = mediaTypes;\n    }\n  };\n\n  const getMediaTypes = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    return (value && value.mediaTypes) || [];\n  };\n\n  const addConn = (peerId: string, userId: string) => {\n    const value = map.get(peerId);\n    if (value) {\n      throw new Error(\"addConn: already exists\");\n    }\n    const conn: Connection = {\n      peerIndex: getNextPeerIndex(),\n      peer: peerId,\n      userId,\n      sendPc: new RTCPeerConnection(DEFAULT_CONFIG),\n      recvPc: new RTCPeerConnection(DEFAULT_CONFIG),\n    };\n    map.set(conn.peer, { conn, mediaTypes: [] });\n    return conn;\n  };\n\n  const getConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return null;\n    return value.conn;\n  };\n\n  const findConn = (peerIndex: number) => {\n    const value = Array.from(map.values()).find(\n      (v) => v.conn.peerIndex === peerIndex\n    );\n    if (value) return value.conn;\n    return null;\n  };\n\n  const delConn = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n      conn.sendPc.close();\n      conn.recvPc.close();\n    } else {\n      throw new Error(\"delConn: does not exist\");\n    }\n  };\n\n  const getPeerIndexList = () =>\n    Array.from(map.values()).map((v) => v.conn.peerIndex);\n\n  const forEachConns = (callback: (conn: Connection) => void) => {\n    Array.from(map.values()).forEach((value) => {\n      callback(value.conn);\n    });\n  };\n\n  const forEachConnsAcceptingMedia = (\n    mediaType: string,\n    callback: (conn: Connection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.mediaTypes && value.mediaTypes.includes(mediaType)) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const size = () => map.size;\n\n  return {\n    setMediaTypes,\n    getMediaTypes,\n    addConn,\n    getConn,\n    findConn,\n    delConn,\n    getPeerIndexList,\n    forEachConns,\n    forEachConnsAcceptingMedia,\n    size,\n  };\n};\n","import Ipfs, { IpfsType, PubsubHandler } from \"ipfs\";\n\nimport { sleep } from \"../utils/sleep\";\nimport { secureRandomId, encrypt, decrypt } from \"../utils/crypto\";\nimport { isObject } from \"../utils/types\";\nimport { ROOM_ID_PREFIX_LEN, PeerInfo, CreateRoom } from \"./common\";\nimport { Connection, createConnectionMap } from \"./ipfsUtils\";\nimport { setupTrackStopOnLongMute } from \"./trackUtils\";\n\nexport const createRoom: CreateRoom = (\n  roomId,\n  userId,\n  updateNetworkStatus,\n  notifyNewPeer,\n  receiveData,\n  receiveTrack\n) => {\n  let disposed = false;\n  let myIpfs: IpfsType | null = null;\n  let myPeerId: string | null = null;\n  const connMap = createConnectionMap();\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myConnMap = connMap;\n  }\n  let mediaTypes: string[] = [];\n  let localStream: MediaStream | null = null;\n\n  const roomTopic = roomId.slice(0, ROOM_ID_PREFIX_LEN);\n\n  const showConnectedStatus = () => {\n    if (disposed) return;\n    const peerIndexList = connMap.getPeerIndexList();\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const parsePayload = async (encrypted: ArrayBuffer): Promise<unknown> => {\n    try {\n      const payload = JSON.parse(\n        await decrypt(encrypted, roomId.slice(ROOM_ID_PREFIX_LEN))\n      );\n      console.log(\"decrypted payload\", payload);\n      return payload;\n    } catch (e) {\n      console.info(\"Error in parsePayload\", e, encrypted);\n      return undefined;\n    }\n  };\n\n  const sendPayload = async (topic: string, payload: unknown) => {\n    try {\n      console.log(\"payload to encrypt\", topic, payload);\n      const encrypted = await encrypt(\n        JSON.stringify(payload),\n        roomId.slice(ROOM_ID_PREFIX_LEN)\n      );\n      console.log(\"sending encrypted\", encrypted.byteLength);\n      if (encrypted.byteLength > 262144) {\n        console.warn(\"encrypted message too large, aborting\");\n        return;\n      }\n      if (!myIpfs) return;\n      await myIpfs.pubsub.publish(topic, encrypted);\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const broadcastData = async (data: unknown) => {\n    if (disposed) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayload(roomTopic, payload);\n  };\n\n  const sendData = async (data: unknown, peerIndex: number) => {\n    if (disposed) return;\n    const conn = connMap.findConn(peerIndex);\n    if (!conn) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayload(roomTopic, { ...payload, to: conn.peer });\n    // TODO direct connection\n    // await sendPayload(`${roomTopic} ${conn.peer}`, payload);\n  };\n\n  const acceptMediaTypes = (mTypes: string[]) => {\n    mediaTypes = mTypes;\n    if (mediaTypes.length) {\n      if (!localStream) {\n        localStream = new MediaStream();\n        connMap.forEachConns((conn) => {\n          const info: PeerInfo = {\n            userId: conn.userId,\n            peerIndex: conn.peerIndex,\n            mediaTypes: connMap.getMediaTypes(conn),\n          };\n          conn.recvPc.getReceivers().forEach((receiver) => {\n            if (receiver.track.readyState !== \"live\") return;\n            receiveTrack(\n              setupTrackStopOnLongMute(receiver.track, conn.recvPc),\n              info\n            );\n          });\n        });\n      }\n    } else {\n      localStream = null;\n    }\n    broadcastData(null);\n  };\n\n  const sendSDP = (conn: Connection, sdp: unknown) => {\n    sendPayload(roomTopic, { SDP: sdp, to: conn.peer });\n    // TODO direct connection\n    // sendPayload(`${roomTopic} ${conn.peer}`, { SDP: sdp });\n  };\n\n  const handlePayloadSDP = async (conn: Connection, sdp: unknown) => {\n    if (!isObject(sdp)) return;\n    if (isObject((sdp as { offer: unknown }).offer)) {\n      const { offer } = sdp as { offer: object };\n      try {\n        await conn.recvPc.setRemoteDescription(offer as any);\n        const answer = await conn.recvPc.createAnswer();\n        await conn.recvPc.setLocalDescription(answer);\n        sendSDP(conn, { answer });\n      } catch (e) {\n        console.info(\"handleSDP offer failed\", e);\n      }\n    } else if (isObject((sdp as { answer: unknown }).answer)) {\n      const { answer } = sdp as { answer: object };\n      try {\n        await conn.sendPc.setRemoteDescription(answer as any);\n      } catch (e) {\n        console.info(\"handleSDP answer failed\", e);\n        await sleep(Math.random() * 30 * 1000);\n        removeAllTracks(conn);\n        syncAllTracks(conn);\n      }\n    } else {\n      console.warn(\"unknown SDP\", sdp);\n    }\n  };\n\n  const sendIceCandidate = (conn: Connection, iceCandidate: unknown) => {\n    sendPayload(roomTopic, { iceCandidate, to: conn.peer });\n    // TODO direct connection\n    // sendPayload(`${roomTopic} ${conn.peer}`, { iceCandidate });\n  };\n\n  const handlePayloadIceCandidate = (\n    conn: Connection,\n    iceCandidate: unknown\n  ) => {\n    if (!isObject(iceCandidate)) return;\n    try {\n      conn.recvPc.addIceCandidate(iceCandidate as any);\n    } catch (e) {\n      console.info(\"handleCandidate failed\", e);\n    }\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Connection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setMediaTypes(conn, payloadMediaTypes as string[]);\n      await sleep(5000);\n      syncAllTracks(conn);\n    }\n  };\n\n  const handlePayloadData = (conn: Connection, data: unknown) => {\n    const info: PeerInfo = {\n      userId: conn.userId,\n      peerIndex: conn.peerIndex,\n      mediaTypes: connMap.getMediaTypes(conn),\n    };\n    try {\n      receiveData(data, info);\n    } catch (e) {\n      console.warn(\"receiveData\", e);\n    }\n  };\n\n  const handlePayload = async (conn: Connection, payload: unknown) => {\n    if (disposed) return;\n    try {\n      if (!isObject(payload)) return;\n\n      handlePayloadSDP(conn, (payload as { SDP?: unknown }).SDP);\n      handlePayloadIceCandidate(\n        conn,\n        (payload as { iceCandidate?: unknown }).iceCandidate\n      );\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, payload);\n    }\n  };\n\n  const scheduledNegotiation = new WeakMap<Connection, boolean>();\n  const initConnection = (peerId: string, payloadUserId: string) => {\n    const conn = connMap.addConn(peerId, payloadUserId);\n    conn.sendPc.addEventListener(\"icecandidate\", (evt) => {\n      if (evt.candidate) {\n        sendIceCandidate(conn, evt.candidate);\n      }\n    });\n    conn.sendPc.addEventListener(\"negotiationneeded\", async () => {\n      if (scheduledNegotiation.has(conn)) return;\n      scheduledNegotiation.set(conn, true);\n      await sleep(2000);\n      scheduledNegotiation.delete(conn);\n      const offer = await conn.sendPc.createOffer();\n      await conn.sendPc.setLocalDescription(offer);\n      sendSDP(conn, { offer });\n    });\n    conn.recvPc.addEventListener(\"track\", (event: RTCTrackEvent) => {\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getMediaTypes(conn),\n      };\n      receiveTrack(setupTrackStopOnLongMute(event.track, conn.recvPc), info);\n    });\n    notifyNewPeer(conn.peerIndex);\n    updateNetworkStatus({\n      type: \"NEW_CONNECTION\",\n      peerIndex: conn.peerIndex,\n    });\n    return conn;\n  };\n\n  // TODO direct connection\n  const getToFromPayload = (payload: unknown) => {\n    if (!Object(payload)) return null;\n    const payloadTo = (payload as { to: unknown }).to;\n    if (typeof payloadTo !== \"string\") return null;\n    return payloadTo;\n  };\n\n  const getUserIdFromPayload = (payload: unknown) => {\n    if (!Object(payload)) return null;\n    const payloadUserId = (payload as { userId: unknown }).userId;\n    if (typeof payloadUserId !== \"string\") return null;\n    return payloadUserId;\n  };\n\n  const pubsubHandler: PubsubHandler = async (msg) => {\n    if (msg.from === myPeerId) return;\n    const payload = await parsePayload(msg.data);\n    // TODO direct connection\n    const payloadTo = getToFromPayload(payload);\n    if (payloadTo && payloadTo !== myPeerId) return;\n    const payloadUserId = getUserIdFromPayload(payload);\n    let conn = connMap.getConn(msg.from);\n    if (!conn && payloadUserId) {\n      conn = initConnection(msg.from, payloadUserId);\n    }\n    if (conn) {\n      await handlePayload(conn, payload);\n    }\n    showConnectedStatus();\n  };\n\n  const checkPeers = async () => {\n    if (disposed) return;\n    const peers = myIpfs ? myIpfs.pubsub.peers(roomTopic) : [];\n    const prevConnMapSize = connMap.size();\n    connMap.forEachConns((conn) => {\n      if (!peers.includes(conn.peer)) {\n        connMap.delConn(conn);\n        updateNetworkStatus({\n          type: \"CONNECTION_CLOSED\",\n          peerIndex: conn.peerIndex,\n        });\n      }\n    });\n    const prevIpfs = myIpfs;\n    if (prevIpfs && prevConnMapSize > 0 && connMap.size() === 0) {\n      myIpfs = null;\n      myPeerId = null;\n      await closeIpfs(prevIpfs);\n      await sleep(20 * 1000);\n      await initIpfs();\n      return;\n    }\n    if (!peers.length) {\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      await sleep(1000);\n      checkPeers();\n      return;\n    }\n    if (!connMap.size()) {\n      await broadcastData(null);\n    }\n    await sleep(5 * 1000);\n    checkPeers();\n  };\n\n  const initIpfs = async () => {\n    updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex: 0 });\n    const ipfs: IpfsType = await Ipfs.create({\n      repo: secureRandomId(),\n      config: {\n        Addresses: {\n          Swarm: [\n            \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\n          ],\n        },\n      },\n    });\n    myPeerId = (await ipfs.id()).id;\n    await ipfs.pubsub.subscribe(roomTopic, pubsubHandler);\n    // TODO direct connection\n    // await ipfs.pubsub.subscribe(`${roomTopic} ${myPeerId}`, pubsubHandler);\n    myIpfs = ipfs;\n    if (process.env.NODE_ENV !== \"production\") {\n      (window as any).myIpfs = myIpfs;\n    }\n    checkPeers();\n  };\n  initIpfs();\n\n  const closeIpfs = async (ipfs: IpfsType) => {\n    await ipfs.pubsub.unsubscribe(roomTopic, pubsubHandler);\n    // TODO direct connection\n    // await ipfs.pubsub.unsubscribe(`${roomTopic} ${myPeerId}`, pubsubHandler);\n    await ipfs.stop();\n  };\n\n  const trackMediaTypeMap = new WeakMap<MediaStreamTrack, string>();\n\n  const addTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (!localStream) return;\n    trackMediaTypeMap.set(track, mediaType);\n    localStream.addTrack(track);\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      try {\n        if (!localStream) return;\n        conn.sendPc.addTrack(track, localStream);\n        conn.sendPc.dispatchEvent(new Event(\"negotiationneeded\"));\n      } catch (e) {\n        if (e.name === \"InvalidAccessError\") {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n    });\n  };\n\n  const removeTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (localStream) {\n      localStream.removeTrack(track);\n    }\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      const senders = conn.sendPc.getSenders();\n      const sender = senders.find((s) => s.track === track);\n      if (sender) {\n        conn.sendPc.removeTrack(sender);\n        conn.sendPc.dispatchEvent(new Event(\"negotiationneeded\"));\n      }\n    });\n  };\n\n  const syncAllTracks = (conn: Connection) => {\n    const senders = conn.sendPc.getSenders();\n    const mTypes = connMap.getMediaTypes(conn);\n    if (localStream) {\n      localStream.getTracks().forEach((track) => {\n        const mType = trackMediaTypeMap.get(track);\n        if (\n          localStream &&\n          mType &&\n          mTypes.includes(mType) &&\n          senders.every((sender) => sender.track !== track)\n        ) {\n          conn.sendPc.addTrack(track, localStream);\n        }\n      });\n    }\n    senders.forEach((sender) => {\n      if (sender.track) {\n        const mType = trackMediaTypeMap.get(sender.track);\n        if (!mType || !mTypes.includes(mType)) {\n          conn.sendPc.removeTrack(sender);\n        }\n      }\n    });\n    if (senders.some((sender) => sender.track && !sender.transport)) {\n      conn.sendPc.dispatchEvent(new Event(\"negotiationneeded\"));\n    }\n  };\n\n  const removeAllTracks = (conn: Connection) => {\n    const senders = conn.sendPc.getSenders();\n    senders.forEach((sender) => {\n      if (sender.track) {\n        conn.sendPc.removeTrack(sender);\n      }\n    });\n    conn.sendPc.dispatchEvent(new Event(\"negotiationneeded\"));\n  };\n\n  const dispose = async () => {\n    disposed = true;\n    if (myIpfs) {\n      closeIpfs(myIpfs);\n    }\n  };\n\n  return {\n    broadcastData,\n    sendData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n","import { hasPeerJsConfigInUrl } from \"../utils/url\";\nimport type { CreateRoom } from \"./common\";\nimport { createRoom as peerjsCreateRoom } from \"./peerjsRoom\";\nimport { createRoom as ipfsCreateRoom } from \"./ipfsRoom\";\n\nexport type { NetworkStatus, PeerInfo } from \"./common\";\nexport { ROOM_ID_PREFIX_LEN } from \"./common\";\n\nexport const createRoom: CreateRoom = (...args) => {\n  if (hasPeerJsConfigInUrl()) {\n    return peerjsCreateRoom(...args);\n  }\n  return ipfsCreateRoom(...args);\n};\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 425;","export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","import pako from \"pako\";\n\nexport const sha256 = async (text: string) => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(text);\n  const buf = await window.crypto.subtle.digest(\"SHA-256\", data);\n  const arr = Array.from(new Uint8Array(buf));\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const secureRandomId = (len = 32) => {\n  const buf = window.crypto.getRandomValues(new Uint8Array(len));\n  const arr = Array.from(buf);\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const rand4 = () => {\n  const rand = window.crypto.getRandomValues(new Uint16Array(1))[0];\n  return 1000 + (rand % 9000);\n};\n\nexport const generateCryptoKey = async () => {\n  const key = await window.crypto.subtle.generateKey(\n    { name: \"AES-GCM\", length: 128 },\n    true,\n    [\"encrypt\", \"decrypt\"]\n  );\n  const buf = await window.crypto.subtle.exportKey(\"raw\", key);\n  const arr = Array.from(new Uint8Array(buf));\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const importCryptoKey = async (\n  key: string,\n  usages: (\"encrypt\" | \"decrypt\")[]\n) => {\n  const size = key.length / 2;\n  const buf = new Uint8Array(size);\n  for (let i = 0; i < size; i += 1) {\n    buf[i] = parseInt(key.slice(i * 2, i * 2 + 2), 16);\n  }\n  const cryptoKey = await window.crypto.subtle.importKey(\n    \"raw\",\n    buf,\n    { name: \"AES-GCM\", length: 128 },\n    true,\n    usages\n  );\n  return cryptoKey;\n};\n\n// encrypt with compression\nexport const encrypt = async (data: string, key: string) => {\n  const encoder = new TextEncoder();\n  const encoded = encoder.encode(data);\n  const compressed = pako.deflate(encoded);\n  const cryptoKey = await importCryptoKey(key, [\"encrypt\"]);\n  const iv = window.crypto.getRandomValues(new Uint8Array(12));\n  const encrypted = await window.crypto.subtle.encrypt(\n    { name: \"AES-GCM\", iv },\n    cryptoKey,\n    compressed\n  );\n  const buf = new Uint8Array(iv.length + encrypted.byteLength);\n  buf.set(iv);\n  buf.set(new Uint8Array(encrypted), iv.length);\n  return buf;\n};\n\n// decrypt with decompression\nexport const decrypt = async (buf: ArrayBuffer, key: string) => {\n  const cryptoKey = await importCryptoKey(key, [\"decrypt\"]);\n  const decrypted = await window.crypto.subtle.decrypt(\n    { name: \"AES-GCM\", iv: buf.slice(0, 12) },\n    cryptoKey,\n    buf.slice(12)\n  );\n  const decompressed = pako.inflate(new Uint8Array(decrypted));\n  const decoder = new TextDecoder(\"utf-8\");\n  const data = decoder.decode(decompressed);\n  return data;\n};\n","export const isObject = (x: unknown): x is object =>\n  typeof x === \"object\" && x !== null;\n","export const copyHashFromLink = (link: string) => {\n  try {\n    const srcHash = new URL(link).hash.slice(1);\n    const srcSearchParams = new URLSearchParams(srcHash);\n    const dstHash = window.location.hash.slice(1);\n    const dstSearchParams = new URLSearchParams(dstHash);\n    srcSearchParams.forEach((value, key) => {\n      dstSearchParams.set(key, value);\n    });\n    window.location.hash = dstSearchParams.toString();\n  } catch (e) {\n    // ignore\n  }\n};\n\nexport const extractRoomIdFromLink = (link: string) => {\n  try {\n    const hash = new URL(link).hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    return searchParams.get(\"roomId\");\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const getRoomIdFromUrl = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  return searchParams.get(\"roomId\");\n};\n\nexport const setRoomIdToUrl = (roomId: string) => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  searchParams.set(\"roomId\", roomId);\n  window.location.hash = searchParams.toString();\n};\n\nexport const hasPeerJsConfigInUrl = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  return searchParams.has(\"peerjs\");\n};\n\nexport const getPeerJsConfigFromUrl = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  const server = searchParams.get(\"peerjs\");\n  try {\n    const url = new URL(server || \"\");\n    const secure = url.protocol === \"https:\";\n    const defaultPort = secure ? 443 : 80;\n    return {\n      host: url.host.split(\":\")[0],\n      port: url.port ? Number(url.port) : defaultPort,\n      path: url.pathname,\n      secure,\n    };\n  } catch (e) {\n    // ignore\n  }\n  return undefined;\n};\n"],"sourceRoot":""}