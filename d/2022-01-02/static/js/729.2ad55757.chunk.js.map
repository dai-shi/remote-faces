{"version":3,"file":"static/js/729.2ad55757.chunk.js","mappings":"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","sources":["network/peerjsUtils.ts","network/peerjsRoom.ts","network/trackUtils.ts","../../node_modules/peerjs/dist|sync"],"sourcesContent":["import Peer from \"peerjs\";\n\nimport { ROOM_ID_PREFIX_LEN } from \"./common\";\nimport { hasObjectProp, hasStringProp } from \"../utils/types\";\n\nexport const isValidPeerId = (\n  roomId: string,\n  peerId: unknown\n): peerId is string =>\n  typeof peerId === \"string\" &&\n  peerId.startsWith(`${roomId.slice(0, ROOM_ID_PREFIX_LEN)} `);\n\nexport const generatePeerId = (roomId: string, peerIndex: number) =>\n  `${roomId.slice(0, ROOM_ID_PREFIX_LEN)} ${peerIndex}`;\n\nexport const getPeerIndexFromPeerId = (peerId: string) =>\n  Number(peerId.split(\" \")[1]);\n\nexport const getPeerIndexFromConn = (conn: Peer.DataConnection) =>\n  getPeerIndexFromPeerId(conn.peer);\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Peer.DataConnection;\n    createdAt: number;\n    connected?: boolean;\n    userId?: string;\n    acceptingMediaTypes: string[];\n    remoteMediaTypes: Record<string, string>; // key = mid\n  };\n  const map = new Map<string, Value>();\n\n  const setAcceptingMediaTypes = (\n    conn: Peer.DataConnection,\n    mediaTypes: string[]\n  ) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.acceptingMediaTypes = mediaTypes;\n    }\n  };\n\n  const getAcceptingMediaTypes = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (!value) return [];\n    return value.acceptingMediaTypes;\n  };\n\n  const addConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    map.set(conn.peer, {\n      conn,\n      createdAt: Date.now(),\n      acceptingMediaTypes: [],\n      remoteMediaTypes: {},\n    });\n    if (value) {\n      value.conn.close();\n    }\n  };\n\n  const markConnected = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      value.connected = true;\n    }\n  };\n\n  const isConnected = (value?: Value) =>\n    !!(value && value.connected && value.conn.open);\n\n  const isConnectedPeerId = (peerId: string) => isConnected(map.get(peerId));\n\n  const isConnectedConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      return isConnected(value);\n    }\n    return false;\n  };\n\n  const setUserId = (conn: Peer.DataConnection, userId: string) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.userId = userId;\n    }\n  };\n\n  const getUserId = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    return value && value.userId;\n  };\n\n  const hasFreshConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return false;\n    return value.createdAt > Date.now() - 10 * 60 * 1000; // 10min\n  };\n\n  const getConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return null;\n    return value.conn;\n  };\n\n  const delConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n      return true;\n    }\n    return false;\n  };\n\n  const getConnectedPeerIds = () =>\n    Array.from(map.keys()).filter((k) => isConnected(map.get(k)));\n\n  const getNotConnectedPeerIds = () =>\n    Array.from(map.keys()).filter((k) => !isConnected(map.get(k)));\n\n  const forEachConnectedConns = (\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (isConnected(value)) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const forEachConnsAcceptingMedia = (\n    mediaType: string,\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (isConnected(value) && value.acceptingMediaTypes.includes(mediaType)) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const clearAll = () => {\n    if (map.size) {\n      console.log(\n        \"connectionMap garbage:\",\n        [...map.entries()].map(([k, v]) => ({\n          id: k,\n          createdAt: v.createdAt,\n          connected: v.connected,\n          open: v.conn.open,\n          userId: v.userId,\n        }))\n      );\n    }\n    map.clear();\n  };\n\n  const getRemoteMediaType = (conn: Peer.DataConnection, mid: string) => {\n    const value = map.get(conn.peer);\n    if (!value) return null;\n    return value.remoteMediaTypes[mid] || null;\n  };\n\n  const registerRemoteMediaTypeFromSDP = (\n    conn: Peer.DataConnection,\n    msid2mediaType: Record<string, unknown>,\n    sdpLines: string\n  ) => {\n    const value = map.get(conn.peer);\n    if (!value) return;\n    const lines = sdpLines.split(/[\\r\\n]+/);\n    let mid: string;\n    lines.forEach((line) => {\n      if (line.startsWith(\"a=mid:\")) {\n        mid = line.slice(\"a=mid:\".length);\n      } else if (line.startsWith(\"a=msid:\")) {\n        const arr = line.slice(\"a=msid:\".length).split(\" \");\n        arr.forEach((msid) => {\n          const mediaType = msid2mediaType[msid];\n          if (typeof mediaType === \"string\") {\n            value.remoteMediaTypes[mid] = mediaType;\n          }\n        });\n      }\n    });\n  };\n\n  const registerRemoteMediaType = (\n    conn: Peer.DataConnection,\n    sdp: Record<string, unknown>\n  ) => {\n    if (!hasObjectProp(sdp, \"msid2mediaType\")) return;\n    if (hasObjectProp(sdp, \"offer\") && hasStringProp(sdp.offer, \"sdp\")) {\n      registerRemoteMediaTypeFromSDP(conn, sdp.msid2mediaType, sdp.offer.sdp);\n    }\n    if (hasObjectProp(sdp, \"answer\") && hasStringProp(sdp.answer, \"sdp\")) {\n      registerRemoteMediaTypeFromSDP(conn, sdp.msid2mediaType, sdp.answer.sdp);\n    }\n  };\n\n  return {\n    setAcceptingMediaTypes,\n    getAcceptingMediaTypes,\n    addConn,\n    markConnected,\n    isConnectedPeerId,\n    isConnectedConn,\n    setUserId,\n    getUserId,\n    hasFreshConn,\n    getConn,\n    delConn,\n    getConnectedPeerIds,\n    getNotConnectedPeerIds,\n    forEachConnectedConns,\n    forEachConnsAcceptingMedia,\n    clearAll,\n    getRemoteMediaType,\n    registerRemoteMediaType,\n  };\n};\n","import Peer from \"peerjs\";\n\nimport { sleep } from \"../utils/sleep\";\nimport {\n  rand4,\n  importCryptoKey,\n  encryptString,\n  decryptString,\n} from \"../utils/crypto\";\nimport { getPeerJsConfigFromUrl } from \"../utils/url\";\nimport { isObject, hasObjectProp } from \"../utils/types\";\nimport { ROOM_ID_PREFIX_LEN, PeerInfo, CreateRoom } from \"./common\";\nimport {\n  isValidPeerId,\n  generatePeerId,\n  getPeerIndexFromPeerId,\n  getPeerIndexFromConn,\n  createConnectionMap,\n} from \"./peerjsUtils\";\nimport { setupTrackStopOnLongMute } from \"./trackUtils\";\n\nconst MIN_SEED_PEER_INDEX = 10; // config\nconst MAX_SEED_PEER_INDEX = 14; // config\nconst guessSeed = (id: string) => {\n  const peerIndex = getPeerIndexFromPeerId(id);\n  return MIN_SEED_PEER_INDEX <= peerIndex && peerIndex <= MAX_SEED_PEER_INDEX;\n};\n\nexport const createRoom: CreateRoom = async (\n  roomId,\n  userId,\n  updateNetworkStatus,\n  notifyNewPeer,\n  receiveData,\n  receiveTrack\n) => {\n  let disposed = false;\n  const connMap = createConnectionMap();\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myConnMap = connMap;\n  }\n  let mediaTypes: string[] = [];\n\n  const cryptoKey = await importCryptoKey(roomId.slice(ROOM_ID_PREFIX_LEN));\n\n  let myPeer: Peer | null = null;\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).getMyPeer = () => myPeer;\n  }\n  const initMyPeer = (index = MIN_SEED_PEER_INDEX) => {\n    if (disposed) return;\n    connMap.clearAll();\n    const isSeed = MIN_SEED_PEER_INDEX <= index && index <= MAX_SEED_PEER_INDEX;\n    const peerIndex = isSeed ? index : rand4();\n    updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex });\n    const id = generatePeerId(roomId, peerIndex);\n    const peer = new Peer(id, getPeerJsConfigFromUrl());\n    peer.on(\"open\", () => {\n      myPeer = peer;\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      setTimeout(() => {\n        for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n          const seedId = generatePeerId(roomId, i);\n          connectPeer(seedId);\n        }\n      }, 10);\n    });\n    peer.on(\"error\", (err) => {\n      if (err.type === \"unavailable-id\") {\n        peer.destroy();\n        initMyPeer(index + 1);\n      } else if (err.type === \"peer-unavailable\") {\n        // ignore\n      } else if (err.type === \"disconnected\") {\n        console.log(\"initMyPeer disconnected error\", peerIndex, err);\n      } else if (err.type === \"network\") {\n        console.log(\"initMyPeer network error\", peerIndex, err);\n        setTimeout(() => {\n          if (!peer.destroyed && myPeer === null) {\n            peer.destroy();\n            initMyPeer();\n          }\n        }, 10 * 1000);\n      } else if (err.type === \"server-error\") {\n        console.log(\"initMyPeer server error\", peerIndex, err);\n        updateNetworkStatus({ type: \"SERVER_ERROR\" });\n      } else {\n        console.error(\"initMyPeer unknown error\", peerIndex, err.type, err);\n        updateNetworkStatus({ type: \"UNKNOWN_ERROR\", err });\n      }\n    });\n    peer.on(\"connection\", (conn) => {\n      if (peer !== myPeer) {\n        console.log(\"new connection to old peer, closing\");\n        conn.close();\n        return;\n      }\n      if (peer.id === conn.peer) {\n        console.log(\"new connection from self, closing\");\n        conn.close();\n        return;\n      }\n      updateNetworkStatus({\n        type: \"NEW_CONNECTION\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      initConnection(conn);\n    });\n    peer.on(\"disconnected\", () => {\n      console.log(\"initMyPeer disconnected\", peerIndex);\n      setTimeout(() => {\n        if (!peer.destroyed && peer === myPeer) {\n          updateNetworkStatus({ type: \"RECONNECTING\", peerIndex });\n          peer.reconnect();\n          setTimeout(() => {\n            if (peer.disconnected && !peer.destroyed && peer === myPeer) {\n              console.log(\"reconnect failed, re-initializing\");\n              peer.destroy();\n              myPeer = null;\n              initMyPeer();\n            }\n          }, 60 * 1000);\n        }\n      }, 5 * 1000);\n    });\n  };\n  initMyPeer();\n\n  const showConnectedStatus = () => {\n    if (disposed) return;\n    const peerIndexList = connMap\n      .getConnectedPeerIds()\n      .map(getPeerIndexFromPeerId);\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n    console.log(\n      \"myPeer index:\",\n      myPeer?.id && getPeerIndexFromPeerId(myPeer.id),\n      \", connecting:\",\n      connMap.getNotConnectedPeerIds().map(getPeerIndexFromPeerId)\n    );\n  };\n\n  const connectPeer = (id: string) => {\n    if (disposed || !myPeer) return;\n    if (myPeer.id === id || myPeer.disconnected) return;\n    if (connMap.isConnectedPeerId(id)) return;\n    if (connMap.hasFreshConn(id)) return;\n    console.log(\"connectPeer\", id);\n    const conn = myPeer.connect(id);\n    initConnection(conn);\n  };\n\n  const broadcastData = (data: unknown) => {\n    if (disposed) return;\n    const peers = connMap.getConnectedPeerIds();\n    connMap.forEachConnectedConns((conn) => {\n      sendPayload(conn, { userId, data, peers, mediaTypes });\n    });\n  };\n\n  const sendData = (data: unknown, peerIndex: number) => {\n    if (disposed) return;\n    const conn = connMap.getConn(generatePeerId(roomId, peerIndex));\n    if (!conn) return;\n    const peers = connMap.getConnectedPeerIds();\n    sendPayload(conn, { userId, data, peers, mediaTypes });\n  };\n\n  const sendSDP = (\n    conn: Peer.DataConnection,\n    sdp: { offer: unknown } | { answer: unknown }\n  ) => {\n    const msid2mediaType = getMsid2MediaType();\n    sendPayload(conn, { SDP: { ...sdp, msid2mediaType } });\n  };\n\n  const handlePayloadSDP = async (conn: Peer.DataConnection, sdp: unknown) => {\n    if (!isObject(sdp)) return;\n    connMap.registerRemoteMediaType(conn, sdp);\n    if (hasObjectProp(sdp, \"offer\")) {\n      try {\n        await conn.peerConnection.setRemoteDescription(\n          sdp.offer as unknown as RTCSessionDescriptionInit // FIXME\n        );\n        syncAllTracks(conn);\n        const answer = await conn.peerConnection.createAnswer();\n        await conn.peerConnection.setLocalDescription(answer);\n        sendSDP(conn, { answer });\n      } catch (e) {\n        console.info(\"handleSDP offer failed\", e);\n      }\n    } else if (hasObjectProp(sdp, \"answer\")) {\n      try {\n        await conn.peerConnection.setRemoteDescription(\n          sdp.answer as unknown as RTCSessionDescriptionInit // FIXME\n        );\n      } catch (e) {\n        console.info(\"handleSDP answer failed\", e);\n        await sleep(Math.random() * 30 * 1000);\n        removeAllTracks(conn);\n        syncAllTracks(conn);\n      }\n    } else {\n      console.warn(\"unknown SDP\", sdp);\n    }\n  };\n\n  const handlePayloadUserId = (\n    conn: Peer.DataConnection,\n    payloadUserId: unknown\n  ) => {\n    if (typeof payloadUserId === \"string\") {\n      connMap.setUserId(conn, payloadUserId);\n    }\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Peer.DataConnection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setAcceptingMediaTypes(conn, payloadMediaTypes as string[]);\n      await sleep(5000);\n      syncAllTracks(conn);\n    }\n  };\n\n  const handlePayloadPeers = (peers: unknown) => {\n    if (Array.isArray(peers)) {\n      peers.forEach((peer) => {\n        if (isValidPeerId(roomId, peer)) {\n          connectPeer(peer);\n        }\n      });\n    }\n  };\n\n  const handlePayloadData = (conn: Peer.DataConnection, data: unknown) => {\n    const connUserId = connMap.getUserId(conn);\n    if (connUserId) {\n      const info: PeerInfo = {\n        userId: connUserId,\n        peerIndex: getPeerIndexFromConn(conn),\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      try {\n        receiveData(data, info);\n      } catch (e) {\n        console.warn(\"receiveData\", e);\n      }\n    }\n  };\n\n  const handlePayload = async (\n    conn: Peer.DataConnection,\n    encrypted: ArrayBuffer\n  ) => {\n    if (disposed) return;\n    try {\n      const payload = JSON.parse(await decryptString(encrypted, cryptoKey));\n      // console.log(\"decrypted payload\", conn.peer, payload);\n      if (!isObject(payload)) return;\n\n      handlePayloadSDP(conn, (payload as { SDP?: unknown }).SDP);\n      handlePayloadUserId(conn, (payload as { userId?: unknown }).userId);\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadPeers((payload as { peers?: unknown }).peers);\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, encrypted);\n    }\n  };\n\n  const sendPayload = async (conn: Peer.DataConnection, payload: unknown) => {\n    try {\n      const encrypted = await encryptString(JSON.stringify(payload), cryptoKey);\n      conn.send(encrypted);\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const initConnection = (conn: Peer.DataConnection) => {\n    if (connMap.isConnectedPeerId(conn.peer)) {\n      console.info(\"dataConnection already in map, overriding\", conn.peer);\n    }\n    connMap.addConn(conn);\n    let timer: NodeJS.Timeout;\n    const scheduleClose = () => {\n      clearTimeout(timer);\n      timer = setTimeout(() => {\n        const peerIndex = getPeerIndexFromConn(conn);\n        console.log(\"dataConnection inactive for 5min\", peerIndex, conn.open);\n        if (!conn.open) {\n          connMap.delConn(conn);\n        }\n        conn.close();\n      }, 5 * 60 * 1000); // 5 minutes\n    };\n    scheduleClose();\n    conn.on(\"open\", () => {\n      scheduleClose();\n      connMap.markConnected(conn);\n      const peerIndex = getPeerIndexFromConn(conn);\n      console.log(\"dataConnection open\", peerIndex);\n      showConnectedStatus();\n      notifyNewPeer(peerIndex);\n    });\n    conn.on(\"data\", (buf: ArrayBuffer) => {\n      scheduleClose();\n      connMap.markConnected(conn);\n      handlePayload(conn, buf);\n    });\n    conn.peerConnection.addEventListener(\"icegatheringstatechange\", () => {\n      const pc = conn.peerConnection;\n      if (pc.iceGatheringState === \"complete\") {\n        pc.onicecandidate = () => undefined;\n      }\n    });\n    let negotiationScheduled = false;\n    conn.peerConnection.addEventListener(\"negotiationneeded\", async () => {\n      if (negotiationScheduled) return;\n      negotiationScheduled = true;\n      await sleep(5000);\n      negotiationScheduled = false;\n      if (!connMap.isConnectedConn(conn)) return;\n      if (!conn.peerConnection) return;\n      if (conn.peerConnection.signalingState === \"closed\") return;\n      const offer = await conn.peerConnection.createOffer();\n      await conn.peerConnection.setLocalDescription(offer);\n      sendSDP(conn, { offer });\n    });\n    conn.peerConnection.addEventListener(\"track\", (event: RTCTrackEvent) => {\n      if (!connMap.isConnectedConn(conn)) {\n        console.warn(\"received track from non-connected peer, ignoring\");\n        return;\n      }\n      const { mid } = event.transceiver;\n      const mType = mid && connMap.getRemoteMediaType(conn, mid);\n      if (!mType) {\n        console.warn(\"failed to find media type from mid\");\n        return;\n      }\n      const connUserId = connMap.getUserId(conn);\n      if (connUserId) {\n        const info: PeerInfo = {\n          userId: connUserId,\n          peerIndex: getPeerIndexFromPeerId(conn.peer),\n          mediaTypes: connMap.getAcceptingMediaTypes(conn),\n        };\n        receiveTrack(\n          mType,\n          setupTrackStopOnLongMute(event.track, conn.peerConnection),\n          info\n        );\n      }\n    });\n    conn.on(\"close\", () => {\n      clearTimeout(timer);\n      if (!connMap.delConn(conn)) return;\n      const peerIndex = getPeerIndexFromConn(conn);\n      updateNetworkStatus({ type: \"CONNECTION_CLOSED\", peerIndex });\n      showConnectedStatus();\n      if (connMap.getConnectedPeerIds().length === 0) {\n        reInitMyPeer(true);\n      } else if (\n        myPeer &&\n        guessSeed(conn.peer) &&\n        !myPeer.disconnected &&\n        !guessSeed(myPeer.id)\n      ) {\n        const waitSec = 10 * 60 + Math.floor(Math.random() * 10 * 60);\n        console.log(\n          `Disconnected seed peer: ${peerIndex}, reinit in ${waitSec}sec...`\n        );\n        setTimeout(reInitMyPeer, waitSec * 1000);\n      }\n    });\n  };\n\n  const reInitMyPeer = (force?: boolean) => {\n    if (!myPeer || myPeer.disconnected) return; // should already be handled\n    if (!force) {\n      if (guessSeed(myPeer.id)) return;\n      let existsAllSeeds = true;\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const id = generatePeerId(roomId, i);\n        if (!connMap.isConnectedPeerId(id)) {\n          existsAllSeeds = false;\n          break;\n        }\n      }\n      if (existsAllSeeds) {\n        showConnectedStatus();\n        return;\n      }\n    }\n    myPeer.destroy();\n    myPeer = null;\n    initMyPeer();\n  };\n\n  const acceptMediaTypes = (mTypes: string[]) => {\n    if (disposed) return;\n    if (mTypes.length !== mediaTypes.length) {\n      connMap.forEachConnectedConns((conn) => {\n        const connUserId = connMap.getUserId(conn);\n        if (connUserId) {\n          const info: PeerInfo = {\n            userId: connUserId,\n            peerIndex: getPeerIndexFromPeerId(conn.peer),\n            mediaTypes: connMap.getAcceptingMediaTypes(conn),\n          };\n          const transceivers = conn.peerConnection.getTransceivers();\n          conn.peerConnection.getReceivers().forEach((receiver) => {\n            const transceiver = transceivers.find(\n              (t) => t.receiver === receiver\n            );\n            const mid = transceiver?.mid;\n            const mType = mid && connMap.getRemoteMediaType(conn, mid);\n            if (!mType) {\n              console.warn(\"failed to find media type from mid\");\n              return;\n            }\n            if (\n              receiver.track.readyState === \"live\" &&\n              !mediaTypes.includes(mType) &&\n              mTypes.includes(mType)\n            ) {\n              receiveTrack(\n                mType,\n                setupTrackStopOnLongMute(receiver.track, conn.peerConnection),\n                info\n              );\n            }\n          });\n        }\n      });\n    }\n    mediaTypes = mTypes;\n    broadcastData(null);\n  };\n\n  const mediaTypeMap = new Map<\n    string,\n    {\n      stream: MediaStream;\n      track: MediaStreamTrack;\n    }\n  >();\n\n  const getMsid2MediaType = () => {\n    const msid2mediaType: Record<string, string> = {};\n    mediaTypeMap.forEach(({ stream }, mType) => {\n      msid2mediaType[stream.id] = mType;\n    });\n    return msid2mediaType;\n  };\n\n  const addTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (disposed) return;\n    if (mediaTypeMap.has(mediaType)) {\n      throw new Error(`track is already added for ${mediaType}`);\n    }\n    const stream = new MediaStream([track]);\n    mediaTypeMap.set(mediaType, { stream, track });\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      try {\n        conn.peerConnection.addTrack(track, stream);\n      } catch (e) {\n        if ((e as any).name === \"InvalidAccessError\") {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n    });\n  };\n\n  const removeTrack = (mediaType: string) => {\n    if (disposed) return;\n    const item = mediaTypeMap.get(mediaType);\n    if (!item) {\n      console.log(\"track is already removed for\", mediaType);\n      return;\n    }\n    const { track } = item;\n    mediaTypeMap.delete(mediaType);\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      const senders = conn.peerConnection?.getSenders() ?? [];\n      const sender = senders.find((s) => s.track === track);\n      if (sender && conn.peerConnection.signalingState !== \"closed\") {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const syncAllTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection?.getSenders() ?? [];\n    const acceptingMediaTypes = connMap.getAcceptingMediaTypes(conn);\n    acceptingMediaTypes.forEach((mType) => {\n      const item = mediaTypeMap.get(mType);\n      if (!item) return;\n      const { stream, track } = item;\n      if (senders.every((sender) => sender.track !== track)) {\n        conn.peerConnection.addTrack(track, stream);\n      }\n    });\n    senders.forEach((sender) => {\n      if (!sender.track) return;\n      const isEffective = acceptingMediaTypes.some(\n        (mType) => mediaTypeMap.get(mType)?.track === sender.track\n      );\n      if (!isEffective && conn.peerConnection.signalingState !== \"closed\") {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n    if (senders.some((sender) => sender.track && !sender.transport)) {\n      conn.peerConnection.dispatchEvent(new Event(\"negotiationneeded\"));\n    }\n  };\n\n  const removeAllTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection?.getSenders() ?? [];\n    senders.forEach((sender) => {\n      if (sender.track && conn.peerConnection.signalingState !== \"closed\") {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const dispose = () => {\n    disposed = true;\n    if (myPeer) {\n      myPeer.destroy();\n      myPeer = null;\n    }\n  };\n\n  return {\n    broadcastData,\n    sendData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n","const setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = (timeout = 1000) => {\n    if (track.readyState === \"ended\") return;\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    } else if (timeout < 64000) {\n      setTimeout(() => {\n        onmute(timeout * 2);\n      }, timeout);\n    }\n  };\n  track.addEventListener(\"mute\", () => onmute());\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n\nexport const videoTrackToImageConverter = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") {\n    throw new Error(\"track kind is not video\");\n  }\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const imageCapture = new ImageCapture(track);\n  const getImage = async () => {\n    try {\n      const bitmap = await imageCapture.grabFrame();\n      canvas.width = bitmap.width;\n      canvas.height = bitmap.height;\n      ctx.drawImage(bitmap, 0, 0);\n      return canvas.toDataURL(\"image/jpeg\");\n    } catch (e) {\n      console.log(\"failed to grab frame from viedeo track\", e);\n      return null;\n    }\n  };\n  return { getImage };\n};\n\nconst createImage = (src: string): Promise<HTMLImageElement> =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n\nexport const imageToVideoTrackConverter = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const [videoTrack] = canvasStream.getVideoTracks();\n  const setImage = async (dataURL: string) => {\n    const img = await createImage(dataURL);\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n  };\n  return { videoTrack, setImage };\n};\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = 98983;\nmodule.exports = webpackEmptyContext;"],"names":["generatePeerId","roomId","peerIndex","slice","ROOM_ID_PREFIX_LEN","getPeerIndexFromPeerId","peerId","Number","split","getPeerIndexFromConn","conn","peer","MIN_SEED_PEER_INDEX","MAX_SEED_PEER_INDEX","guessSeed","id","createRoom","async","userId","updateNetworkStatus","notifyNewPeer","receiveData","receiveTrack","disposed","connMap","map","Map","isConnected","value","connected","open","registerRemoteMediaTypeFromSDP","msid2mediaType","sdpLines","get","mid","forEach","line","startsWith","length","msid","mediaType","remoteMediaTypes","setAcceptingMediaTypes","mediaTypes","acceptingMediaTypes","getAcceptingMediaTypes","addConn","set","createdAt","Date","now","close","markConnected","isConnectedPeerId","isConnectedConn","setUserId","getUserId","hasFreshConn","getConn","delConn","delete","getConnectedPeerIds","Array","from","keys","filter","k","getNotConnectedPeerIds","forEachConnectedConns","callback","values","forEachConnsAcceptingMedia","includes","clearAll","size","console","log","entries","v","clear","getRemoteMediaType","registerRemoteMediaType","sdp","hasObjectProp","hasStringProp","offer","answer","createConnectionMap","cryptoKey","importCryptoKey","myPeer","initMyPeer","index","isSeed","rand4","type","Peer","getPeerJsConfigFromUrl","on","setTimeout","i","seedId","connectPeer","err","destroy","destroyed","error","initConnection","reconnect","disconnected","showConnectedStatus","peerIndexList","connect","broadcastData","data","peers","sendPayload","sendSDP","getMsid2MediaType","SDP","handlePayloadPeers","isArray","isValidPeerId","handlePayload","encrypted","payload","JSON","parse","decryptString","isObject","peerConnection","setRemoteDescription","syncAllTracks","createAnswer","setLocalDescription","e","info","sleep","Math","random","removeAllTracks","warn","handlePayloadSDP","payloadUserId","handlePayloadUserId","payloadMediaTypes","every","x","handlePayloadMediaTypes","connUserId","handlePayloadData","encryptString","stringify","send","timer","scheduleClose","clearTimeout","buf","addEventListener","pc","iceGatheringState","onicecandidate","negotiationScheduled","signalingState","createOffer","event","transceiver","mType","setupTrackStopOnLongMute","track","reInitMyPeer","waitSec","floor","force","existsAllSeeds","mediaTypeMap","stream","senders","getSenders","item","sender","addTrack","some","removeTrack","transport","dispatchEvent","Event","sendData","acceptMediaTypes","mTypes","transceivers","getTransceivers","getReceivers","receiver","find","t","readyState","has","Error","MediaStream","name","s","dispose","setupMap","WeakMap","onmute","timeout","currentDirection","stop","loopbackPeerConnection","Promise","resolve","reject","pcIn","RTCPeerConnection","pcOut","candidate","addIceCandidate","videoTrackToImageConverter","kind","canvas","document","createElement","ctx","getContext","imageCapture","ImageCapture","getImage","bitmap","grabFrame","width","height","drawImage","toDataURL","imageToVideoTrackConverter","canvasStream","captureStream","videoTrack","getVideoTracks","setImage","img","src","dataURL","Image","onload","onerror","webpackEmptyContext","req","code","module","exports"],"sourceRoot":""}