{"version":3,"file":"static/js/440.dbd677f7.chunk.js","mappings":"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","sources":["network/ipfsUtils.ts","network/ipfsRoom.ts","network/trackUtils.ts"],"sourcesContent":["import { hasObjectProp, hasStringProp } from \"../utils/types\";\n\nlet peerIndexCounter = 0;\n\nconst getNextPeerIndex = () => {\n  peerIndexCounter += 1;\n  return peerIndexCounter;\n};\n\nexport type Connection = {\n  peerIndex: number;\n  peer: string; // ipfsId\n  userId: string;\n  sendPc: RTCPeerConnection;\n  recvPc: RTCPeerConnection;\n};\n\nconst DEFAULT_CONFIG = {\n  iceServers: [\n    { urls: \"stun:stun.l.google.com:19302\" },\n    {\n      urls: \"turn:openrelay.metered.ca:80\",\n      username: \"openrelayproject\",\n      credential: \"openrelayproject\",\n    },\n  ],\n  sdpSemantics: \"unified-plan\",\n};\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Connection;\n    acceptingMediaTypes: string[];\n    remoteMediaTypes: Record<string, string>; // key = mid\n  };\n  const map = new Map<string, Value>();\n\n  const setAcceptingMediaTypes = (conn: Connection, mediaTypes: string[]) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.acceptingMediaTypes = mediaTypes;\n    }\n  };\n\n  const getAcceptingMediaTypes = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (!value) return [];\n    return value.acceptingMediaTypes;\n  };\n\n  const addConn = (peerId: string, userId: string) => {\n    const value = map.get(peerId);\n    if (value) {\n      throw new Error(\"addConn: already exists\");\n    }\n    const conn: Connection = {\n      peerIndex: getNextPeerIndex(),\n      peer: peerId,\n      userId,\n      sendPc: new RTCPeerConnection(DEFAULT_CONFIG),\n      recvPc: new RTCPeerConnection(DEFAULT_CONFIG),\n    };\n    map.set(conn.peer, {\n      conn,\n      acceptingMediaTypes: [],\n      remoteMediaTypes: {},\n    });\n    return conn;\n  };\n\n  const getConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return null;\n    return value.conn;\n  };\n\n  const findConn = (peerIndex: number) => {\n    const value = Array.from(map.values()).find(\n      (v) => v.conn.peerIndex === peerIndex\n    );\n    if (value) return value.conn;\n    return null;\n  };\n\n  const delConn = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n      conn.sendPc.close();\n      conn.recvPc.close();\n    } else {\n      throw new Error(\"delConn: does not exist\");\n    }\n  };\n\n  const getPeerIndexList = () =>\n    Array.from(map.values()).map((v) => v.conn.peerIndex);\n\n  const forEachConns = (callback: (conn: Connection) => void) => {\n    Array.from(map.values()).forEach((value) => {\n      callback(value.conn);\n    });\n  };\n\n  const forEachConnsAcceptingMedia = (\n    mediaType: string,\n    callback: (conn: Connection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.acceptingMediaTypes.includes(mediaType)) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const size = () => map.size;\n\n  const getRemoteMediaType = (conn: Connection, mid: string) => {\n    const value = map.get(conn.peer);\n    if (!value) return null;\n    return value.remoteMediaTypes[mid] || null;\n  };\n\n  const registerRemoteMediaTypeFromSDP = (\n    conn: Connection,\n    msid2mediaType: Record<string, unknown>,\n    sdpLines: string\n  ) => {\n    const value = map.get(conn.peer);\n    if (!value) return;\n    const lines = sdpLines.split(/[\\r\\n]+/);\n    let mid: string;\n    lines.forEach((line) => {\n      if (line.startsWith(\"a=mid:\")) {\n        mid = line.slice(\"a=mid:\".length);\n      } else if (line.startsWith(\"a=msid:\")) {\n        const arr = line.slice(\"a=msid:\".length).split(\" \");\n        arr.forEach((msid) => {\n          const mediaType = msid2mediaType[msid];\n          if (typeof mediaType === \"string\") {\n            value.remoteMediaTypes[mid] = mediaType;\n          }\n        });\n      }\n    });\n  };\n\n  const registerRemoteMediaType = (\n    conn: Connection,\n    sdp: Record<string, unknown>\n  ) => {\n    if (!hasObjectProp(sdp, \"msid2mediaType\")) return;\n    if (hasObjectProp(sdp, \"offer\") && hasStringProp(sdp.offer, \"sdp\")) {\n      registerRemoteMediaTypeFromSDP(conn, sdp.msid2mediaType, sdp.offer.sdp);\n    }\n    if (hasObjectProp(sdp, \"answer\") && hasStringProp(sdp.answer, \"sdp\")) {\n      registerRemoteMediaTypeFromSDP(conn, sdp.msid2mediaType, sdp.answer.sdp);\n    }\n  };\n\n  return {\n    setAcceptingMediaTypes,\n    getAcceptingMediaTypes,\n    addConn,\n    getConn,\n    findConn,\n    delConn,\n    getPeerIndexList,\n    forEachConns,\n    forEachConnsAcceptingMedia,\n    size,\n    getRemoteMediaType,\n    registerRemoteMediaType,\n  };\n};\n","import { create as createUntyped } from \"ipfs\";\nimport type { create as createFn } from \"ipfs-core/types/src/components/index\";\nimport type { Message } from \"ipfs-core-types/types/src/pubsub/index\";\nimport IpfsPubSubRoom from \"ipfs-pubsub-room\";\n\nimport { sleep } from \"../utils/sleep\";\nimport {\n  secureRandomId,\n  importCryptoKey,\n  encryptStringToChunks,\n  decryptStringFromChunks,\n} from \"../utils/crypto\";\nimport { getWebrtcStarFromUrl } from \"../utils/url\";\nimport { isObject, hasStringProp, hasObjectProp } from \"../utils/types\";\nimport { ROOM_ID_PREFIX_LEN, PeerInfo, CreateRoom } from \"./common\";\nimport { Connection, createConnectionMap } from \"./ipfsUtils\";\nimport { setupTrackStopOnLongMute } from \"./trackUtils\";\n\nconst create = createUntyped as typeof createFn;\n\nexport const createRoom: CreateRoom = async (\n  roomId,\n  userId,\n  updateNetworkStatus,\n  notifyNewPeer,\n  receiveData,\n  receiveTrack\n) => {\n  let disposed = false;\n  const connMap = createConnectionMap();\n  // if (process.env.NODE_ENV !== \"production\") {\n  (window as any).myConnMap = connMap;\n  // }\n  let mediaTypes: readonly string[] = [];\n\n  const roomTopic = roomId.slice(0, ROOM_ID_PREFIX_LEN);\n  const cryptoKey = await importCryptoKey(roomId.slice(ROOM_ID_PREFIX_LEN));\n\n  updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex: 0 });\n  const myIpfs = await create({\n    repo: secureRandomId(),\n    config: {\n      Addresses: {\n        Swarm: [\n          getWebrtcStarFromUrl() ||\n            \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\n        ],\n      },\n      Bootstrap: [], // not sure why this helps\n    },\n  });\n  const myPeerId = (await myIpfs.id()).id;\n  const myIpfsPubSubRoom = new IpfsPubSubRoom(\n    // https://github.com/ipfs-shipyard/ipfs-pubsub-room/pull/110\n    (myIpfs as any).libp2p,\n    roomTopic\n  );\n  myIpfsPubSubRoom.on(\"message\", (msg) => pubsubHandler(msg));\n  myIpfsPubSubRoom.on(\"peer joined\", () => {\n    broadcastData(null); // XXX this is not efficient, we don't need to broadcast\n  });\n  myIpfsPubSubRoom.on(\"peer left\", (peerId: string) => {\n    const conn = connMap.getConn(peerId);\n    if (conn) {\n      connMap.delConn(conn);\n      updateNetworkStatus({\n        type: \"CONNECTION_CLOSED\",\n        peerIndex: conn.peerIndex,\n      });\n    }\n  });\n  // if (process.env.NODE_ENV !== \"production\") {\n  (window as any).myIpfs = myIpfs;\n  // }\n\n  const parsePayload = async (encrypted: ArrayBuffer): Promise<unknown> => {\n    try {\n      const str = await decryptStringFromChunks(encrypted, cryptoKey);\n      if (str === null) return undefined;\n      const payload = JSON.parse(str);\n      // console.log(\"decrypted payload\", payload);\n      return payload;\n    } catch (e) {\n      console.info(\"Error in parsePayload\", e, encrypted);\n      return undefined;\n    }\n  };\n\n  const sendPayload = async (_topic: string, payload: unknown) => {\n    try {\n      // console.log(\"payload to encrypt\", topic, payload);\n      for await (const encrypted of encryptStringToChunks(\n        JSON.stringify(payload),\n        cryptoKey\n      )) {\n        myIpfsPubSubRoom.broadcast(encrypted);\n      }\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const sendPayloadDirectly = async (conn: Connection, payload: unknown) => {\n    try {\n      for await (const encrypted of encryptStringToChunks(\n        JSON.stringify(payload),\n        cryptoKey\n      )) {\n        myIpfsPubSubRoom.sendTo(conn.peer, encrypted);\n      }\n    } catch (e) {\n      console.error(\"sendPayloadDirectly\", e);\n    }\n  };\n\n  const broadcastData = async (data: unknown) => {\n    if (disposed) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayload(roomTopic, payload);\n  };\n\n  const sendData = async (data: unknown, peerIndex: number) => {\n    if (disposed) return;\n    const conn = connMap.findConn(peerIndex);\n    if (!conn) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayloadDirectly(conn, payload);\n  };\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).sendData = sendData;\n  }\n\n  const acceptMediaTypes = (mTypes: readonly string[]) => {\n    if (disposed) return;\n    if (mTypes.length !== mediaTypes.length) {\n      connMap.forEachConns((conn) => {\n        const info: PeerInfo = {\n          userId: conn.userId,\n          peerIndex: conn.peerIndex,\n          mediaTypes: connMap.getAcceptingMediaTypes(conn),\n        };\n        const transceivers = conn.recvPc.getTransceivers();\n        conn.recvPc.getReceivers().forEach((receiver) => {\n          const transceiver = transceivers.find((t) => t.receiver === receiver);\n          const mid = transceiver?.mid;\n          const mType = mid && connMap.getRemoteMediaType(conn, mid);\n          if (!mType) {\n            console.warn(\"failed to find media type from mid\");\n            return;\n          }\n          if (\n            receiver.track.readyState === \"live\" &&\n            !mediaTypes.includes(mType) &&\n            mTypes.includes(mType)\n          ) {\n            receiveTrack(\n              mType,\n              setupTrackStopOnLongMute(receiver.track, conn.recvPc),\n              info\n            );\n          }\n        });\n      });\n    }\n    mediaTypes = mTypes;\n    broadcastData(null);\n  };\n\n  const sendSDP = async (\n    conn: Connection,\n    sdp:\n      | {\n          negotiationId: string;\n          offer: RTCSessionDescriptionInit;\n        }\n      | {\n          negotiationId: string;\n          answer: RTCSessionDescriptionInit;\n        }\n  ) => {\n    const msid2mediaType = getMsid2MediaType();\n    await sendPayloadDirectly(conn, { SDP: { ...sdp, msid2mediaType } });\n  };\n\n  const handlePayloadSDP = async (conn: Connection, sdp: unknown) => {\n    if (!isObject(sdp)) return;\n    if (!hasStringProp(sdp, \"negotiationId\")) {\n      console.warn(\"negotiationId not found in SDP\");\n      return;\n    }\n    const { negotiationId } = sdp;\n    connMap.registerRemoteMediaType(conn, sdp);\n    if (hasObjectProp(sdp, \"offer\")) {\n      try {\n        await conn.recvPc.setRemoteDescription(\n          sdp.offer as unknown as RTCSessionDescriptionInit // FIXME\n        );\n        const answer = await conn.recvPc.createAnswer();\n        await conn.recvPc.setLocalDescription(answer);\n        sendSDP(conn, { negotiationId, answer });\n      } catch (e) {\n        console.info(\"handleSDP offer failed\", e);\n      }\n    } else if (hasObjectProp(sdp, \"answer\")) {\n      if (negotiationIdMap.get(conn) === negotiationId) {\n        negotiationIdMap.delete(conn);\n      }\n      try {\n        await conn.sendPc.setRemoteDescription(\n          sdp.answer as unknown as RTCSessionDescriptionInit // FIXME\n        );\n      } catch (e) {\n        console.info(\"handleSDP answer failed\", e);\n      }\n    } else {\n      console.warn(\"unknown SDP\", sdp);\n    }\n  };\n\n  const negotiationIdMap = new WeakMap<Connection, string>();\n  const startNegotiation = (conn: Connection) => {\n    const running = negotiationIdMap.has(conn);\n    negotiationIdMap.set(conn, secureRandomId());\n    if (running) return;\n    const negotiate = async () => {\n      const negotiationId = negotiationIdMap.get(conn);\n      if (!negotiationId) return;\n      if (conn.sendPc.signalingState === \"closed\") {\n        negotiationIdMap.delete(conn);\n        return;\n      }\n      const offer = await conn.sendPc.createOffer();\n      await conn.sendPc.setLocalDescription(offer);\n      await sendSDP(conn, { negotiationId, offer });\n      await sleep(5000);\n      negotiate();\n    };\n    negotiate();\n  };\n\n  const sendIce = (\n    conn: Connection,\n    ice: {\n      direction: \"send\" | \"recv\";\n      candidate: RTCIceCandidate;\n    }\n  ) => {\n    sendPayloadDirectly(conn, { ICE: ice });\n  };\n\n  const handlePayloadIce = (conn: Connection, ice: unknown) => {\n    if (!isObject(ice)) return;\n    if (!hasStringProp(ice, \"direction\")) {\n      console.warn(\"direction not found in ICE\");\n      return;\n    }\n    if (!hasObjectProp(ice, \"candidate\")) {\n      console.warn(\"candidate not found in ICE\");\n      return;\n    }\n    try {\n      if (ice.direction === \"send\") {\n        conn.recvPc.addIceCandidate(ice.candidate);\n      } else if (ice.direction === \"recv\") {\n        conn.sendPc.addIceCandidate(ice.candidate);\n      }\n    } catch (e) {\n      console.info(\"handleCandidate failed\", e);\n    }\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Connection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setAcceptingMediaTypes(conn, payloadMediaTypes as string[]);\n      await sleep(5000);\n      syncAllTracks(conn);\n    }\n  };\n\n  const handlePayloadData = (conn: Connection, data: unknown) => {\n    const info: PeerInfo = {\n      userId: conn.userId,\n      peerIndex: conn.peerIndex,\n      mediaTypes: connMap.getAcceptingMediaTypes(conn),\n    };\n    try {\n      receiveData(data, info);\n    } catch (e) {\n      console.warn(\"receiveData\", e);\n    }\n  };\n\n  const handlePayload = async (conn: Connection, payload: unknown) => {\n    try {\n      if (!isObject(payload)) return;\n\n      handlePayloadSDP(conn, (payload as { SDP?: unknown }).SDP);\n      handlePayloadIce(conn, (payload as { ICE?: unknown }).ICE);\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, payload);\n    }\n  };\n\n  const initConnection = (peerId: string, payloadUserId: string) => {\n    const conn = connMap.addConn(peerId, payloadUserId);\n    conn.sendPc.addEventListener(\"icecandidate\", ({ candidate }) => {\n      if (candidate) {\n        sendIce(conn, { direction: \"send\", candidate });\n      }\n    });\n    conn.recvPc.addEventListener(\"icecandidate\", ({ candidate }) => {\n      if (candidate) {\n        sendIce(conn, { direction: \"recv\", candidate });\n      }\n    });\n    conn.recvPc.addEventListener(\"track\", (event: RTCTrackEvent) => {\n      const { mid } = event.transceiver;\n      const mType = mid && connMap.getRemoteMediaType(conn, mid);\n      if (!mType) {\n        console.warn(\"failed to find media type from mid\");\n        return;\n      }\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      receiveTrack(\n        mType,\n        setupTrackStopOnLongMute(event.track, conn.recvPc),\n        info\n      );\n    });\n    notifyNewPeer(conn.peerIndex);\n    updateNetworkStatus({\n      type: \"NEW_CONNECTION\",\n      peerIndex: conn.peerIndex,\n    });\n    return conn;\n  };\n\n  const getUserIdFromPayload = (payload: unknown) => {\n    if (!isObject(payload)) return null;\n    const payloadUserId = (payload as { userId: unknown }).userId;\n    if (typeof payloadUserId !== \"string\") return null;\n    return payloadUserId;\n  };\n\n  const pubsubHandler = async (msg: Message) => {\n    if (disposed) return;\n    if (!(\"from\" in msg)) return;\n    if (msg.from.toString() === myPeerId.toString()) return;\n    const payload = await parsePayload(msg.data);\n    if (payload === undefined) return;\n    const payloadUserId = getUserIdFromPayload(payload);\n    let conn = connMap.getConn(msg.from.toString());\n    if (!conn) {\n      if (payloadUserId) {\n        conn = initConnection(msg.from.toString(), payloadUserId);\n      } else {\n        console.warn(\"cannot initialize conn without user id\");\n      }\n    }\n    if (conn) {\n      await handlePayload(conn, payload);\n    }\n    const peerIndexList = connMap.getPeerIndexList();\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const mediaTypeMap = new Map<\n    string,\n    {\n      stream: MediaStream;\n      track: MediaStreamTrack;\n    }\n  >();\n\n  const getMsid2MediaType = () => {\n    const msid2mediaType: Record<string, string> = {};\n    mediaTypeMap.forEach(({ stream }, mType) => {\n      msid2mediaType[stream.id] = mType;\n    });\n    return msid2mediaType;\n  };\n\n  const addTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (disposed) return;\n    if (mediaTypeMap.has(mediaType)) {\n      throw new Error(`track is already added for ${mediaType}`);\n    }\n    const stream = new MediaStream([track]);\n    mediaTypeMap.set(mediaType, { stream, track });\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      try {\n        conn.sendPc.addTrack(track, stream);\n        startNegotiation(conn);\n      } catch (e) {\n        if ((e as any).name === \"InvalidAccessError\") {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n    });\n  };\n\n  const removeTrack = (mediaType: string) => {\n    if (disposed) return;\n    const item = mediaTypeMap.get(mediaType);\n    if (!item) {\n      console.log(\"track is already removed for\", mediaType);\n      return;\n    }\n    const { track } = item;\n    mediaTypeMap.delete(mediaType);\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      const senders = conn.sendPc.getSenders();\n      const sender = senders.find((s) => s.track === track);\n      if (sender && conn.sendPc.signalingState !== \"closed\") {\n        conn.sendPc.removeTrack(sender);\n        startNegotiation(conn);\n      }\n    });\n  };\n\n  const syncAllTracks = (conn: Connection) => {\n    const senders = conn.sendPc.getSenders();\n    const acceptingMediaTypes = connMap.getAcceptingMediaTypes(conn);\n    acceptingMediaTypes.forEach((mType) => {\n      const item = mediaTypeMap.get(mType);\n      if (!item) return;\n      const { stream, track } = item;\n      if (senders.every((sender) => sender.track !== track)) {\n        conn.sendPc.addTrack(track, stream);\n        startNegotiation(conn);\n      }\n    });\n    senders.forEach((sender) => {\n      if (!sender.track) return;\n      const isEffective = acceptingMediaTypes.some(\n        (mType) => mediaTypeMap.get(mType)?.track === sender.track\n      );\n      if (!isEffective && conn.sendPc.signalingState !== \"closed\") {\n        conn.sendPc.removeTrack(sender);\n        startNegotiation(conn);\n      }\n    });\n  };\n\n  const dispose = async () => {\n    disposed = true;\n    await myIpfsPubSubRoom.leave();\n    await myIpfs.stop();\n  };\n\n  return {\n    broadcastData,\n    sendData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n","const setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = (timeout = 1000) => {\n    if (track.readyState === \"ended\") return;\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    } else if (timeout < 64000) {\n      setTimeout(() => {\n        onmute(timeout * 2);\n      }, timeout);\n    }\n  };\n  track.addEventListener(\"mute\", () => onmute());\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n\nexport const videoTrackToImageConverter = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") {\n    throw new Error(\"track kind is not video\");\n  }\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const imageCapture = new ImageCapture(track);\n  const getImage = async () => {\n    try {\n      const bitmap = await imageCapture.grabFrame();\n      canvas.width = bitmap.width;\n      canvas.height = bitmap.height;\n      ctx.drawImage(bitmap, 0, 0);\n      return canvas.toDataURL(\"image/jpeg\");\n    } catch (e) {\n      console.log(\"failed to grab frame from viedeo track\", e);\n      return null;\n    }\n  };\n  return { getImage };\n};\n\nconst createImage = (src: string): Promise<HTMLImageElement> =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n\nexport const imageToVideoTrackConverter = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const [videoTrack] = canvasStream.getVideoTracks();\n  const setImage = async (dataURL: string) => {\n    const img = await createImage(dataURL);\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n  };\n  return { videoTrack, setImage };\n};\n"],"names":["peerIndexCounter","DEFAULT_CONFIG","iceServers","urls","username","credential","sdpSemantics","create","createUntyped","createRoom","async","roomId","userId","updateNetworkStatus","notifyNewPeer","receiveData","receiveTrack","disposed","connMap","map","Map","registerRemoteMediaTypeFromSDP","conn","msid2mediaType","sdpLines","value","get","peer","mid","split","forEach","line","startsWith","slice","length","msid","mediaType","remoteMediaTypes","setAcceptingMediaTypes","mediaTypes","acceptingMediaTypes","getAcceptingMediaTypes","addConn","peerId","Error","peerIndex","sendPc","RTCPeerConnection","recvPc","set","getConn","findConn","Array","from","values","find","v","delConn","delete","close","getPeerIndexList","forEachConns","callback","forEachConnsAcceptingMedia","includes","size","getRemoteMediaType","registerRemoteMediaType","sdp","hasObjectProp","hasStringProp","offer","answer","createConnectionMap","window","myConnMap","roomTopic","ROOM_ID_PREFIX_LEN","cryptoKey","importCryptoKey","type","myIpfs","repo","secureRandomId","config","Addresses","Swarm","getWebrtcStarFromUrl","Bootstrap","myPeerId","id","myIpfsPubSubRoom","IpfsPubSubRoom","libp2p","on","msg","pubsubHandler","broadcastData","sendPayloadDirectly","payload","encrypted","encryptStringToChunks","JSON","stringify","sendTo","e","console","error","data","_topic","broadcast","sendPayload","sendSDP","getMsid2MediaType","SDP","negotiationIdMap","WeakMap","startNegotiation","running","has","negotiate","negotiationId","signalingState","createOffer","setLocalDescription","sleep","sendIce","ice","ICE","handlePayload","isObject","warn","setRemoteDescription","createAnswer","info","handlePayloadSDP","direction","addIceCandidate","candidate","handlePayloadIce","payloadMediaTypes","isArray","every","x","syncAllTracks","handlePayloadMediaTypes","handlePayloadData","toString","str","decryptStringFromChunks","parse","parsePayload","undefined","payloadUserId","getUserIdFromPayload","addEventListener","event","transceiver","mType","setupTrackStopOnLongMute","track","initConnection","peerIndexList","mediaTypeMap","stream","senders","getSenders","item","sender","addTrack","some","removeTrack","sendData","acceptMediaTypes","mTypes","transceivers","getTransceivers","getReceivers","receiver","t","readyState","MediaStream","name","log","s","dispose","leave","stop","setupMap","pc","onmute","timeout","currentDirection","setTimeout","dispatchEvent","Event","loopbackPeerConnection","Promise","resolve","reject","pcIn","pcOut","videoTrackToImageConverter","kind","canvas","document","createElement","ctx","getContext","imageCapture","ImageCapture","getImage","bitmap","grabFrame","width","height","drawImage","toDataURL","imageToVideoTrackConverter","canvasStream","captureStream","videoTrack","getVideoTracks","setImage","img","src","dataURL","Image","onload","onerror"],"sourceRoot":""}