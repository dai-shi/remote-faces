{"version":3,"sources":["utils/storage.ts","media/capture.ts","hooks/useFaceImages.ts","media/audio.ts","hooks/useFaceVideos.ts","components/FaceImages.tsx","hooks/useMomentaryChat.ts","utils/emoji.ts","components/WysiwygEditor.tsx","components/MomentaryChat.tsx","components/UserProfile.tsx","components/SingleRoom.tsx","network/trackUtils.ts","network/room.ts","hooks/useRoom.ts","utils/sleep.ts","utils/types.ts","hooks/useNicknameMap.ts","media/video.ts","media/devices.ts","hooks/useAvailableDevices.ts","../../node_modules/peerjs/dist sync"],"names":["setStringItem","name","value","window","localStorage","setItem","e","console","info","getStringItem","getItem","captureImage","stream","track","a","ImageCapture","imageCapture","sleep","takePhoto","blob","createImageBitmap","srcImg","grabFrame","srcW","width","srcH","height","video","document","getElementById","style","display","savedSrcObject","srcObject","revert","videoWidth","videoHeight","deviceId","constraints","navigator","mediaDevices","getUserMedia","getVideoTracks","canvas","ctx","getContext","dstW","dstH","ratio","Math","max","min","x","y","drawImage","stop","toDataURL","isImageData","isObject","image","nickname","message","liveMode","isFaceInfo","getAudioStream","audio","getAudioTracks","applyConstraints","echoCancellation","echoCancellationType","ideal","noiseSuppression","dispose","addTrackToStream","disposeStream","newStream","MediaStream","addTrack","dispatchEvent","MediaStreamTrackEvent","addEventListener","removeTrack","getTracks","length","FaceImage","React","memo","statusMesg","obsoleted","speakerOn","className","opacity","ref","videoEle","autoPlay","playsInline","muted","src","alt","title","FaceImages","roomId","userId","micOn","videoDeviceId","audioDeviceId","useState","myImage","setMyImage","roomImages","setRoomImages","fatalError","setFatalError","lastDataRef","useRef","useRoomNewPeer","useCallback","current","broadcastData","useBroadcastData","useRoomData","data","roomImage","received","Date","now","peerIndex","prev","find","item","map","useRoomNetworkStatus","networkStatus","type","changed","next","useEffect","timer","checkObsoletedImage","twoMinAgo","tenMinAgo","filter","loop","setTimeout","clearTimeout","useFaceImages","videoEnabled","audioEnabled","faceStream","setFaceStream","faceStreamMap","setFaceStreamMap","isMounted","onTrack","kind","isVideoTrackFaceSize","useRoomMedia","undefined","addVideoTrack","removeVideoTrack","addAudioTrack","removeAudioTrack","getFaceVideoStream","videoStream","disposeVideo","videoTrack","Event","audioStream","disposeAudio","audioTrack","forEach","enabled","onaddtrack","event","removeEventListener","useFaceVideos","key","compareReply","b","countDiff","useMomentaryChat","chatHistory","chatList","setChatList","addChatItem","chatData","some","messageId","unshift","pop","chatInReplyTo","chatText","replyMap","Map","replies","set","get","entries","sort","chatItem","createdAt","text","time","toLocaleString","split","slice","newList","i","random","sendChat","secureRandomId","replyChat","inReplyTo","EmojiPicker","Picker","config","toolbar","balloonToolbar","link","addTargetToExternalLinks","WysiwygEditor","registerClear","onChange","editor","CustomEditor","onInit","setData","plugins","addItems","character","initEditor","_event","getData","MomentaryChatContentPart","openEmojiPicker","setOpenEmojiPicker","reply","onSelect","native","onClick","dangerouslySetInnerHTML","__html","DOMPurify","sanitize","ADD_ATTR","count","MomentaryChatContent","chatListRef","latestMessageId","scrollTop","scrollHeight","MomentaryChat","containerRef","clearRef","setText","clear","disabled","TextField","initialText","onUpdate","buttonLabel","placeholder","clearOnUpdate","onSubmit","preventDefault","target","UserProfile","initialNickname","emoji","onUpdateNickname","onUpdateStatusMesg","onUpdateEmoji","size","ScreenShare","lazy","VideoShare","CollabWhiteBoard","initialConfigOpen","initialVideoDeviceId","initialAudioDeviceId","SingleRoom","setNickname","setStatusMesg","setEmoji","setRoomIdToUrl","videoDevices","useVideoDevices","audioDevices","useAudioDevices","setVideoDeviceId","setAudioDeviceId","setLiveMode","setMicOn","setSpeakerOn","screenShareMode","setScreenShareMode","videoShareMode","setVideoShareMode","collabWBOpen","setCollabWBOpen","configOpen","setConfigOpen","useNicknameMap","appLink","location","href","replace","o","readOnly","videoDevice","label","audioDevice","checked","JSON","stringify","setupMap","WeakMap","setupTrackStopOnLongMute","pc","has","onmute","transceiver","getTransceivers","t","receiver","currentDirection","guessSeed","id","getPeerIndexFromPeerId","roomEntryMap","register","listeners","roomEntryKey","entry","networkStatusListeners","Set","newPeerListeners","dataListeners","trackListeners","room","updateNetworkStatus","notifyNewPeer","receiveData","receiveTrack","disposed","myPeer","connMap","createConnectionMap","mediaTypes","localStream","showConnectedStatus","peerIndexList","getConnectedPeerIds","connectPeer","disconnected","hasConn","log","conn","connect","initConnection","peers","forEachConnectedConns","sendPayload","sendSDP","sdp","SDP","handlePayloadSDP","offer","peerConnection","setRemoteDescription","syncAllTracks","createAnswer","answer","setLocalDescription","removeAllTracks","warn","handlePayloadUserId","payloadUserId","setUserId","handlePayloadMediaTypes","payloadMediaTypes","Array","isArray","every","setMediaTypes","handlePayloadData","connUserId","getUserId","getPeerIndexFromConn","getMediaTypes","handlePayload","encrypted","decrypt","ROOM_ID_PREFIX_LEN","payload","parse","peer","isValidPeerId","encrypt","send","error","isConnected","close","addConn","on","markConnected","buf","iceGatheringState","onicecandidate","scheduledNegotiation","delete","createOffer","delConn","reInitMyPeer","waitSec","floor","initMyPeer","index","clearAll","isSeed","rand4","generatePeerId","Peer","getServerConfigFromUrl","debug","seedId","err","destroy","destroyed","reconnect","force","existsAllSeeds","oldPeer","trackMediaTypeMap","senders","getSenders","mTypes","mType","includes","sender","transport","acceptMediaTypes","getReceivers","mediaType","forEachConnsAcceptingMedia","s","createRoom","status","listener","sendInitialData","networkStatusListener","add","newPeerListener","dataListener","trackListener","mediaTypeSet","from","prevSize","definedEntry","unregister","onNetworkStatus","Error","ns","getInitialDataIterator","broadcastDataRef","registered","onRoomData","functions","setFunctions","result","ms","Promise","resolve","cache","createMapFromCache","nicknameMap","setNicknameMap","findIndex","lastUpdated","push","splice","keys","Object","getVideoStream","canvasStream","captureStream","checkVideTrackFaceSize","createElement","videoTrackFaceSizeMap","promise","getVideoDeviceInfoList","enumerateDevices","devices","list","getAudioDeviceInfoList","setDevices","deviceInfoList","webpackEmptyContext","req","code","module","exports"],"mappings":"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","file":"static/js/4.5b65ce9e.chunk.js","sourcesContent":["type StringItemName =\n  | \"nickname\"\n  | \"config_hidden\"\n  | \"faceimage_video_device_id\"\n  | \"faceimage_audio_device_id\";\n\ntype JsonItemName = \"TODO2\" | \"TODO3\";\n\nexport const setStringItem = (name: StringItemName, value: string) => {\n  try {\n    window.localStorage.setItem(name, value);\n  } catch (e) {\n    console.info(\"Failed to save string to localStorage\", e);\n  }\n};\n\nexport const getStringItem = (name: StringItemName) => {\n  try {\n    return window.localStorage.getItem(name) || \"\";\n  } catch (e) {\n    // ignore\n    return \"\";\n  }\n};\n\nexport const setJsonItem = (name: JsonItemName, value: unknown) => {\n  try {\n    window.localStorage.setItem(name, JSON.stringify(value));\n  } catch (e) {\n    console.info(\"Failed to save json to localStorage\", e);\n  }\n};\n\nexport const getJsonItem = (name: JsonItemName): unknown | null => {\n  try {\n    return JSON.parse(window.localStorage.getItem(name) || \"\");\n  } catch (e) {\n    // ignore\n    return null;\n  }\n};\n\nexport const removeItem = (name: StringItemName | JsonItemName) => {\n  try {\n    window.localStorage.removeItem(name);\n  } catch (e) {\n    // ignore\n  }\n};\n","import { sleep } from \"../utils/sleep\";\n\nconst captureImage = async (stream: MediaStream, track: MediaStreamTrack) => {\n  if (typeof ImageCapture !== \"undefined\") {\n    const imageCapture = new ImageCapture(track);\n    await sleep(2000);\n    let srcImg;\n    try {\n      const blob = await imageCapture.takePhoto();\n      srcImg = await createImageBitmap(blob);\n    } catch (e) {\n      srcImg = await imageCapture.grabFrame();\n    }\n    const srcW = srcImg.width;\n    const srcH = srcImg.height;\n    return { srcImg, srcW, srcH };\n  }\n  const video = document.getElementById(\"internal-video\") as HTMLVideoElement;\n  video.style.display = \"block\";\n  const savedSrcObject = video.srcObject;\n  const revert = () => {\n    video.srcObject = savedSrcObject;\n  };\n  video.srcObject = stream;\n  await sleep(2000);\n  const srcImg = video;\n  const srcW = video.videoWidth;\n  const srcH = video.videoHeight;\n  return { srcImg, srcW, srcH, revert };\n};\n\nexport const takePhoto = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        video: { deviceId },\n      }\n    : { video: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const [track] = stream.getVideoTracks();\n  const canvas = document.getElementById(\n    \"internal-canvas\"\n  ) as HTMLCanvasElement;\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const dstW = 72;\n  const dstH = 72;\n  canvas.width = dstW;\n  canvas.height = dstH;\n  const { srcImg, srcW, srcH, revert } = await captureImage(stream, track);\n  const ratio = Math.max(dstW / srcW, dstH / srcH);\n  const width = Math.min(srcW, dstW / ratio);\n  const height = Math.min(srcH, dstH / ratio);\n  const x = (srcW - width) / 2;\n  const y = (srcH - height) / 2;\n  ctx.drawImage(srcImg, x, y, width, height, 0, 0, dstW, dstH);\n  if (revert) {\n    revert();\n  }\n  track.stop();\n  return canvas.toDataURL(\"image/jpeg\");\n};\n","import { useCallback, useEffect, useState, useRef } from \"react\";\n\nimport { isObject } from \"../utils/types\";\nimport { takePhoto } from \"../media/capture\";\nimport {\n  useRoomData,\n  useBroadcastData,\n  useRoomNetworkStatus,\n  useRoomNewPeer,\n} from \"./useRoom\";\n\ntype ImageUrl = string;\ntype FaceInfo = {\n  nickname: string;\n  message: string;\n  liveMode: boolean;\n};\ntype ImageData = {\n  image: ImageUrl;\n  info: FaceInfo;\n};\ntype RoomImage = ImageData & {\n  userId: string;\n  received: number; // in milliseconds\n  obsoleted: boolean;\n  peerIndex: number;\n};\n\nconst isFaceInfo = (x: unknown): x is FaceInfo =>\n  isObject(x) &&\n  typeof (x as { nickname: unknown }).nickname === \"string\" &&\n  typeof (x as { message: unknown }).message === \"string\" &&\n  typeof (x as { liveMode: unknown }).liveMode === \"boolean\";\n\nconst isImageData = (x: unknown): x is ImageData =>\n  isObject(x) &&\n  typeof (x as { image: unknown }).image === \"string\" &&\n  isFaceInfo((x as { info: unknown }).info);\n\nexport const useFaceImages = (\n  roomId: string,\n  userId: string,\n  nickname: string,\n  statusMesg: string,\n  liveMode: boolean,\n  deviceId?: string\n) => {\n  const [myImage, setMyImage] = useState<ImageUrl>();\n  const [roomImages, setRoomImages] = useState<RoomImage[]>([]);\n\n  const [fatalError, setFatalError] = useState<Error>();\n  if (fatalError) {\n    throw fatalError;\n  }\n\n  const lastDataRef = useRef<ImageData>();\n  useRoomNewPeer(\n    roomId,\n    userId,\n    useCallback(async function* getInitialDataIterator() {\n      if (!lastDataRef.current) return;\n      yield lastDataRef.current;\n    }, [])\n  );\n\n  const broadcastData = useBroadcastData(roomId, userId);\n  useRoomData(\n    roomId,\n    userId,\n    useCallback((data, info) => {\n      if (!isImageData(data)) return;\n      const roomImage = {\n        ...data,\n        userId: info.userId,\n        received: Date.now(),\n        obsoleted: false,\n        peerIndex: info.peerIndex,\n      };\n      setRoomImages((prev) => {\n        const found = prev.find((item) => item.userId === roomImage.userId);\n        if (!found) {\n          return [...prev, roomImage];\n        }\n        return prev.map((item) =>\n          item.userId === roomImage.userId ? roomImage : item\n        );\n      });\n    }, [])\n  );\n\n  useRoomNetworkStatus(\n    roomId,\n    userId,\n    useCallback((networkStatus) => {\n      if (networkStatus && networkStatus.type === \"CONNECTION_CLOSED\") {\n        const { peerIndex } = networkStatus;\n        setRoomImages((prev) => {\n          let changed = false;\n          const next = prev.map((item) => {\n            if (item.peerIndex === peerIndex) {\n              changed = true;\n              return { ...item, obsoleted: true };\n            }\n            return item;\n          });\n          return changed ? next : prev;\n        });\n      }\n    }, [])\n  );\n\n  useEffect(() => {\n    const checkObsoletedImage = () => {\n      const twoMinAgo = Date.now() - 2 * 60 * 1000;\n      const tenMinAgo = Date.now() - 10 * 60 * 1000;\n      setRoomImages((prev) => {\n        let changed = false;\n        const next = prev\n          .map((item) => {\n            if (item.received < twoMinAgo && !item.obsoleted) {\n              changed = true;\n              return { ...item, obsoleted: true };\n            }\n            if (item.received < tenMinAgo && item.obsoleted) {\n              changed = true;\n              return null;\n            }\n            return item;\n          })\n          .filter((item) => item) as typeof prev;\n\n        return changed ? next : prev;\n      });\n    };\n    let timer: NodeJS.Timeout;\n    const loop = async () => {\n      try {\n        checkObsoletedImage();\n        const image = await takePhoto(deviceId);\n        setMyImage(image);\n        const info: FaceInfo = { nickname, message: statusMesg, liveMode };\n        const data: ImageData = {\n          image,\n          info,\n        };\n        broadcastData(data);\n        lastDataRef.current = data;\n      } catch (e) {\n        setFatalError(e);\n      }\n      timer = setTimeout(loop, 2 * 60 * 1000);\n    };\n    loop();\n    return () => {\n      clearTimeout(timer);\n    };\n  }, [roomId, userId, deviceId, nickname, statusMesg, liveMode, broadcastData]);\n\n  return {\n    myImage,\n    roomImages,\n  };\n};\n","export const getAudioStream = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        audio: { deviceId },\n      }\n    : { audio: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const [track] = stream.getAudioTracks();\n  await track.applyConstraints({\n    echoCancellation: true,\n    echoCancellationType: { ideal: \"system\" },\n    noiseSuppression: { ideal: true },\n  } as MediaTrackConstraints);\n  const dispose = () => {\n    track.stop();\n  };\n  return {\n    stream,\n    dispose,\n  };\n};\n","import { useCallback, useEffect, useState, useRef } from \"react\";\n\nimport { getFaceVideoStream, isVideoTrackFaceSize } from \"../media/video\";\nimport { getAudioStream } from \"../media/audio\";\nimport { useRoomMedia } from \"./useRoom\";\n\nconst addTrackToStream = (\n  track: MediaStreamTrack,\n  stream: MediaStream | null,\n  disposeStream: () => void\n) => {\n  const newStream = stream || new MediaStream();\n  newStream.addTrack(track);\n  newStream.dispatchEvent(new MediaStreamTrackEvent(\"addtrack\", { track }));\n  track.addEventListener(\"ended\", () => {\n    newStream.removeTrack(track);\n    if (newStream.getTracks().length === 0) {\n      disposeStream();\n    }\n  });\n  return newStream;\n};\n\nexport const useFaceVideos = (\n  roomId: string,\n  userId: string,\n  videoEnabled: boolean,\n  audioEnabled: boolean,\n  micOn: boolean,\n  videoDeviceId?: string,\n  audioDeviceId?: string\n) => {\n  const [faceStream, setFaceStream] = useState<MediaStream | null>(null);\n  const [faceStreamMap, setFaceStreamMap] = useState<{\n    [userId: string]: MediaStream;\n  }>({});\n\n  const isMounted = useRef(true);\n  useEffect(() => {\n    isMounted.current = false;\n  }, []);\n\n  const onTrack = useCallback(async (track, info) => {\n    if (track.kind === \"video\" && !(await isVideoTrackFaceSize(track))) {\n      return;\n    }\n    const disposeStream = () => {\n      if (isMounted.current) {\n        setFaceStreamMap((prev) => {\n          const { [info.userId]: _, ...rest } = prev;\n          return rest;\n        });\n      }\n    };\n    setFaceStreamMap((prev) => {\n      const stream = prev[info.userId];\n      const newStream = addTrackToStream(track, stream, disposeStream);\n      if (stream === newStream) {\n        return prev;\n      }\n      return { ...prev, [info.userId]: newStream };\n    });\n  }, []);\n\n  const {\n    addTrack: addVideoTrack,\n    removeTrack: removeVideoTrack,\n  } = useRoomMedia(\n    roomId,\n    userId,\n    onTrack,\n    videoEnabled ? \"faceVideo\" : undefined\n  );\n\n  const {\n    addTrack: addAudioTrack,\n    removeTrack: removeAudioTrack,\n  } = useRoomMedia(\n    roomId,\n    userId,\n    onTrack,\n    audioEnabled ? \"faceAudio\" : undefined\n  );\n\n  useEffect(() => {\n    let dispose: (() => void) | null = null;\n    if (videoEnabled && addVideoTrack && removeVideoTrack) {\n      (async () => {\n        const {\n          stream: videoStream,\n          dispose: disposeVideo,\n        } = await getFaceVideoStream(videoDeviceId);\n        const [videoTrack] = videoStream.getVideoTracks();\n        addVideoTrack(videoTrack);\n        const disposeStream = () => {\n          if (isMounted.current) {\n            setFaceStream(null);\n          }\n        };\n        setFaceStream((prev) =>\n          addTrackToStream(videoTrack, prev, disposeStream)\n        );\n        dispose = () => {\n          removeVideoTrack(videoTrack);\n          disposeVideo();\n          // XXX we need to manually dispatch ended event, why?\n          videoTrack.dispatchEvent(new Event(\"ended\"));\n        };\n      })();\n    }\n    return () => {\n      if (dispose) dispose();\n    };\n  }, [roomId, videoEnabled, videoDeviceId, addVideoTrack, removeVideoTrack]);\n\n  useEffect(() => {\n    let dispose: (() => void) | null = null;\n    if (audioEnabled && addAudioTrack && removeAudioTrack) {\n      (async () => {\n        const {\n          stream: audioStream,\n          dispose: disposeAudio,\n        } = await getAudioStream(audioDeviceId);\n        const [audioTrack] = audioStream.getAudioTracks();\n        addAudioTrack(audioTrack);\n        const disposeStream = () => {\n          if (isMounted.current) {\n            setFaceStream(null);\n          }\n        };\n        setFaceStream((prev) =>\n          addTrackToStream(audioTrack, prev, disposeStream)\n        );\n        dispose = () => {\n          removeAudioTrack(audioTrack);\n          disposeAudio();\n          // XXX we need to manually dispatch ended event, why?\n          audioTrack.dispatchEvent(new Event(\"ended\"));\n        };\n      })();\n    }\n    return () => {\n      if (dispose) dispose();\n    };\n  }, [roomId, audioEnabled, audioDeviceId, addAudioTrack, removeAudioTrack]);\n  useEffect(() => {\n    if (faceStream) {\n      faceStream.getAudioTracks().forEach((track) => {\n        const audioTrack = track;\n        audioTrack.enabled = micOn;\n      });\n      const onaddtrack = (event: MediaStreamTrackEvent) => {\n        const { track } = event;\n        if (track.kind === \"audio\") {\n          track.enabled = micOn;\n        }\n      };\n      faceStream.addEventListener(\"addtrack\", onaddtrack);\n      return () => {\n        faceStream.removeEventListener(\"addtrack\", onaddtrack);\n      };\n    }\n    return undefined;\n  }, [faceStream, micOn]);\n\n  return { faceStream, faceStreamMap };\n};\n","import React from \"react\";\n\nimport \"./FaceImages.css\";\nimport { useFaceImages } from \"../hooks/useFaceImages\";\nimport { useFaceVideos } from \"../hooks/useFaceVideos\";\n\nconst BLANK_IMAGE =\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQI12NgYAAAAAMAASDVlMcAAAAASUVORK5CYII=\";\n\nconst FaceImage = React.memo<{\n  image?: string;\n  nickname: string;\n  statusMesg: string;\n  obsoleted?: boolean;\n  liveMode?: boolean;\n  stream?: MediaStream;\n  speakerOn?: boolean;\n}>(\n  ({ image, nickname, statusMesg, obsoleted, liveMode, stream, speakerOn }) => (\n    <div className=\"FaceImages-card\" style={{ opacity: obsoleted ? 0.2 : 1 }}>\n      {liveMode && !obsoleted && stream ? (\n        <video\n          className=\"FaceImages-photo\"\n          ref={(videoEle) => {\n            if (videoEle && videoEle.srcObject !== stream) {\n              // eslint-disable-next-line no-param-reassign\n              videoEle.srcObject = stream;\n            }\n          }}\n          autoPlay\n          playsInline\n          muted={!speakerOn}\n        />\n      ) : (\n        <img\n          src={image || BLANK_IMAGE}\n          className=\"FaceImages-photo\"\n          alt=\"myself\"\n        />\n      )}\n      <div className=\"FaceImages-name\">{nickname}</div>\n      <div className=\"FaceImages-mesg\">{statusMesg}</div>\n      {liveMode && !obsoleted && stream && (\n        <div className=\"FaceImages-live-indicator\" title=\"Live Mode On\">\n          &#9673;\n        </div>\n      )}\n      {liveMode && !obsoleted && !stream && (\n        <div className=\"FaceImages-live-indicator\" title=\"Live Mode Available\">\n          &#9678;\n        </div>\n      )}\n    </div>\n  )\n);\n\nexport const FaceImages = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n  statusMesg: string;\n  liveMode: boolean;\n  micOn: boolean;\n  speakerOn: boolean;\n  videoDeviceId?: string;\n  audioDeviceId?: string;\n}>(\n  ({\n    roomId,\n    userId,\n    nickname,\n    statusMesg,\n    liveMode,\n    micOn,\n    speakerOn,\n    videoDeviceId,\n    audioDeviceId,\n  }) => {\n    const { myImage, roomImages } = useFaceImages(\n      roomId,\n      userId,\n      nickname,\n      statusMesg,\n      liveMode,\n      videoDeviceId\n    );\n    const { faceStream, faceStreamMap } = useFaceVideos(\n      roomId,\n      userId,\n      liveMode,\n      liveMode,\n      micOn,\n      videoDeviceId,\n      audioDeviceId\n    );\n\n    return (\n      <div className=\"FaceImage-container\">\n        <FaceImage\n          image={myImage}\n          nickname={nickname}\n          statusMesg={statusMesg}\n          liveMode={liveMode}\n          stream={faceStream || undefined}\n        />\n        {roomImages.map((item) => (\n          <FaceImage\n            key={item.userId}\n            image={item.image}\n            nickname={item.info.nickname}\n            statusMesg={item.info.message}\n            obsoleted={item.obsoleted}\n            liveMode={item.info.liveMode}\n            stream={(liveMode && faceStreamMap[item.userId]) || undefined}\n            speakerOn={speakerOn}\n          />\n        ))}\n      </div>\n    );\n  }\n);\n","import { useState, useCallback, useRef } from \"react\";\n\nimport { sleep } from \"../utils/sleep\";\nimport { secureRandomId } from \"../utils/crypto\";\nimport { isObject } from \"../utils/types\";\nimport { useRoomData, useBroadcastData, useRoomNewPeer } from \"./useRoom\";\n\nconst MAX_CHAT_LIST_SIZE = 100;\nconst MAX_CHAT_HISTORY_SIZE = 1000;\n\ntype ChatData = {\n  userId: string;\n  nickname: string;\n  messageId: string;\n  createdAt: number; // in millisecond\n  chatText: string;\n  chatInReplyTo?: string; // messageId\n};\n\nconst isChatData = (x: unknown): x is ChatData =>\n  isObject(x) &&\n  typeof (x as { userId: unknown }).userId === \"string\" &&\n  typeof (x as { nickname: unknown }).nickname === \"string\" &&\n  typeof (x as { messageId: unknown }).messageId === \"string\" &&\n  typeof (x as { createdAt: unknown }).createdAt === \"number\" &&\n  typeof (x as { chatText: unknown }).chatText === \"string\" &&\n  (typeof (x as { chatInReplyTo: unknown }).chatInReplyTo === \"undefined\" ||\n    typeof (x as { chatInReplyTo: unknown }).chatInReplyTo === \"string\");\n\ntype Reply = [string, number];\n\nexport type ChatItem = {\n  messageId: string;\n  nickname: string;\n  createdAt: number; // in millisecond\n  text: string;\n  replies: Reply[];\n  time: string;\n};\n\nconst compareReply = (a: Reply, b: Reply) => {\n  const countDiff = b[1] - a[1];\n  if (countDiff === 0) {\n    return a[0].length - b[0].length;\n  }\n  return countDiff;\n};\n\nexport const useMomentaryChat = (\n  roomId: string,\n  userId: string,\n  nickname: string\n) => {\n  const chatHistory = useRef<ChatData[]>([]);\n  const [chatList, setChatList] = useState<ChatItem[]>([]);\n\n  const addChatItem = useCallback((chatData: ChatData) => {\n    if (chatHistory.current.some((x) => x.messageId === chatData.messageId)) {\n      return;\n    }\n    chatHistory.current.unshift(chatData);\n    if (chatHistory.current.length > MAX_CHAT_HISTORY_SIZE) {\n      chatHistory.current.pop();\n    }\n    if (chatData.chatInReplyTo) {\n      const { chatText, chatInReplyTo } = chatData;\n      setChatList((prev) =>\n        prev.map((item) => {\n          if (item.messageId === chatInReplyTo) {\n            const replyMap = new Map(item.replies);\n            replyMap.set(chatText, (replyMap.get(chatText) || 0) + 1);\n            const replies = [...replyMap.entries()];\n            replies.sort(compareReply);\n            return { ...item, replies };\n          }\n          return item;\n        })\n      );\n      return;\n    }\n    const chatItem: ChatItem = {\n      messageId: chatData.messageId,\n      nickname: chatData.nickname,\n      createdAt: chatData.createdAt,\n      text: chatData.chatText,\n      replies: [],\n      time: new Date(chatData.createdAt)\n        .toLocaleString()\n        .split(\" \")[1]\n        .slice(0, -3),\n    };\n    setChatList((prev) => {\n      const newList = [chatItem, ...prev];\n      if (newList.length > MAX_CHAT_LIST_SIZE) {\n        newList.pop();\n      }\n      newList.sort((a, b) => b.createdAt - a.createdAt); // slow?\n      return newList;\n    });\n  }, []);\n\n  useRoomNewPeer(\n    roomId,\n    userId,\n    useCallback(async function* getInitialDataIterator() {\n      // TODO do not let all peers send initial data\n      // XXX it might be better to return packed chatList\n      for (let i = chatHistory.current.length - 1; i >= 0; i -= 1) {\n        // eslint-disable-next-line no-await-in-loop\n        await sleep(Math.random() * 5000);\n        yield chatHistory.current[i];\n      }\n    }, [])\n  );\n\n  const broadcastData = useBroadcastData(roomId, userId);\n  useRoomData(\n    roomId,\n    userId,\n    useCallback(\n      (data) => {\n        if (!isChatData(data)) return;\n        addChatItem(data);\n      },\n      [addChatItem]\n    )\n  );\n\n  const sendChat = useCallback(\n    (text: string) => {\n      const data: ChatData = {\n        userId,\n        nickname,\n        messageId: secureRandomId(),\n        createdAt: Date.now(),\n        chatText: text,\n      };\n      broadcastData(data);\n      addChatItem(data);\n    },\n    [broadcastData, userId, nickname, addChatItem]\n  );\n\n  const replyChat = useCallback(\n    (text: string, inReplyTo: string) => {\n      const data: ChatData = {\n        userId,\n        nickname,\n        messageId: secureRandomId(),\n        createdAt: Date.now(),\n        chatText: text,\n        chatInReplyTo: inReplyTo,\n      };\n      broadcastData(data);\n      addChatItem(data);\n    },\n    [broadcastData, userId, nickname, addChatItem]\n  );\n\n  return {\n    chatList,\n    sendChat,\n    replyChat,\n  };\n};\n","import React from \"react\";\nimport \"emoji-mart/css/emoji-mart.css\";\nimport { BaseEmoji, Picker } from \"emoji-mart\";\n\nexport { Emoji } from \"emoji-mart\";\nexport type EmojiDataType = BaseEmoji;\n\n// we do not support custom emojis\nexport const EmojiPicker = Picker as React.ComponentType<\n  | Omit<React.ComponentProps<typeof Picker>, \"custom\" | \"onSelect\">\n  | {\n      onSelect: (emoji: BaseEmoji) => void;\n    }\n>;\n","// @ts-nocheck XXX ckeditor5 doesn't come with types\n\nimport React from \"react\";\nimport CKEditor from \"@ckeditor/ckeditor5-react\";\nimport CustomEditor from \"@daishi/ckeditor5-build-inline-custom\";\n\nimport \"./WysiwygEditor.css\";\n\nconst config = {\n  toolbar: [\n    \"specialCharacters\",\n    \"|\",\n    \"bold\",\n    \"italic\",\n    \"link\",\n    \"blockQuote\",\n    \"|\",\n    \"imageUpload\",\n    \"insertTable\",\n    \"mediaEmbed\",\n    \"|\",\n    \"undo\",\n    \"redo\",\n  ],\n  balloonToolbar: [\n    \"heading\",\n    \"|\",\n    \"bulletedList\",\n    \"numberedList\",\n    \"indent\",\n    \"outdent\",\n  ],\n  link: {\n    addTargetToExternalLinks: true,\n  },\n};\n\nconst initEditor = (editor) => {\n  editor.plugins.get(\"SpecialCharacters\").addItems(\"Emoji\", [\n    { title: \"smiley face\", character: \"\" },\n    { title: \"rocket\", character: \"\" },\n    { title: \"wind blowing face\", character: \"\" },\n    { title: \"floppy disk\", character: \"\" },\n    { title: \"heart\", character: \"\" },\n  ]);\n};\n\nexport const WysiwygEditor = React.memo<{\n  registerClear: (clear: () => void) => void;\n  onChange: (data: string) => void;\n}>(({ registerClear, onChange }) => (\n  <CKEditor\n    editor={CustomEditor}\n    config={config}\n    onInit={(editor) => {\n      registerClear(() => {\n        editor.setData(\"\");\n      });\n      initEditor(editor);\n    }}\n    onChange={(_event, editor) => {\n      const data = editor.getData();\n      onChange(data);\n    }}\n  />\n));\n","import React, { useState, useRef, useEffect } from \"react\";\nimport DOMPurify from \"dompurify\";\n\nimport \"./MomentaryChat.css\";\nimport { useMomentaryChat, ChatItem } from \"../hooks/useMomentaryChat\";\nimport { EmojiPicker } from \"../utils/emoji\";\nimport { WysiwygEditor } from \"./WysiwygEditor\";\n\ntype ChatList = ReturnType<typeof useMomentaryChat>[\"chatList\"];\ntype ReplyChat = ReturnType<typeof useMomentaryChat>[\"replyChat\"];\n\nconst sanitize = (text: string) => ({\n  __html: DOMPurify.sanitize(text, { ADD_ATTR: [\"target\"] }),\n});\n\nconst MomentaryChatContentPart = React.memo<{\n  item: ChatItem;\n  replyChat: ReplyChat;\n}>(({ item, replyChat }) => {\n  const [openEmojiPicker, setOpenEmojiPicker] = useState(false);\n  const reply = (text: string) => replyChat(text, item.messageId);\n  return (\n    <li key={item.messageId} className=\"MomentaryChat-listPart\">\n      {openEmojiPicker && (\n        <EmojiPicker\n          onSelect={(e) => {\n            reply(e.native);\n            setOpenEmojiPicker(false);\n          }}\n        />\n      )}\n      <div className=\"MomentaryChat-listPart-header\">\n        <div className=\"MomentaryChat-iconButton-container\">\n          <div className=\"MomentaryChat-iconButton\">\n            <button\n              type=\"button\"\n              onClick={() => {\n                setOpenEmojiPicker(!openEmojiPicker);\n              }}\n            >\n              +\n            </button>\n          </div>\n        </div>\n        <span className=\"MomentaryChat-nickname\">\n          {item.nickname || \"No Name\"}\n        </span>\n        <span className=\"MomentaryChat-time\">{item.time}</span>\n      </div>\n      <div\n        className=\"MomentaryChat-text ck-content\"\n        dangerouslySetInnerHTML={sanitize(item.text)}\n      />\n      {item.replies.map(([text, count]) => (\n        <button\n          key={text}\n          className=\"MomentaryChat-icon\"\n          type=\"button\"\n          onClick={() => reply(text)}\n        >\n          {text} {count}\n        </button>\n      ))}\n    </li>\n  );\n});\n\nconst MomentaryChatContent = React.memo<{\n  chatList: ChatList;\n  replyChat: ReplyChat;\n}>(({ chatList, replyChat }) => {\n  const chatListRef = useRef<HTMLUListElement | null>(null);\n  const latestMessageId = chatList[0]?.messageId;\n  useEffect(() => {\n    if (chatListRef.current && latestMessageId) {\n      chatListRef.current.scrollTop = chatListRef.current.scrollHeight;\n    }\n  }, [latestMessageId]);\n\n  return (\n    <ul className=\"MomentaryChat-list\" ref={chatListRef}>\n      {chatList.map((item) => (\n        <MomentaryChatContentPart\n          key={item.messageId}\n          item={item}\n          replyChat={replyChat}\n        />\n      ))}\n    </ul>\n  );\n});\n\nexport const MomentaryChat = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n}>(({ roomId, userId, nickname }) => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const { chatList, sendChat, replyChat } = useMomentaryChat(\n    roomId,\n    userId,\n    nickname\n  );\n\n  const clearRef = useRef<() => void>();\n  const registerClear = (clear: () => void) => {\n    clearRef.current = clear;\n  };\n\n  const [text, setText] = useState(\"\");\n  const onClick = () => {\n    if (text) {\n      sendChat(text);\n      setText(\"\");\n      if (clearRef.current) {\n        clearRef.current();\n      }\n    }\n  };\n\n  return (\n    <div className=\"MomentaryChat-container\" ref={containerRef}>\n      <MomentaryChatContent chatList={chatList} replyChat={replyChat} />\n      <div className=\"MomentaryChat-editor\">\n        <WysiwygEditor registerClear={registerClear} onChange={setText} />\n      </div>\n      <div className=\"MomentaryChat-button\">\n        <button type=\"button\" onClick={onClick} disabled={!text}>\n          Send\n        </button>\n      </div>\n    </div>\n  );\n});\n","import React, { useState } from \"react\";\n\nimport \"./UserProfile.css\";\nimport { Emoji, EmojiPicker, EmojiDataType } from \"../utils/emoji\";\n\nconst TextField = React.memo<{\n  initialText: string;\n  onUpdate: (text: string) => void;\n  buttonLabel?: string;\n  placeholder?: string;\n  clearOnUpdate?: boolean;\n}>(({ initialText, onUpdate, buttonLabel, placeholder, clearOnUpdate }) => {\n  const [text, setText] = useState(initialText);\n  const onSubmit = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    if (text) {\n      onUpdate(text);\n      if (clearOnUpdate) {\n        setText(\"\");\n      }\n    }\n  };\n\n  return (\n    <form onSubmit={onSubmit}>\n      <input\n        value={text}\n        onChange={(e) => setText(e.target.value)}\n        placeholder={placeholder}\n      />\n      {buttonLabel && (\n        <button type=\"submit\" disabled={!text}>\n          {buttonLabel}\n        </button>\n      )}\n    </form>\n  );\n});\n\nexport const UserProfile = React.memo<{\n  initialNickname: string;\n  emoji: EmojiDataType | null;\n  onUpdateNickname: (e: string) => void;\n  onUpdateStatusMesg: (e: string) => void;\n  onUpdateEmoji: (e: EmojiDataType | null) => void;\n}>(\n  ({\n    initialNickname,\n    emoji,\n    onUpdateNickname,\n    onUpdateStatusMesg,\n    onUpdateEmoji,\n  }) => {\n    const [openEmojiPicker, setOpenEmojiPicker] = useState(false);\n    return (\n      <div className=\"UserProfile-container\">\n        <div className=\"UserProfile-nickname\">\n          <TextField\n            initialText={initialNickname}\n            onUpdate={onUpdateNickname}\n            placeholder=\"Enter your name\"\n            buttonLabel=\"Set\"\n          />\n        </div>\n        <div className=\"UserProfile-status-area\">\n          <div className=\"UserProfile-emoji\">\n            <button\n              type=\"button\"\n              onClick={() => {\n                setOpenEmojiPicker(!openEmojiPicker);\n              }}\n            >\n              {emoji ? <Emoji emoji={emoji} size={10} /> : \":)\"}\n            </button>\n          </div>\n          <div className=\"UserProfile-statusmesg\">\n            <TextField\n              initialText=\"\"\n              onUpdate={onUpdateStatusMesg}\n              placeholder=\"Enter status message\"\n              buttonLabel=\"Set\"\n            />\n          </div>\n          <button\n            type=\"button\"\n            onClick={() => {\n              onUpdateEmoji(null);\n              onUpdateStatusMesg(\"\");\n              setOpenEmojiPicker(false);\n            }}\n          >\n            Clear\n          </button>\n        </div>\n        {openEmojiPicker && (\n          <EmojiPicker\n            onSelect={(e) => {\n              onUpdateEmoji(e);\n              setOpenEmojiPicker(false);\n            }}\n          />\n        )}\n      </div>\n    );\n  }\n);\n","import React, { useEffect, useState } from \"react\";\n\nimport \"./SingleRoom.css\";\nimport { setRoomIdToUrl } from \"../utils/url\";\nimport { setStringItem, getStringItem } from \"../utils/storage\";\nimport { useRoomNetworkStatus } from \"../hooks/useRoom\";\nimport { useNicknameMap } from \"../hooks/useNicknameMap\";\nimport { useVideoDevices, useAudioDevices } from \"../hooks/useAvailableDevices\";\nimport { FaceImages } from \"./FaceImages\";\nimport { MomentaryChat } from \"./MomentaryChat\";\nimport { UserProfile } from \"./UserProfile\";\nimport { EmojiDataType } from \"../utils/emoji\";\n\nconst ScreenShare = React.lazy(() => import(\"./ScreenShare\"));\nconst VideoShare = React.lazy(() => import(\"./VideoShare\"));\nconst CollabWhiteBoard = React.lazy(() => import(\"./CollabWhiteBoard\"));\n\nconst initialNickname = getStringItem(\"nickname\");\nconst initialConfigOpen = getStringItem(\"config_hidden\") !== \"true\";\nconst initialVideoDeviceId = getStringItem(\"faceimage_video_device_id\");\nconst initialAudioDeviceId = getStringItem(\"faceimage_audio_device_id\");\n\nexport const SingleRoom = React.memo<{\n  roomId: string;\n  userId: string;\n}>(({ roomId, userId }) => {\n  const [nickname, setNickname] = useState(initialNickname);\n  const [statusMesg, setStatusMesg] = useState(\"\");\n  const [emoji, setEmoji] = useState<EmojiDataType | null>(null);\n  useEffect(() => {\n    setRoomIdToUrl(roomId);\n  }, [roomId]);\n\n  const videoDevices = useVideoDevices();\n  const audioDevices = useAudioDevices();\n  const [videoDeviceId, setVideoDeviceId] = useState(initialVideoDeviceId);\n  const [audioDeviceId, setAudioDeviceId] = useState(initialAudioDeviceId);\n  const [liveMode, setLiveMode] = useState(false);\n  const [micOn, setMicOn] = useState(false);\n  const [speakerOn, setSpeakerOn] = useState(false);\n  const [screenShareMode, setScreenShareMode] = useState(false);\n  const [videoShareMode, setVideoShareMode] = useState(false);\n  const [collabWBOpen, setCollabWBOpen] = useState(false);\n\n  const [configOpen, setConfigOpen] = useState(initialConfigOpen);\n  useEffect(() => {\n    setStringItem(\"config_hidden\", configOpen ? \"false\" : \"true\");\n  }, [configOpen]);\n\n  const networkStatus = useRoomNetworkStatus(roomId, userId);\n  useNicknameMap(roomId, userId); // to enable caching\n\n  const appLink = `remote-faces://${window.location.href.replace(\n    /^https:\\/\\//,\n    \"\"\n  )}`;\n\n  return (\n    <>\n      <div className=\"SingleRoom-body\">\n        <FaceImages\n          roomId={roomId}\n          userId={userId}\n          videoDeviceId={videoDeviceId}\n          audioDeviceId={audioDeviceId}\n          nickname={nickname}\n          statusMesg={`${emoji?.native || \"\"}${statusMesg}`}\n          liveMode={liveMode}\n          micOn={micOn}\n          speakerOn={speakerOn}\n        />\n        <div className=\"SingleRoom-2nd-column\">\n          <UserProfile\n            initialNickname={initialNickname}\n            emoji={emoji}\n            onUpdateNickname={(text) => {\n              setNickname(text);\n              setStringItem(\"nickname\", text);\n            }}\n            onUpdateStatusMesg={(text) => {\n              setStatusMesg(text);\n            }}\n            onUpdateEmoji={(e) => {\n              setEmoji(e);\n            }}\n          />\n          <div>\n            <button\n              type=\"button\"\n              className=\"SingleRoom-config-toggle\"\n              onClick={() => setConfigOpen((o) => !o)}\n            >\n              Setting{configOpen ? <>&#9660;</> : <>&#9654;</>}\n            </button>\n            {configOpen && (\n              <div className=\"SingleRoom-config\">\n                <div>\n                  Link to this room:\n                  <input value={window.location.href} readOnly />\n                  (Share this link with your colleagues)\n                  <a href={appLink}>Open App</a>\n                </div>\n                <div>\n                  Select Camera:{\" \"}\n                  <select\n                    value={videoDeviceId}\n                    onChange={(e) => {\n                      setVideoDeviceId(e.target.value);\n                      setStringItem(\n                        \"faceimage_video_device_id\",\n                        e.target.value\n                      );\n                    }}\n                  >\n                    {videoDevices.map((videoDevice) => (\n                      <option\n                        key={videoDevice.deviceId}\n                        value={videoDevice.deviceId}\n                      >\n                        {videoDevice.label}\n                      </option>\n                    ))}\n                  </select>\n                </div>\n                <div>\n                  Select Mic:{\" \"}\n                  <select\n                    value={audioDeviceId}\n                    onChange={(e) => {\n                      setAudioDeviceId(e.target.value);\n                      setStringItem(\n                        \"faceimage_audio_device_id\",\n                        e.target.value\n                      );\n                    }}\n                  >\n                    {audioDevices.map((audioDevice) => (\n                      <option\n                        key={audioDevice.deviceId}\n                        value={audioDevice.deviceId}\n                      >\n                        {audioDevice.label}\n                      </option>\n                    ))}\n                  </select>\n                </div>\n                <div>\n                  Live Mode:{\" \"}\n                  <button type=\"button\" onClick={() => setLiveMode((x) => !x)}>\n                    {liveMode ? \"Disable\" : \"Enable\"}\n                  </button>\n                  {liveMode && <>&#10004;</>}\n                  {liveMode && (\n                    <div>\n                      <label>\n                        <input\n                          type=\"checkbox\"\n                          checked={micOn}\n                          onChange={(e) => setMicOn(e.target.checked)}\n                        />\n                        Mic On\n                      </label>\n                      <label>\n                        <input\n                          type=\"checkbox\"\n                          checked={speakerOn}\n                          onChange={(e) => setSpeakerOn(e.target.checked)}\n                        />\n                        Speaker On\n                      </label>\n                    </div>\n                  )}\n                </div>\n                <div>\n                  Screen Share:{\" \"}\n                  <button\n                    type=\"button\"\n                    onClick={() => setScreenShareMode((x) => !x)}\n                  >\n                    {screenShareMode ? \"Close\" : \"Open\"}\n                  </button>\n                  {screenShareMode && <>&#10004;</>}\n                </div>\n                <div>\n                  Video Share:{\" \"}\n                  <button\n                    type=\"button\"\n                    onClick={() => setVideoShareMode((x) => !x)}\n                  >\n                    {videoShareMode ? \"Close\" : \"Open\"}\n                  </button>\n                  {videoShareMode && <>&#10004;</>}\n                </div>\n                <div>\n                  Collab White Board:{\" \"}\n                  <button\n                    type=\"button\"\n                    onClick={() => setCollabWBOpen((x) => !x)}\n                  >\n                    {collabWBOpen ? \"Close\" : \"Open\"}\n                  </button>\n                  {collabWBOpen && <>&#10004;</>}\n                </div>\n                <div className=\"SingleRoom-status\">\n                  {JSON.stringify(networkStatus)}\n                </div>\n              </div>\n            )}\n          </div>\n          <MomentaryChat roomId={roomId} userId={userId} nickname={nickname} />\n        </div>\n        <div className=\"SingleRoom-3rd-column\">\n          {screenShareMode && (\n            <ScreenShare roomId={roomId} userId={userId} nickname={nickname} />\n          )}\n          {videoShareMode && (\n            <VideoShare roomId={roomId} userId={userId} nickname={nickname} />\n          )}\n          {collabWBOpen && <CollabWhiteBoard roomId={roomId} />}\n        </div>\n      </div>\n    </>\n  );\n});\n\nexport default SingleRoom;\n","import { sleep } from \"../utils/sleep\";\n\nconst setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = async () => {\n    await sleep(5000);\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    }\n  };\n  track.addEventListener(\"mute\", onmute);\n  return track;\n};\n","import Peer from \"peerjs\";\n\nimport { sleep } from \"../utils/sleep\";\nimport { rand4, encrypt, decrypt } from \"../utils/crypto\";\nimport { getServerConfigFromUrl } from \"../utils/url\";\nimport { isObject } from \"../utils/types\";\nimport {\n  ROOM_ID_PREFIX_LEN,\n  isValidPeerId,\n  generatePeerId,\n  getPeerIndexFromPeerId,\n  getPeerIndexFromConn,\n  createConnectionMap,\n} from \"./peerUtils\";\nimport { setupTrackStopOnLongMute } from \"./trackUtils\";\n\nconst MIN_SEED_PEER_INDEX = 10; // config\nconst MAX_SEED_PEER_INDEX = 14; // config\nconst guessSeed = (id: string) => {\n  const peerIndex = getPeerIndexFromPeerId(id);\n  return MIN_SEED_PEER_INDEX <= peerIndex && peerIndex <= MAX_SEED_PEER_INDEX;\n};\n\nexport type NetworkStatus =\n  | { type: \"CONNECTING_SEED_PEERS\" }\n  | { type: \"NEW_CONNECTION\"; peerIndex: number }\n  | { type: \"CONNECTION_CLOSED\"; peerIndex: number }\n  | { type: \"INITIALIZING_PEER\"; peerIndex: number }\n  | { type: \"RECONNECTING\" }\n  | { type: \"SERVER_ERROR\" }\n  | { type: \"UNKNOWN_ERROR\"; err: Error }\n  | { type: \"CONNECTED_PEERS\"; peerIndexList: number[] };\n\ntype UpdateNetworkStatus = (status: NetworkStatus) => void;\n\nexport type PeerInfo = {\n  userId: string;\n  peerIndex: number;\n  mediaTypes: string[];\n};\ntype NotifyNewPeer = (sendInitialData: (data: unknown) => void) => void;\ntype ReceiveData = (data: unknown, info: PeerInfo) => void;\ntype ReceiveTrack = (track: MediaStreamTrack, info: PeerInfo) => void;\n\nexport const createRoom = (\n  roomId: string,\n  userId: string,\n  updateNetworkStatus: UpdateNetworkStatus,\n  notifyNewPeer: NotifyNewPeer,\n  receiveData: ReceiveData,\n  receiveTrack: ReceiveTrack\n) => {\n  let disposed = false;\n  let myPeer: Peer | null = null;\n  const connMap = createConnectionMap();\n  let mediaTypes: string[] = [];\n  let localStream: MediaStream | null = null;\n\n  const showConnectedStatus = () => {\n    if (disposed) return;\n    const peerIndexList = connMap\n      .getConnectedPeerIds()\n      .map(getPeerIndexFromPeerId);\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const connectPeer = (id: string) => {\n    if (disposed) return;\n    if (!myPeer || myPeer.id === id || myPeer.disconnected) return;\n    if (connMap.hasConn(id)) return;\n    console.log(\"connectPeer\", id);\n    const conn = myPeer.connect(id);\n    initConnection(conn);\n  };\n\n  const broadcastData = (data: unknown) => {\n    if (disposed) return;\n    const peers = connMap.getConnectedPeerIds();\n    connMap.forEachConnectedConns((conn) => {\n      sendPayload(conn, { userId, data, peers, mediaTypes });\n    });\n  };\n\n  const sendSDP = (conn: Peer.DataConnection, sdp: unknown) => {\n    sendPayload(conn, { SDP: sdp });\n  };\n\n  const handlePayloadSDP = async (conn: Peer.DataConnection, sdp: unknown) => {\n    if (!isObject(sdp)) return;\n    if (isObject((sdp as { offer: unknown }).offer)) {\n      const { offer } = sdp as { offer: object };\n      try {\n        await conn.peerConnection.setRemoteDescription(offer as any);\n        syncAllTracks(conn);\n        const answer = await conn.peerConnection.createAnswer();\n        await conn.peerConnection.setLocalDescription(answer);\n        sendSDP(conn, { answer });\n      } catch (e) {\n        console.info(\"handleSDP offer failed\", e);\n      }\n    } else if (isObject((sdp as { answer: unknown }).answer)) {\n      const { answer } = sdp as { answer: object };\n      try {\n        await conn.peerConnection.setRemoteDescription(answer as any);\n      } catch (e) {\n        console.info(\"handleSDP answer failed\", e);\n        await sleep(Math.random() * 30 * 1000);\n        removeAllTracks(conn);\n        syncAllTracks(conn);\n      }\n    } else {\n      console.warn(\"unknown SDP\", sdp);\n    }\n  };\n\n  const handlePayloadUserId = (\n    conn: Peer.DataConnection,\n    payloadUserId: unknown\n  ) => {\n    if (typeof payloadUserId === \"string\") {\n      connMap.setUserId(conn, payloadUserId as string);\n    }\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Peer.DataConnection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setMediaTypes(conn, payloadMediaTypes as string[]);\n      await sleep(5000);\n      syncAllTracks(conn);\n    }\n  };\n\n  const handlePayloadPeers = (peers: unknown) => {\n    if (Array.isArray(peers)) {\n      peers.forEach((peer) => {\n        if (isValidPeerId(roomId, peer)) {\n          connectPeer(peer);\n        }\n      });\n    }\n  };\n\n  const handlePayloadData = (conn: Peer.DataConnection, data: unknown) => {\n    const connUserId = connMap.getUserId(conn);\n    if (connUserId) {\n      const info: PeerInfo = {\n        userId: connUserId,\n        peerIndex: getPeerIndexFromConn(conn),\n        mediaTypes: connMap.getMediaTypes(conn),\n      };\n      try {\n        receiveData(data, info);\n      } catch (e) {\n        console.warn(\"receiveData\", e);\n      }\n    }\n  };\n\n  const handlePayload = async (\n    conn: Peer.DataConnection,\n    encrypted: ArrayBuffer\n  ) => {\n    if (disposed) return;\n    try {\n      const payload = JSON.parse(\n        await decrypt(encrypted, roomId.slice(ROOM_ID_PREFIX_LEN))\n      );\n      console.log(\"decrypted payload\", conn.peer, payload);\n      if (!isObject(payload)) return;\n\n      handlePayloadSDP(conn, (payload as { SDP?: unknown }).SDP);\n      handlePayloadUserId(conn, (payload as { userId?: unknown }).userId);\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadPeers((payload as { peers?: unknown }).peers);\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, encrypted);\n    }\n  };\n\n  const sendPayload = async (conn: Peer.DataConnection, payload: unknown) => {\n    try {\n      const encrypted = await encrypt(\n        JSON.stringify(payload),\n        roomId.slice(ROOM_ID_PREFIX_LEN)\n      );\n      conn.send(encrypted);\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const initConnection = (conn: Peer.DataConnection) => {\n    if (connMap.isConnected(conn.peer)) {\n      conn.close();\n      return;\n    }\n    connMap.addConn(conn);\n    conn.on(\"open\", () => {\n      connMap.markConnected(conn);\n      console.log(\"dataConnection open\", conn);\n      showConnectedStatus();\n      const sendInitialData = (data: unknown) => {\n        const peers = connMap.getConnectedPeerIds();\n        sendPayload(conn, { userId, data, peers, mediaTypes });\n      };\n      notifyNewPeer(sendInitialData);\n    });\n    conn.on(\"data\", (buf: ArrayBuffer) => handlePayload(conn, buf));\n    conn.peerConnection.addEventListener(\"icegatheringstatechange\", () => {\n      const pc = conn.peerConnection;\n      if (pc.iceGatheringState === \"complete\") {\n        pc.onicecandidate = () => undefined;\n      }\n    });\n    const scheduledNegotiation = new WeakMap<Peer.DataConnection, boolean>();\n    conn.peerConnection.addEventListener(\"negotiationneeded\", async () => {\n      if (scheduledNegotiation.has(conn)) return;\n      scheduledNegotiation.set(conn, true);\n      await sleep(2000);\n      scheduledNegotiation.delete(conn);\n      if (!connMap.isConnected(conn.peer)) return;\n      const offer = await conn.peerConnection.createOffer();\n      await conn.peerConnection.setLocalDescription(offer);\n      sendSDP(conn, { offer });\n    });\n    conn.peerConnection.addEventListener(\"track\", (event: RTCTrackEvent) => {\n      const connUserId = connMap.getUserId(conn);\n      if (connUserId) {\n        const info: PeerInfo = {\n          userId: connUserId,\n          peerIndex: getPeerIndexFromPeerId(conn.peer),\n          mediaTypes: connMap.getMediaTypes(conn),\n        };\n        receiveTrack(\n          setupTrackStopOnLongMute(event.track, conn.peerConnection),\n          info\n        );\n      }\n    });\n    conn.on(\"close\", () => {\n      connMap.delConn(conn);\n      console.log(\"dataConnection closed\", conn);\n      updateNetworkStatus({\n        type: \"CONNECTION_CLOSED\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      showConnectedStatus();\n      if (connMap.getConnectedPeerIds().length === 0) {\n        reInitMyPeer(true);\n      } else if (\n        guessSeed(conn.peer) &&\n        myPeer &&\n        !myPeer.disconnected &&\n        !guessSeed(myPeer.id)\n      ) {\n        const waitSec = 30 + Math.floor(Math.random() * 60);\n        console.log(\n          `Disconnected seed peer: ${getPeerIndexFromPeerId(\n            conn.peer\n          )}, reinit in ${waitSec}sec...`\n        );\n        setTimeout(reInitMyPeer, waitSec * 1000);\n      }\n    });\n  };\n\n  const initMyPeer = (index = MIN_SEED_PEER_INDEX) => {\n    if (disposed) return;\n    if (myPeer) return;\n    connMap.clearAll();\n    const isSeed = MIN_SEED_PEER_INDEX <= index && index <= MAX_SEED_PEER_INDEX;\n    const peerIndex = isSeed ? index : rand4();\n    updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex });\n    const id = generatePeerId(roomId, peerIndex);\n    console.log(\"initMyPeer start\", index, id);\n    const peer = new Peer(id, {\n      ...(getServerConfigFromUrl() || {}),\n      debug: 3,\n    });\n    myPeer = peer;\n    peer.on(\"open\", () => {\n      myPeer = peer;\n      if (process.env.NODE_ENV !== \"production\") {\n        (window as any).myPeer = myPeer;\n      }\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const seedId = generatePeerId(roomId, i);\n        connectPeer(seedId);\n      }\n    });\n    peer.on(\"error\", (err) => {\n      if (err.type === \"unavailable-id\") {\n        myPeer = null;\n        peer.destroy();\n        initMyPeer(index + 1);\n      } else if (err.type === \"peer-unavailable\") {\n        // ignore\n      } else if (err.type === \"disconnected\") {\n        console.log(\"initMyPeer disconnected error\", index, err);\n        peer.destroy();\n      } else if (err.type === \"network\") {\n        console.log(\"initMyPeer network error\", index, err);\n      } else if (err.type === \"server-error\") {\n        console.log(\"initMyPeer server error\", index, err);\n        updateNetworkStatus({ type: \"SERVER_ERROR\" });\n      } else {\n        console.error(\"initMyPeer unknown error\", index, err.type, err);\n        updateNetworkStatus({ type: \"UNKNOWN_ERROR\", err });\n      }\n    });\n    peer.on(\"connection\", (conn) => {\n      if (myPeer !== peer) {\n        conn.close();\n        return;\n      }\n      console.log(\"new connection received\", conn);\n      updateNetworkStatus({\n        type: \"NEW_CONNECTION\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      initConnection(conn);\n    });\n    peer.on(\"disconnected\", () => {\n      console.log(\"initMyPeer disconnected\", index);\n      setTimeout(() => {\n        if (myPeer === peer && !peer.destroyed) {\n          console.log(\"initMyPeer reconnecting\", index);\n          updateNetworkStatus({ type: \"RECONNECTING\" });\n          peer.reconnect();\n        }\n      }, 5 * 1000);\n    });\n    peer.on(\"close\", () => {\n      if (myPeer === peer) {\n        console.log(\"initMyPeer closed, re-initializing\", index);\n        myPeer = null;\n        setTimeout(initMyPeer, 20 * 1000);\n      } else {\n        console.log(\"initMyPeer closed, ignoring\", index);\n      }\n    });\n  };\n  initMyPeer();\n\n  const reInitMyPeer = (force?: boolean) => {\n    if (!myPeer) return;\n    if (myPeer.disconnected) return; // should already be handled\n    if (!force) {\n      if (guessSeed(myPeer.id)) return;\n      let existsAllSeeds = true;\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const id = generatePeerId(roomId, i);\n        if (!connMap.isConnected(id)) {\n          existsAllSeeds = false;\n          break;\n        }\n      }\n      if (existsAllSeeds) {\n        showConnectedStatus();\n        return;\n      }\n    }\n    const oldPeer = myPeer;\n    myPeer = null;\n    oldPeer.destroy();\n    initMyPeer();\n  };\n\n  const acceptMediaTypes = (mTypes: string[]) => {\n    mediaTypes = mTypes;\n    if (mediaTypes.length) {\n      if (!localStream) {\n        localStream = new MediaStream();\n        connMap.forEachConnectedConns((conn) => {\n          const connUserId = connMap.getUserId(conn);\n          if (connUserId) {\n            const info: PeerInfo = {\n              userId: connUserId,\n              peerIndex: getPeerIndexFromPeerId(conn.peer),\n              mediaTypes: connMap.getMediaTypes(conn),\n            };\n            conn.peerConnection.getReceivers().forEach((receiver) => {\n              receiveTrack(\n                setupTrackStopOnLongMute(receiver.track, conn.peerConnection),\n                info\n              );\n            });\n          }\n        });\n      }\n    } else {\n      localStream = null;\n    }\n    broadcastData(null);\n  };\n\n  const trackMediaTypeMap = new WeakMap<MediaStreamTrack, string>();\n\n  const addTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (!localStream) return;\n    trackMediaTypeMap.set(track, mediaType);\n    localStream.addTrack(track);\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      try {\n        if (!localStream) return;\n        conn.peerConnection.addTrack(track, localStream);\n      } catch (e) {\n        if (e.name === \"InvalidAccessError\") {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n    });\n  };\n\n  const removeTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (localStream) {\n      localStream.removeTrack(track);\n    }\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      const senders = conn.peerConnection.getSenders();\n      const sender = senders.find((s) => s.track === track);\n      if (sender) {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const syncAllTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection.getSenders();\n    const mTypes = connMap.getMediaTypes(conn);\n    if (localStream) {\n      localStream.getTracks().forEach((track) => {\n        const mType = trackMediaTypeMap.get(track);\n        if (\n          localStream &&\n          mType &&\n          mTypes.includes(mType) &&\n          senders.every((sender) => sender.track !== track)\n        ) {\n          conn.peerConnection.addTrack(track, localStream);\n        }\n      });\n    }\n    senders.forEach((sender) => {\n      if (sender.track) {\n        const mType = trackMediaTypeMap.get(sender.track);\n        if (!mType || !mTypes.includes(mType)) {\n          conn.peerConnection.removeTrack(sender);\n        }\n      }\n    });\n    if (senders.some((sender) => sender.track && !sender.transport)) {\n      conn.peerConnection.dispatchEvent(new Event(\"negotiationneeded\"));\n    }\n  };\n\n  const removeAllTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection.getSenders();\n    senders.forEach((sender) => {\n      if (sender.track) {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const dispose = () => {\n    disposed = true;\n    if (myPeer) {\n      myPeer.destroy();\n    }\n  };\n\n  return {\n    broadcastData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n","import { useEffect, useState, useCallback, useRef } from \"react\";\n\nimport { PeerInfo, createRoom, NetworkStatus } from \"../network/room\";\n\ntype NetworkStatusListener = (status: NetworkStatus) => void;\ntype NewPeerListener = (sendInitialData: (data: unknown) => void) => void;\ntype DataListener = (data: unknown, info: PeerInfo) => void;\ntype TrackListener = {\n  mediaType: string;\n  listener: (track: MediaStreamTrack, info: PeerInfo) => void;\n};\ntype RoomEntry = {\n  room: ReturnType<typeof createRoom>;\n  networkStatusListeners: Set<NetworkStatusListener>;\n  newPeerListeners: Set<NewPeerListener>;\n  dataListeners: Set<DataListener>;\n  trackListeners: Set<TrackListener>;\n  count: number;\n};\nconst roomEntryMap = new Map<string, RoomEntry>();\nconst register = (\n  roomId: string,\n  userId: string,\n  listeners: {\n    networkStatusListener?: NetworkStatusListener;\n    newPeerListener?: NewPeerListener;\n    dataListener?: DataListener;\n    trackListener?: TrackListener;\n  }\n) => {\n  const roomEntryKey = `${roomId}_${userId}`;\n  let entry = roomEntryMap.get(roomEntryKey);\n  if (!entry) {\n    const networkStatusListeners = new Set<NetworkStatusListener>();\n    const newPeerListeners = new Set<NewPeerListener>();\n    const dataListeners = new Set<DataListener>();\n    const trackListeners = new Set<TrackListener>();\n    const updateNetworkStatus = (status: NetworkStatus) => {\n      networkStatusListeners.forEach((listener) => {\n        listener(status);\n      });\n    };\n    const notifyNewPeer = (sendInitialData: (data: unknown) => void) => {\n      newPeerListeners.forEach((listener) => {\n        listener(sendInitialData);\n      });\n    };\n    const receiveData = (data: unknown, info: PeerInfo) => {\n      dataListeners.forEach((listener) => {\n        listener(data, info);\n      });\n    };\n    const receiveTrack = (track: MediaStreamTrack, info: PeerInfo) => {\n      trackListeners.forEach(({ listener }) => {\n        listener(track, info);\n      });\n    };\n    const room = createRoom(\n      roomId,\n      userId,\n      updateNetworkStatus,\n      notifyNewPeer,\n      receiveData,\n      receiveTrack\n    );\n    entry = {\n      room,\n      networkStatusListeners,\n      newPeerListeners,\n      dataListeners,\n      trackListeners,\n      count: 0,\n    };\n    roomEntryMap.set(roomEntryKey, entry);\n  }\n  if (listeners.networkStatusListener) {\n    entry.networkStatusListeners.add(listeners.networkStatusListener);\n  }\n  if (listeners.newPeerListener) {\n    entry.newPeerListeners.add(listeners.newPeerListener);\n  }\n  if (listeners.dataListener) {\n    entry.dataListeners.add(listeners.dataListener);\n  }\n  if (listeners.trackListener) {\n    const mediaTypeSet = new Set(\n      Array.from(entry.trackListeners).map((x) => x.mediaType)\n    );\n    const prevSize = mediaTypeSet.size;\n    entry.trackListeners.add(listeners.trackListener);\n    mediaTypeSet.add(listeners.trackListener.mediaType);\n    if (prevSize !== mediaTypeSet.size) {\n      entry.room.acceptMediaTypes(Array.from(mediaTypeSet));\n    }\n  }\n  entry.count += 1;\n  const definedEntry = entry;\n  const unregister = () => {\n    if (listeners.networkStatusListener) {\n      definedEntry.networkStatusListeners.delete(\n        listeners.networkStatusListener\n      );\n    }\n    if (listeners.newPeerListener) {\n      definedEntry.newPeerListeners.delete(listeners.newPeerListener);\n    }\n    if (listeners.dataListener) {\n      definedEntry.dataListeners.delete(listeners.dataListener);\n    }\n    if (listeners.trackListener) {\n      let mediaTypeSet = new Set(\n        Array.from(definedEntry.trackListeners).map((x) => x.mediaType)\n      );\n      const prevSize = mediaTypeSet.size;\n      definedEntry.trackListeners.delete(listeners.trackListener);\n      mediaTypeSet = new Set(\n        Array.from(definedEntry.trackListeners).map((x) => x.mediaType)\n      );\n      if (prevSize !== mediaTypeSet.size) {\n        definedEntry.room.acceptMediaTypes(Array.from(mediaTypeSet));\n      }\n    }\n    definedEntry.count -= 1;\n    if (definedEntry.count <= 0) {\n      definedEntry.room.dispose();\n      roomEntryMap.delete(roomEntryKey);\n    }\n  };\n  return {\n    broadcastData: entry.room.broadcastData,\n    addTrack: entry.room.addTrack,\n    removeTrack: entry.room.removeTrack,\n    unregister,\n  };\n};\n\nexport const useRoomNetworkStatus = (\n  roomId: string,\n  userId: string,\n  onNetworkStatus?: (networkStatus: NetworkStatus) => void\n) => {\n  const [networkStatus, updateNetworkStatus] = useState<NetworkStatus>();\n  if (networkStatus && networkStatus.type === \"UNKNOWN_ERROR\") {\n    throw new Error(`Network Error: ${networkStatus.err.message}`);\n  }\n  useEffect(() => {\n    const { unregister } = register(roomId, userId, {\n      networkStatusListener: (ns: NetworkStatus) => {\n        updateNetworkStatus(ns);\n        if (onNetworkStatus) onNetworkStatus(ns);\n      },\n    });\n    return unregister;\n  }, [roomId, userId, onNetworkStatus]);\n  return networkStatus;\n};\n\nexport const useRoomNewPeer = (\n  roomId: string,\n  userId: string,\n  getInitialDataIterator: () => AsyncIterable<unknown>\n) => {\n  useEffect(() => {\n    const { unregister } = register(roomId, userId, {\n      newPeerListener: async (sendInitialData: (data: unknown) => void) => {\n        // eslint-disable-next-line no-restricted-syntax\n        for await (const data of getInitialDataIterator()) {\n          sendInitialData(data);\n        }\n      },\n    });\n    return unregister;\n  }, [roomId, userId, getInitialDataIterator]);\n};\n\ntype BroadcastData = ReturnType<typeof createRoom>[\"broadcastData\"];\n\nexport const useBroadcastData = (roomId: string, userId: string) => {\n  const broadcastDataRef = useRef<BroadcastData>();\n  const broadcastData = useCallback((...args: Parameters<BroadcastData>) => {\n    if (broadcastDataRef.current) {\n      broadcastDataRef.current(...args);\n    } else {\n      // TODO pending queue\n    }\n  }, []);\n  useEffect(() => {\n    const registered = register(roomId, userId, {});\n    broadcastDataRef.current = registered.broadcastData;\n    return registered.unregister;\n  }, [roomId, userId]);\n  return broadcastData;\n};\n\nexport const useRoomData = (\n  roomId: string,\n  userId: string,\n  onRoomData: (data: unknown, info: PeerInfo) => void\n) => {\n  useEffect(() => {\n    const { unregister } = register(roomId, userId, {\n      dataListener: onRoomData,\n    });\n    return unregister;\n  }, [roomId, userId, onRoomData]);\n};\n\nexport const useRoomMedia = (\n  roomId: string,\n  userId: string,\n  onTrack: (track: MediaStreamTrack, info: PeerInfo) => void,\n  mediaType?: string\n) => {\n  const [functions, setFunctions] = useState<{\n    addTrack?: (track: MediaStreamTrack) => void;\n    removeTrack?: (track: MediaStreamTrack) => void;\n  }>({});\n  useEffect(() => {\n    if (mediaType) {\n      const result = register(roomId, userId, {\n        trackListener: { mediaType, listener: onTrack },\n      });\n      setFunctions({\n        addTrack: (track: MediaStreamTrack) =>\n          result.addTrack(mediaType, track),\n        removeTrack: (track: MediaStreamTrack) =>\n          result.removeTrack(mediaType, track),\n      });\n      return () => {\n        setFunctions({});\n        result.unregister();\n      };\n    }\n    return undefined;\n  }, [roomId, userId, onTrack, mediaType]);\n  return functions;\n};\n","export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","export const isObject = (x: unknown): x is object =>\n  typeof x === \"object\" && x !== null;\n","import { useCallback, useState } from \"react\";\n\nimport { isObject } from \"../utils/types\";\nimport { useRoomData } from \"./useRoom\";\n\ntype Entry = {\n  roomId: string;\n  userId: string;\n  nickname: string;\n  lastUpdated: number;\n};\nconst cache: Entry[] = [];\nconst TTL = 10 * 60 * 1000; // 10min\n\nconst createMapFromCache = (roomId: string) => {\n  const map: { [userId: string]: string } = {};\n  cache.forEach((entry) => {\n    if (entry.roomId === roomId) {\n      map[entry.userId] = entry.nickname;\n    }\n  });\n  return map;\n};\n\nconst hasInfoNickname = (x: unknown): x is { info: { nickname: string } } =>\n  isObject(x) &&\n  isObject((x as { info: unknown }).info) &&\n  typeof (x as { info: { nickname: unknown } }).info.nickname === \"string\";\n\nexport const useNicknameMap = (roomId: string, userId: string) => {\n  const [nicknameMap, setNicknameMap] = useState<{\n    [userId: string]: string;\n  }>(() => createMapFromCache(roomId));\n  useRoomData(\n    roomId,\n    userId,\n    useCallback(\n      (data, info) => {\n        if (!hasInfoNickname(data)) return;\n        const index = cache.findIndex(\n          (entry) => entry.roomId === roomId && entry.userId === info.userId\n        );\n        const now = Date.now();\n        if (index >= 0) {\n          if (cache[index].nickname !== data.info.nickname) {\n            cache[index].nickname = data.info.nickname;\n          }\n          cache[index].lastUpdated = now;\n        } else {\n          cache.push({\n            roomId,\n            userId: info.userId,\n            nickname: data.info.nickname,\n            lastUpdated: now,\n          });\n        }\n        for (let i = cache.length - 1; i >= 0; i -= 1) {\n          if (cache[i].lastUpdated + TTL < now) {\n            cache.splice(i, 1);\n          }\n        }\n        setNicknameMap((prev) => {\n          const map = createMapFromCache(roomId);\n          const keys = Object.keys(map);\n          if (\n            keys.length === Object.keys(prev).length &&\n            keys.every((key) => map[key] === prev[key])\n          ) {\n            return prev;\n          }\n          return map;\n        });\n      },\n      [roomId]\n    )\n  );\n  return nicknameMap;\n};\n","import { sleep } from \"../utils/sleep\";\n\nexport const getVideoStream = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        video: { deviceId },\n      }\n    : { video: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const [track] = stream.getVideoTracks();\n  const dispose = () => {\n    track.stop();\n  };\n  return {\n    stream,\n    dispose,\n  };\n};\n\nexport const getFaceVideoStream = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        video: { deviceId },\n      }\n    : { video: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const [track] = stream.getVideoTracks();\n  const video = document.getElementById(\"internal-video\") as HTMLVideoElement;\n  video.style.display = \"block\";\n  video.srcObject = stream;\n  await sleep(1000);\n  const srcW = video.videoWidth;\n  const srcH = video.videoHeight;\n  const canvas = document.getElementById(\n    \"internal-canvas\"\n  ) as HTMLCanvasElement;\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const dstW = 72;\n  const dstH = 72;\n  canvas.width = dstW;\n  canvas.height = dstH;\n  const ratio = Math.max(dstW / srcW, dstH / srcH);\n  const width = Math.min(srcW, dstW / ratio);\n  const height = Math.min(srcH, dstH / ratio);\n  const x = (srcW - width) / 2;\n  const y = (srcH - height) / 2;\n  let timer: NodeJS.Timeout;\n  const loop = () => {\n    ctx.drawImage(video, x, y, width, height, 0, 0, dstW, dstH);\n    timer = setTimeout(loop, 1000 / 15);\n  };\n  loop();\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const dispose = () => {\n    video.style.display = \"none\";\n    clearTimeout(timer);\n    track.stop();\n    canvasStream.getVideoTracks()[0].stop();\n  };\n  return {\n    stream: canvasStream,\n    dispose,\n  };\n};\n\nconst checkVideTrackFaceSize = async (track: MediaStreamTrack) => {\n  try {\n    const video = document.createElement(\"video\");\n    video.srcObject = new MediaStream([track]);\n    for (let i = 0; i < 50; i += 1) {\n      // eslint-disable-next-line no-await-in-loop\n      await sleep(100);\n      const width = video.videoWidth;\n      const height = video.videoHeight;\n      if (width > 0 && height > 0) {\n        return width === 72 && height === 72;\n      }\n    }\n    return true; // fallback to true\n  } catch (e) {\n    return true; // fallback to true\n  }\n};\n\nconst videoTrackFaceSizeMap = new WeakMap<MediaStreamTrack, Promise<boolean>>();\n\nexport const isVideoTrackFaceSize = (track: MediaStreamTrack) => {\n  if (videoTrackFaceSizeMap.has(track)) {\n    return videoTrackFaceSizeMap.get(track) as Promise<boolean>;\n  }\n  const promise = checkVideTrackFaceSize(track);\n  videoTrackFaceSizeMap.set(track, promise);\n  return promise;\n};\n","type DeviceInfo = {\n  label: string;\n  deviceId: string;\n};\n\nexport const getVideoDeviceInfoList = async () => {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const list: DeviceInfo[] = devices\n      .filter(({ kind }) => kind === \"videoinput\")\n      .map(({ label, deviceId }) => ({ label, deviceId }));\n    return list;\n  } catch (e) {\n    // ignored\n    return [];\n  }\n};\n\nexport const getAudioDeviceInfoList = async () => {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const list: DeviceInfo[] = devices\n      .filter(({ kind }) => kind === \"audioinput\")\n      .map(({ label, deviceId }) => ({ label, deviceId }));\n    return list;\n  } catch (e) {\n    // ignored\n    return [];\n  }\n};\n","import { useEffect, useState } from \"react\";\n\nimport {\n  getVideoDeviceInfoList,\n  getAudioDeviceInfoList,\n} from \"../media/devices\";\n\ntype VideoDeviceInfoList = ReturnType<\n  typeof getVideoDeviceInfoList\n> extends Promise<infer T>\n  ? T\n  : never;\n\nexport const useVideoDevices = () => {\n  const [devices, setDevices] = useState<VideoDeviceInfoList>([]);\n  useEffect(() => {\n    (async () => {\n      const deviceInfoList = await getVideoDeviceInfoList();\n      setDevices(deviceInfoList);\n    })();\n  }, []);\n  return devices;\n};\n\ntype AudioDeviceInfoList = ReturnType<\n  typeof getAudioDeviceInfoList\n> extends Promise<infer T>\n  ? T\n  : never;\n\nexport const useAudioDevices = () => {\n  const [devices, setDevices] = useState<AudioDeviceInfoList>([]);\n  useEffect(() => {\n    (async () => {\n      const deviceInfoList = await getAudioDeviceInfoList();\n      setDevices(deviceInfoList);\n    })();\n  }, []);\n  return devices;\n};\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 68;"],"sourceRoot":""}