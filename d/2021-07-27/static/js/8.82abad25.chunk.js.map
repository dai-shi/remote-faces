{"version":3,"sources":["utils/types.ts","utils/sleep.ts","network/trackUtils.ts","network/ipfsUtils.ts","network/ipfsRoom.ts"],"names":["isObject","x","hasStringProp","prop","hasObjectProp","sleep","ms","Promise","resolve","setTimeout","setupMap","WeakMap","setupTrackStopOnLongMute","track","pc","has","set","onmute","timeout","readyState","transceiver","getTransceivers","find","t","receiver","currentDirection","stop","dispatchEvent","Event","addEventListener","loopbackPeerConnection","reject","a","pcIn","RTCPeerConnection","pcOut","candidate","addIceCandidate","event","close","addTrack","createOffer","offer","setLocalDescription","setRemoteDescription","createAnswer","answer","videoTrackToImageConverter","kind","Error","canvas","document","createElement","ctx","getContext","imageCapture","ImageCapture","getImage","grabFrame","bitmap","width","height","drawImage","toDataURL","console","log","createImage","src","img","Image","onload","onerror","imageToVideoTrackConverter","captureStream","getVideoTracks","videoTrack","setImage","dataURL","peerIndexCounter","DEFAULT_CONFIG","iceServers","urls","username","credential","sdpSemantics","createConnectionMap","map","Map","registerRemoteMediaTypeFromSDP","conn","msid2mediaType","sdpLines","mid","value","get","peer","split","forEach","line","startsWith","slice","length","msid","mediaType","remoteMediaTypes","setAcceptingMediaTypes","mediaTypes","acceptingMediaTypes","getAcceptingMediaTypes","addConn","peerId","userId","peerIndex","sendPc","recvPc","getConn","findConn","Array","from","values","v","delConn","delete","getPeerIndexList","forEachConns","callback","forEachConnsAcceptingMedia","includes","size","getRemoteMediaType","registerRemoteMediaType","sdp","createRoom","roomId","updateNetworkStatus","notifyNewPeer","receiveData","receiveTrack","disposed","connMap","roomTopic","ROOM_ID_PREFIX_LEN","importCryptoKey","cryptoKey","type","Ipfs","create","repo","secureRandomId","config","Addresses","Swarm","getWebrtcStarFromUrl","Discovery","MDNS","Enabled","webRTCStar","myIpfs","id","myPeerId","myIpfsPubSubRoom","IpfsPubSubRoom","on","msg","pubsubHandler","broadcastData","parsePayload","encrypted","decryptStringFromChunks","str","undefined","payload","JSON","parse","info","sendPayload","topic","encryptStringToChunks","stringify","broadcast","error","sendPayloadDirectly","sendTo","data","sendData","acceptMediaTypes","mTypes","transceivers","getReceivers","mType","warn","sendSDP","getMsid2MediaType","SDP","handlePayloadSDP","negotiationId","negotiationIdMap","startNegotiation","running","negotiate","signalingState","sendIce","ice","ICE","handlePayloadIce","direction","e","handlePayloadMediaTypes","payloadMediaTypes","isArray","every","syncAllTracks","handlePayloadData","handlePayload","initConnection","payloadUserId","getUserIdFromPayload","peerIndexList","mediaTypeMap","stream","MediaStream","name","removeTrack","item","sender","getSenders","s","senders","some","dispose","leave"],"mappings":"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","file":"static/js/8.82abad25.chunk.js","sourcesContent":["export const isObject = (x: unknown): x is Record<string, unknown> =>\n  typeof x === \"object\" && x !== null;\n\nexport const hasStringProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, string> =>\n  typeof (x as Record<Prop, unknown>)[prop] === \"string\";\n\nexport const hasObjectProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, Record<string, unknown>> =>\n  isObject((x as Record<Prop, unknown>)[prop]);\n\nexport type ReturnPromiseType<\n  F extends (...args: any) => any\n> = ReturnType<F> extends Promise<infer T> ? T : never;\n","export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","const setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = (timeout = 1000) => {\n    if (track.readyState === \"ended\") return;\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    } else if (timeout < 64000) {\n      setTimeout(() => {\n        onmute(timeout * 2);\n      }, timeout);\n    }\n  };\n  track.addEventListener(\"mute\", () => onmute());\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n\nexport const videoTrackToImageConverter = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") {\n    throw new Error(\"track kind is not video\");\n  }\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const imageCapture = new ImageCapture(track);\n  const getImage = async () => {\n    try {\n      const bitmap = await imageCapture.grabFrame();\n      canvas.width = bitmap.width;\n      canvas.height = bitmap.height;\n      ctx.drawImage(bitmap, 0, 0);\n      return canvas.toDataURL(\"image/jpeg\");\n    } catch (e) {\n      console.log(\"failed to grab frame from viedeo track\", e);\n      return null;\n    }\n  };\n  return { getImage };\n};\n\nconst createImage = (src: string): Promise<HTMLImageElement> =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n\nexport const imageToVideoTrackConverter = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const [videoTrack] = canvasStream.getVideoTracks();\n  const setImage = async (dataURL: string) => {\n    const img = await createImage(dataURL);\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n  };\n  return { videoTrack, setImage };\n};\n","import { hasObjectProp, hasStringProp } from \"../utils/types\";\n\nlet peerIndexCounter = 0;\n\nconst getNextPeerIndex = () => {\n  peerIndexCounter += 1;\n  return peerIndexCounter;\n};\n\nexport type Connection = {\n  peerIndex: number;\n  peer: string; // ipfsId\n  userId: string;\n  sendPc: RTCPeerConnection;\n  recvPc: RTCPeerConnection;\n};\n\nconst DEFAULT_CONFIG = {\n  iceServers: [\n    { urls: \"stun:stun.l.google.com:19302\" },\n    {\n      urls: \"turn:0.peerjs.com:3478\",\n      username: \"peerjs\",\n      credential: \"peerjsp\",\n    },\n  ],\n  sdpSemantics: \"unified-plan\",\n};\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Connection;\n    acceptingMediaTypes: string[];\n    remoteMediaTypes: Record<string, string>; // key = mid\n  };\n  const map = new Map<string, Value>();\n\n  const setAcceptingMediaTypes = (conn: Connection, mediaTypes: string[]) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.acceptingMediaTypes = mediaTypes;\n    }\n  };\n\n  const getAcceptingMediaTypes = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (!value) return [];\n    return value.acceptingMediaTypes;\n  };\n\n  const addConn = (peerId: string, userId: string) => {\n    const value = map.get(peerId);\n    if (value) {\n      throw new Error(\"addConn: already exists\");\n    }\n    const conn: Connection = {\n      peerIndex: getNextPeerIndex(),\n      peer: peerId,\n      userId,\n      sendPc: new RTCPeerConnection(DEFAULT_CONFIG),\n      recvPc: new RTCPeerConnection(DEFAULT_CONFIG),\n    };\n    map.set(conn.peer, {\n      conn,\n      acceptingMediaTypes: [],\n      remoteMediaTypes: {},\n    });\n    return conn;\n  };\n\n  const getConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return null;\n    return value.conn;\n  };\n\n  const findConn = (peerIndex: number) => {\n    const value = Array.from(map.values()).find(\n      (v) => v.conn.peerIndex === peerIndex\n    );\n    if (value) return value.conn;\n    return null;\n  };\n\n  const delConn = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n      conn.sendPc.close();\n      conn.recvPc.close();\n    } else {\n      throw new Error(\"delConn: does not exist\");\n    }\n  };\n\n  const getPeerIndexList = () =>\n    Array.from(map.values()).map((v) => v.conn.peerIndex);\n\n  const forEachConns = (callback: (conn: Connection) => void) => {\n    Array.from(map.values()).forEach((value) => {\n      callback(value.conn);\n    });\n  };\n\n  const forEachConnsAcceptingMedia = (\n    mediaType: string,\n    callback: (conn: Connection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.acceptingMediaTypes.includes(mediaType)) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const size = () => map.size;\n\n  const getRemoteMediaType = (conn: Connection, mid: string) => {\n    const value = map.get(conn.peer);\n    if (!value) return null;\n    return value.remoteMediaTypes[mid] || null;\n  };\n\n  const registerRemoteMediaTypeFromSDP = (\n    conn: Connection,\n    msid2mediaType: Record<string, unknown>,\n    sdpLines: string\n  ) => {\n    const value = map.get(conn.peer);\n    if (!value) return;\n    const lines = sdpLines.split(/[\\r\\n]+/);\n    let mid: string;\n    lines.forEach((line) => {\n      if (line.startsWith(\"a=mid:\")) {\n        mid = line.slice(\"a=mid:\".length);\n      } else if (line.startsWith(\"a=msid:\")) {\n        const arr = line.slice(\"a=msid:\".length).split(\" \");\n        arr.forEach((msid) => {\n          const mediaType = msid2mediaType[msid];\n          if (typeof mediaType === \"string\") {\n            value.remoteMediaTypes[mid] = mediaType;\n          }\n        });\n      }\n    });\n  };\n\n  const registerRemoteMediaType = (\n    conn: Connection,\n    sdp: Record<string, unknown>\n  ) => {\n    if (!hasObjectProp(sdp, \"msid2mediaType\")) return;\n    if (hasObjectProp(sdp, \"offer\") && hasStringProp(sdp.offer, \"sdp\")) {\n      registerRemoteMediaTypeFromSDP(conn, sdp.msid2mediaType, sdp.offer.sdp);\n    }\n    if (hasObjectProp(sdp, \"answer\") && hasStringProp(sdp.answer, \"sdp\")) {\n      registerRemoteMediaTypeFromSDP(conn, sdp.msid2mediaType, sdp.answer.sdp);\n    }\n  };\n\n  return {\n    setAcceptingMediaTypes,\n    getAcceptingMediaTypes,\n    addConn,\n    getConn,\n    findConn,\n    delConn,\n    getPeerIndexList,\n    forEachConns,\n    forEachConnsAcceptingMedia,\n    size,\n    getRemoteMediaType,\n    registerRemoteMediaType,\n  };\n};\n","import Ipfs from \"ipfs\";\nimport IpfsPubSubRoom from \"ipfs-pubsub-room\";\n\nimport { sleep } from \"../utils/sleep\";\nimport {\n  secureRandomId,\n  importCryptoKey,\n  encryptStringToChunks,\n  decryptStringFromChunks,\n} from \"../utils/crypto\";\nimport { getWebrtcStarFromUrl } from \"../utils/url\";\nimport { isObject, hasStringProp, hasObjectProp } from \"../utils/types\";\nimport { ROOM_ID_PREFIX_LEN, PeerInfo, CreateRoom } from \"./common\";\nimport { Connection, createConnectionMap } from \"./ipfsUtils\";\nimport { setupTrackStopOnLongMute } from \"./trackUtils\";\n\n// copied from node_modules/ipfs-core/dist/src/components/pubsub.d.ts\ntype Message = {\n  from: string;\n  seqno: Uint8Array;\n  data: Uint8Array;\n  topicIDs: string[];\n};\n\nexport const createRoom: CreateRoom = async (\n  roomId,\n  userId,\n  updateNetworkStatus,\n  notifyNewPeer,\n  receiveData,\n  receiveTrack\n) => {\n  let disposed = false;\n  const connMap = createConnectionMap();\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myConnMap = connMap;\n  }\n  let mediaTypes: string[] = [];\n\n  const roomTopic = roomId.slice(0, ROOM_ID_PREFIX_LEN);\n  const cryptoKey = await importCryptoKey(roomId.slice(ROOM_ID_PREFIX_LEN));\n\n  updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex: 0 });\n  const myIpfs = await Ipfs.create({\n    repo: secureRandomId(),\n    config: {\n      Addresses: {\n        Swarm: [\n          getWebrtcStarFromUrl() ||\n            \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\n        ],\n      },\n      Discovery: {\n        MDNS: { Enabled: true },\n        webRTCStar: { Enabled: true },\n      },\n    },\n  });\n  const myPeerId = (await myIpfs.id()).id;\n  const myIpfsPubSubRoom = new IpfsPubSubRoom(myIpfs, roomTopic);\n  myIpfsPubSubRoom.on(\"message\", (msg) => pubsubHandler(msg));\n  myIpfsPubSubRoom.on(\"peer joined\", () => {\n    broadcastData(null); // XXX this is not efficient, we don't need to broadcast\n  });\n  myIpfsPubSubRoom.on(\"peer left\", (peerId: string) => {\n    const conn = connMap.getConn(peerId);\n    if (conn) {\n      connMap.delConn(conn);\n      updateNetworkStatus({\n        type: \"CONNECTION_CLOSED\",\n        peerIndex: conn.peerIndex,\n      });\n    }\n  });\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myIpfs = myIpfs;\n  }\n\n  const parsePayload = async (encrypted: ArrayBuffer): Promise<unknown> => {\n    try {\n      const str = await decryptStringFromChunks(encrypted, cryptoKey);\n      if (str === null) return undefined;\n      const payload = JSON.parse(str);\n      console.log(\"decrypted payload\", payload);\n      return payload;\n    } catch (e) {\n      console.info(\"Error in parsePayload\", e, encrypted);\n      return undefined;\n    }\n  };\n\n  const sendPayload = async (topic: string, payload: unknown) => {\n    try {\n      console.log(\"payload to encrypt\", topic, payload);\n      for await (const encrypted of encryptStringToChunks(\n        JSON.stringify(payload),\n        cryptoKey\n      )) {\n        myIpfsPubSubRoom.broadcast(encrypted);\n      }\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const sendPayloadDirectly = async (conn: Connection, payload: unknown) => {\n    try {\n      for await (const encrypted of encryptStringToChunks(\n        JSON.stringify(payload),\n        cryptoKey\n      )) {\n        myIpfsPubSubRoom.sendTo(conn.peer, encrypted);\n      }\n    } catch (e) {\n      console.error(\"sendPayloadDirectly\", e);\n    }\n  };\n\n  const broadcastData = async (data: unknown) => {\n    if (disposed) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayload(roomTopic, payload);\n  };\n\n  const sendData = async (data: unknown, peerIndex: number) => {\n    if (disposed) return;\n    const conn = connMap.findConn(peerIndex);\n    if (!conn) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayloadDirectly(conn, payload);\n  };\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).sendData = sendData;\n  }\n\n  const acceptMediaTypes = (mTypes: string[]) => {\n    if (disposed) return;\n    if (mTypes.length !== mediaTypes.length) {\n      connMap.forEachConns((conn) => {\n        const info: PeerInfo = {\n          userId: conn.userId,\n          peerIndex: conn.peerIndex,\n          mediaTypes: connMap.getAcceptingMediaTypes(conn),\n        };\n        const transceivers = conn.recvPc.getTransceivers();\n        conn.recvPc.getReceivers().forEach((receiver) => {\n          const transceiver = transceivers.find((t) => t.receiver === receiver);\n          const mid = transceiver?.mid;\n          const mType = mid && connMap.getRemoteMediaType(conn, mid);\n          if (!mType) {\n            console.warn(\"failed to find media type from mid\");\n            return;\n          }\n          if (\n            receiver.track.readyState === \"live\" &&\n            !mediaTypes.includes(mType) &&\n            mTypes.includes(mType)\n          ) {\n            receiveTrack(\n              mType,\n              setupTrackStopOnLongMute(receiver.track, conn.recvPc),\n              info\n            );\n          }\n        });\n      });\n    }\n    mediaTypes = mTypes;\n    broadcastData(null);\n  };\n\n  const sendSDP = async (\n    conn: Connection,\n    sdp:\n      | {\n          negotiationId: string;\n          offer: RTCSessionDescriptionInit;\n        }\n      | {\n          negotiationId: string;\n          answer: RTCSessionDescriptionInit;\n        }\n  ) => {\n    const msid2mediaType = getMsid2MediaType();\n    await sendPayloadDirectly(conn, { SDP: { ...sdp, msid2mediaType } });\n  };\n\n  const handlePayloadSDP = async (conn: Connection, sdp: unknown) => {\n    if (!isObject(sdp)) return;\n    if (!hasStringProp(sdp, \"negotiationId\")) {\n      console.warn(\"negotiationId not found in SDP\");\n      return;\n    }\n    const { negotiationId } = sdp;\n    connMap.registerRemoteMediaType(conn, sdp);\n    if (hasObjectProp(sdp, \"offer\")) {\n      try {\n        await conn.recvPc.setRemoteDescription(sdp.offer);\n        const answer = await conn.recvPc.createAnswer();\n        await conn.recvPc.setLocalDescription(answer);\n        sendSDP(conn, { negotiationId, answer });\n      } catch (e) {\n        console.info(\"handleSDP offer failed\", e);\n      }\n    } else if (hasObjectProp(sdp, \"answer\")) {\n      if (negotiationIdMap.get(conn) === negotiationId) {\n        negotiationIdMap.delete(conn);\n      }\n      try {\n        await conn.sendPc.setRemoteDescription(sdp.answer);\n      } catch (e) {\n        console.info(\"handleSDP answer failed\", e);\n      }\n    } else {\n      console.warn(\"unknown SDP\", sdp);\n    }\n  };\n\n  const negotiationIdMap = new WeakMap<Connection, string>();\n  const startNegotiation = (conn: Connection) => {\n    const running = negotiationIdMap.has(conn);\n    negotiationIdMap.set(conn, secureRandomId());\n    if (running) return;\n    const negotiate = async () => {\n      const negotiationId = negotiationIdMap.get(conn);\n      if (!negotiationId) return;\n      if (conn.sendPc.signalingState === \"closed\") {\n        negotiationIdMap.delete(conn);\n        return;\n      }\n      const offer = await conn.sendPc.createOffer();\n      await conn.sendPc.setLocalDescription(offer);\n      await sendSDP(conn, { negotiationId, offer });\n      await sleep(5000);\n      negotiate();\n    };\n    negotiate();\n  };\n\n  const sendIce = (\n    conn: Connection,\n    ice: {\n      direction: \"send\" | \"recv\";\n      candidate: RTCIceCandidate;\n    }\n  ) => {\n    sendPayloadDirectly(conn, { ICE: ice });\n  };\n\n  const handlePayloadIce = (conn: Connection, ice: unknown) => {\n    if (!isObject(ice)) return;\n    if (!hasStringProp(ice, \"direction\")) {\n      console.warn(\"direction not found in ICE\");\n      return;\n    }\n    if (!hasObjectProp(ice, \"candidate\")) {\n      console.warn(\"candidate not found in ICE\");\n      return;\n    }\n    try {\n      if (ice.direction === \"send\") {\n        conn.recvPc.addIceCandidate(ice.candidate);\n      } else if (ice.direction === \"recv\") {\n        conn.sendPc.addIceCandidate(ice.candidate);\n      }\n    } catch (e) {\n      console.info(\"handleCandidate failed\", e);\n    }\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Connection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setAcceptingMediaTypes(conn, payloadMediaTypes as string[]);\n      await sleep(5000);\n      syncAllTracks(conn);\n    }\n  };\n\n  const handlePayloadData = (conn: Connection, data: unknown) => {\n    const info: PeerInfo = {\n      userId: conn.userId,\n      peerIndex: conn.peerIndex,\n      mediaTypes: connMap.getAcceptingMediaTypes(conn),\n    };\n    try {\n      receiveData(data, info);\n    } catch (e) {\n      console.warn(\"receiveData\", e);\n    }\n  };\n\n  const handlePayload = async (conn: Connection, payload: unknown) => {\n    try {\n      if (!isObject(payload)) return;\n\n      handlePayloadSDP(conn, (payload as { SDP?: unknown }).SDP);\n      handlePayloadIce(conn, (payload as { ICE?: unknown }).ICE);\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, payload);\n    }\n  };\n\n  const initConnection = (peerId: string, payloadUserId: string) => {\n    const conn = connMap.addConn(peerId, payloadUserId);\n    conn.sendPc.addEventListener(\"icecandidate\", ({ candidate }) => {\n      if (candidate) {\n        sendIce(conn, { direction: \"send\", candidate });\n      }\n    });\n    conn.recvPc.addEventListener(\"icecandidate\", ({ candidate }) => {\n      if (candidate) {\n        sendIce(conn, { direction: \"recv\", candidate });\n      }\n    });\n    conn.recvPc.addEventListener(\"track\", (event: RTCTrackEvent) => {\n      const { mid } = event.transceiver;\n      const mType = mid && connMap.getRemoteMediaType(conn, mid);\n      if (!mType) {\n        console.warn(\"failed to find media type from mid\");\n        return;\n      }\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      receiveTrack(\n        mType,\n        setupTrackStopOnLongMute(event.track, conn.recvPc),\n        info\n      );\n    });\n    notifyNewPeer(conn.peerIndex);\n    updateNetworkStatus({\n      type: \"NEW_CONNECTION\",\n      peerIndex: conn.peerIndex,\n    });\n    return conn;\n  };\n\n  const getUserIdFromPayload = (payload: unknown) => {\n    if (!isObject(payload)) return null;\n    const payloadUserId = (payload as { userId: unknown }).userId;\n    if (typeof payloadUserId !== \"string\") return null;\n    return payloadUserId;\n  };\n\n  const pubsubHandler = async (msg: Message) => {\n    if (disposed) return;\n    if (msg.from === myPeerId) return;\n    const payload = await parsePayload(msg.data);\n    if (payload === undefined) return;\n    const payloadUserId = getUserIdFromPayload(payload);\n    let conn = connMap.getConn(msg.from);\n    if (!conn) {\n      if (payloadUserId) {\n        conn = initConnection(msg.from, payloadUserId);\n      } else {\n        console.warn(\"cannot initialize conn without user id\");\n      }\n    }\n    if (conn) {\n      await handlePayload(conn, payload);\n    }\n    const peerIndexList = connMap.getPeerIndexList();\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const mediaTypeMap = new Map<\n    string,\n    {\n      stream: MediaStream;\n      track: MediaStreamTrack;\n    }\n  >();\n\n  const getMsid2MediaType = () => {\n    const msid2mediaType: Record<string, string> = {};\n    mediaTypeMap.forEach(({ stream }, mType) => {\n      msid2mediaType[stream.id] = mType;\n    });\n    return msid2mediaType;\n  };\n\n  const addTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (disposed) return;\n    if (mediaTypeMap.has(mediaType)) {\n      throw new Error(`track is already added for ${mediaType}`);\n    }\n    const stream = new MediaStream([track]);\n    mediaTypeMap.set(mediaType, { stream, track });\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      try {\n        conn.sendPc.addTrack(track, stream);\n        startNegotiation(conn);\n      } catch (e) {\n        if (e.name === \"InvalidAccessError\") {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n    });\n  };\n\n  const removeTrack = (mediaType: string) => {\n    if (disposed) return;\n    const item = mediaTypeMap.get(mediaType);\n    if (!item) {\n      console.log(\"track is already removed for\", mediaType);\n      return;\n    }\n    const { track } = item;\n    mediaTypeMap.delete(mediaType);\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      const senders = conn.sendPc.getSenders();\n      const sender = senders.find((s) => s.track === track);\n      if (sender && conn.sendPc.signalingState !== \"closed\") {\n        conn.sendPc.removeTrack(sender);\n        startNegotiation(conn);\n      }\n    });\n  };\n\n  const syncAllTracks = (conn: Connection) => {\n    const senders = conn.sendPc.getSenders();\n    const acceptingMediaTypes = connMap.getAcceptingMediaTypes(conn);\n    acceptingMediaTypes.forEach((mType) => {\n      const item = mediaTypeMap.get(mType);\n      if (!item) return;\n      const { stream, track } = item;\n      if (senders.every((sender) => sender.track !== track)) {\n        conn.sendPc.addTrack(track, stream);\n        startNegotiation(conn);\n      }\n    });\n    senders.forEach((sender) => {\n      if (!sender.track) return;\n      const isEffective = acceptingMediaTypes.some(\n        (mType) => mediaTypeMap.get(mType)?.track === sender.track\n      );\n      if (!isEffective && conn.sendPc.signalingState !== \"closed\") {\n        conn.sendPc.removeTrack(sender);\n        startNegotiation(conn);\n      }\n    });\n  };\n\n  const dispose = async () => {\n    disposed = true;\n    await myIpfsPubSubRoom.leave();\n    await myIpfs.stop();\n  };\n\n  return {\n    broadcastData,\n    sendData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n"],"sourceRoot":""}