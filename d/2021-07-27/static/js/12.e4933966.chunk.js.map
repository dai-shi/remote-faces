{"version":3,"sources":["utils/types.ts","utils/sleep.ts","network/trackUtils.ts","network/peerjsUtils.ts","network/peerjsRoom.ts","../../node_modules/peerjs/dist sync"],"names":["isObject","x","hasStringProp","prop","hasObjectProp","sleep","ms","Promise","resolve","setTimeout","setupMap","WeakMap","setupTrackStopOnLongMute","track","pc","has","set","onmute","timeout","readyState","transceiver","getTransceivers","find","t","receiver","currentDirection","stop","dispatchEvent","Event","addEventListener","loopbackPeerConnection","reject","a","pcIn","RTCPeerConnection","pcOut","candidate","addIceCandidate","event","close","addTrack","createOffer","offer","setLocalDescription","setRemoteDescription","createAnswer","answer","videoTrackToImageConverter","kind","Error","canvas","document","createElement","ctx","getContext","imageCapture","ImageCapture","getImage","grabFrame","bitmap","width","height","drawImage","toDataURL","console","log","createImage","src","img","Image","onload","onerror","imageToVideoTrackConverter","captureStream","getVideoTracks","videoTrack","setImage","dataURL","isValidPeerId","roomId","peerId","startsWith","slice","ROOM_ID_PREFIX_LEN","generatePeerId","peerIndex","getPeerIndexFromPeerId","Number","split","getPeerIndexFromConn","conn","peer","createConnectionMap","map","Map","isConnected","value","connected","open","registerRemoteMediaTypeFromSDP","msid2mediaType","sdpLines","mid","get","forEach","line","length","msid","mediaType","remoteMediaTypes","setAcceptingMediaTypes","mediaTypes","acceptingMediaTypes","getAcceptingMediaTypes","addConn","createdAt","Date","now","markConnected","isConnectedPeerId","isConnectedConn","setUserId","userId","getUserId","hasFreshConn","getConn","delConn","delete","getConnectedPeerIds","Array","from","keys","filter","k","getNotConnectedPeerIds","forEachConnectedConns","callback","values","forEachConnsAcceptingMedia","includes","clearAll","size","entries","v","id","clear","getRemoteMediaType","registerRemoteMediaType","sdp","MIN_SEED_PEER_INDEX","MAX_SEED_PEER_INDEX","guessSeed","createRoom","updateNetworkStatus","notifyNewPeer","receiveData","receiveTrack","disposed","connMap","importCryptoKey","cryptoKey","myPeer","initMyPeer","index","isSeed","rand4","type","Peer","getPeerJsConfigFromUrl","on","i","seedId","connectPeer","err","destroy","destroyed","error","initConnection","reconnect","disconnected","showConnectedStatus","peerIndexList","connect","broadcastData","data","peers","sendPayload","sendData","sendSDP","getMsid2MediaType","SDP","handlePayloadSDP","peerConnection","syncAllTracks","info","Math","random","removeAllTracks","warn","handlePayloadUserId","payloadUserId","handlePayloadMediaTypes","payloadMediaTypes","isArray","every","handlePayloadPeers","handlePayloadData","connUserId","e","handlePayload","encrypted","JSON","decryptString","payload","parse","encryptString","stringify","send","timer","scheduleClose","clearTimeout","buf","iceGatheringState","onicecandidate","negotiationScheduled","signalingState","mType","reInitMyPeer","waitSec","floor","force","existsAllSeeds","acceptMediaTypes","mTypes","transceivers","getReceivers","mediaTypeMap","stream","MediaStream","name","removeTrack","item","sender","getSenders","s","senders","some","transport","dispose","webpackEmptyContext","req","code","module","exports"],"mappings":"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","file":"static/js/12.e4933966.chunk.js","sourcesContent":["export const isObject = (x: unknown): x is Record<string, unknown> =>\n  typeof x === \"object\" && x !== null;\n\nexport const hasStringProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, string> =>\n  typeof (x as Record<Prop, unknown>)[prop] === \"string\";\n\nexport const hasObjectProp = <\n  Obj extends Record<string, unknown>,\n  Prop extends string\n>(\n  x: Obj,\n  prop: Prop\n): x is Obj & Record<Prop, Record<string, unknown>> =>\n  isObject((x as Record<Prop, unknown>)[prop]);\n\nexport type ReturnPromiseType<\n  F extends (...args: any) => any\n> = ReturnType<F> extends Promise<infer T> ? T : never;\n","export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","const setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = (timeout = 1000) => {\n    if (track.readyState === \"ended\") return;\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    } else if (timeout < 64000) {\n      setTimeout(() => {\n        onmute(timeout * 2);\n      }, timeout);\n    }\n  };\n  track.addEventListener(\"mute\", () => onmute());\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n\nexport const videoTrackToImageConverter = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") {\n    throw new Error(\"track kind is not video\");\n  }\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const imageCapture = new ImageCapture(track);\n  const getImage = async () => {\n    try {\n      const bitmap = await imageCapture.grabFrame();\n      canvas.width = bitmap.width;\n      canvas.height = bitmap.height;\n      ctx.drawImage(bitmap, 0, 0);\n      return canvas.toDataURL(\"image/jpeg\");\n    } catch (e) {\n      console.log(\"failed to grab frame from viedeo track\", e);\n      return null;\n    }\n  };\n  return { getImage };\n};\n\nconst createImage = (src: string): Promise<HTMLImageElement> =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n\nexport const imageToVideoTrackConverter = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const [videoTrack] = canvasStream.getVideoTracks();\n  const setImage = async (dataURL: string) => {\n    const img = await createImage(dataURL);\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n  };\n  return { videoTrack, setImage };\n};\n","import Peer from \"peerjs\";\n\nimport { ROOM_ID_PREFIX_LEN } from \"./common\";\nimport { hasObjectProp, hasStringProp } from \"../utils/types\";\n\nexport const isValidPeerId = (\n  roomId: string,\n  peerId: unknown\n): peerId is string =>\n  typeof peerId === \"string\" &&\n  peerId.startsWith(`${roomId.slice(0, ROOM_ID_PREFIX_LEN)} `);\n\nexport const generatePeerId = (roomId: string, peerIndex: number) =>\n  `${roomId.slice(0, ROOM_ID_PREFIX_LEN)} ${peerIndex}`;\n\nexport const getPeerIndexFromPeerId = (peerId: string) =>\n  Number(peerId.split(\" \")[1]);\n\nexport const getPeerIndexFromConn = (conn: Peer.DataConnection) =>\n  getPeerIndexFromPeerId(conn.peer);\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Peer.DataConnection;\n    createdAt: number;\n    connected?: boolean;\n    userId?: string;\n    acceptingMediaTypes: string[];\n    remoteMediaTypes: Record<string, string>; // key = mid\n  };\n  const map = new Map<string, Value>();\n\n  const setAcceptingMediaTypes = (\n    conn: Peer.DataConnection,\n    mediaTypes: string[]\n  ) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.acceptingMediaTypes = mediaTypes;\n    }\n  };\n\n  const getAcceptingMediaTypes = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (!value) return [];\n    return value.acceptingMediaTypes;\n  };\n\n  const addConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    map.set(conn.peer, {\n      conn,\n      createdAt: Date.now(),\n      acceptingMediaTypes: [],\n      remoteMediaTypes: {},\n    });\n    if (value) {\n      value.conn.close();\n    }\n  };\n\n  const markConnected = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      value.connected = true;\n    }\n  };\n\n  const isConnected = (value?: Value) =>\n    !!(value && value.connected && value.conn.open);\n\n  const isConnectedPeerId = (peerId: string) => isConnected(map.get(peerId));\n\n  const isConnectedConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      return isConnected(value);\n    }\n    return false;\n  };\n\n  const setUserId = (conn: Peer.DataConnection, userId: string) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.userId = userId;\n    }\n  };\n\n  const getUserId = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    return value && value.userId;\n  };\n\n  const hasFreshConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return false;\n    return value.createdAt > Date.now() - 10 * 60 * 1000; // 10min\n  };\n\n  const getConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return null;\n    return value.conn;\n  };\n\n  const delConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n      return true;\n    }\n    return false;\n  };\n\n  const getConnectedPeerIds = () =>\n    Array.from(map.keys()).filter((k) => isConnected(map.get(k)));\n\n  const getNotConnectedPeerIds = () =>\n    Array.from(map.keys()).filter((k) => !isConnected(map.get(k)));\n\n  const forEachConnectedConns = (\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (isConnected(value)) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const forEachConnsAcceptingMedia = (\n    mediaType: string,\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (isConnected(value) && value.acceptingMediaTypes.includes(mediaType)) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const clearAll = () => {\n    if (map.size) {\n      console.log(\n        \"connectionMap garbage:\",\n        [...map.entries()].map(([k, v]) => ({\n          id: k,\n          createdAt: v.createdAt,\n          connected: v.connected,\n          open: v.conn.open,\n          userId: v.userId,\n        }))\n      );\n    }\n    map.clear();\n  };\n\n  const getRemoteMediaType = (conn: Peer.DataConnection, mid: string) => {\n    const value = map.get(conn.peer);\n    if (!value) return null;\n    return value.remoteMediaTypes[mid] || null;\n  };\n\n  const registerRemoteMediaTypeFromSDP = (\n    conn: Peer.DataConnection,\n    msid2mediaType: Record<string, unknown>,\n    sdpLines: string\n  ) => {\n    const value = map.get(conn.peer);\n    if (!value) return;\n    const lines = sdpLines.split(/[\\r\\n]+/);\n    let mid: string;\n    lines.forEach((line) => {\n      if (line.startsWith(\"a=mid:\")) {\n        mid = line.slice(\"a=mid:\".length);\n      } else if (line.startsWith(\"a=msid:\")) {\n        const arr = line.slice(\"a=msid:\".length).split(\" \");\n        arr.forEach((msid) => {\n          const mediaType = msid2mediaType[msid];\n          if (typeof mediaType === \"string\") {\n            value.remoteMediaTypes[mid] = mediaType;\n          }\n        });\n      }\n    });\n  };\n\n  const registerRemoteMediaType = (\n    conn: Peer.DataConnection,\n    sdp: Record<string, unknown>\n  ) => {\n    if (!hasObjectProp(sdp, \"msid2mediaType\")) return;\n    if (hasObjectProp(sdp, \"offer\") && hasStringProp(sdp.offer, \"sdp\")) {\n      registerRemoteMediaTypeFromSDP(conn, sdp.msid2mediaType, sdp.offer.sdp);\n    }\n    if (hasObjectProp(sdp, \"answer\") && hasStringProp(sdp.answer, \"sdp\")) {\n      registerRemoteMediaTypeFromSDP(conn, sdp.msid2mediaType, sdp.answer.sdp);\n    }\n  };\n\n  return {\n    setAcceptingMediaTypes,\n    getAcceptingMediaTypes,\n    addConn,\n    markConnected,\n    isConnectedPeerId,\n    isConnectedConn,\n    setUserId,\n    getUserId,\n    hasFreshConn,\n    getConn,\n    delConn,\n    getConnectedPeerIds,\n    getNotConnectedPeerIds,\n    forEachConnectedConns,\n    forEachConnsAcceptingMedia,\n    clearAll,\n    getRemoteMediaType,\n    registerRemoteMediaType,\n  };\n};\n","import Peer from \"peerjs\";\n\nimport { sleep } from \"../utils/sleep\";\nimport {\n  rand4,\n  importCryptoKey,\n  encryptString,\n  decryptString,\n} from \"../utils/crypto\";\nimport { getPeerJsConfigFromUrl } from \"../utils/url\";\nimport { isObject, hasObjectProp } from \"../utils/types\";\nimport { ROOM_ID_PREFIX_LEN, PeerInfo, CreateRoom } from \"./common\";\nimport {\n  isValidPeerId,\n  generatePeerId,\n  getPeerIndexFromPeerId,\n  getPeerIndexFromConn,\n  createConnectionMap,\n} from \"./peerjsUtils\";\nimport { setupTrackStopOnLongMute } from \"./trackUtils\";\n\nconst MIN_SEED_PEER_INDEX = 10; // config\nconst MAX_SEED_PEER_INDEX = 14; // config\nconst guessSeed = (id: string) => {\n  const peerIndex = getPeerIndexFromPeerId(id);\n  return MIN_SEED_PEER_INDEX <= peerIndex && peerIndex <= MAX_SEED_PEER_INDEX;\n};\n\nexport const createRoom: CreateRoom = async (\n  roomId,\n  userId,\n  updateNetworkStatus,\n  notifyNewPeer,\n  receiveData,\n  receiveTrack\n) => {\n  let disposed = false;\n  const connMap = createConnectionMap();\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myConnMap = connMap;\n  }\n  let mediaTypes: string[] = [];\n\n  const cryptoKey = await importCryptoKey(roomId.slice(ROOM_ID_PREFIX_LEN));\n\n  let myPeer: Peer | null = null;\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).getMyPeer = () => myPeer;\n  }\n  const initMyPeer = (index = MIN_SEED_PEER_INDEX) => {\n    if (disposed) return;\n    connMap.clearAll();\n    const isSeed = MIN_SEED_PEER_INDEX <= index && index <= MAX_SEED_PEER_INDEX;\n    const peerIndex = isSeed ? index : rand4();\n    updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex });\n    const id = generatePeerId(roomId, peerIndex);\n    const peer = new Peer(id, getPeerJsConfigFromUrl());\n    peer.on(\"open\", () => {\n      myPeer = peer;\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      setTimeout(() => {\n        for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n          const seedId = generatePeerId(roomId, i);\n          connectPeer(seedId);\n        }\n      }, 10);\n    });\n    peer.on(\"error\", (err) => {\n      if (err.type === \"unavailable-id\") {\n        peer.destroy();\n        initMyPeer(index + 1);\n      } else if (err.type === \"peer-unavailable\") {\n        // ignore\n      } else if (err.type === \"disconnected\") {\n        console.log(\"initMyPeer disconnected error\", peerIndex, err);\n      } else if (err.type === \"network\") {\n        console.log(\"initMyPeer network error\", peerIndex, err);\n        setTimeout(() => {\n          if (!peer.destroyed && myPeer === null) {\n            peer.destroy();\n            initMyPeer();\n          }\n        }, 10 * 1000);\n      } else if (err.type === \"server-error\") {\n        console.log(\"initMyPeer server error\", peerIndex, err);\n        updateNetworkStatus({ type: \"SERVER_ERROR\" });\n      } else {\n        console.error(\"initMyPeer unknown error\", peerIndex, err.type, err);\n        updateNetworkStatus({ type: \"UNKNOWN_ERROR\", err });\n      }\n    });\n    peer.on(\"connection\", (conn) => {\n      if (peer !== myPeer) {\n        console.log(\"new connection to old peer, closing\");\n        conn.close();\n        return;\n      }\n      if (peer.id === conn.peer) {\n        console.log(\"new connection from self, closing\");\n        conn.close();\n        return;\n      }\n      updateNetworkStatus({\n        type: \"NEW_CONNECTION\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      initConnection(conn);\n    });\n    peer.on(\"disconnected\", () => {\n      console.log(\"initMyPeer disconnected\", peerIndex);\n      setTimeout(() => {\n        if (!peer.destroyed && peer === myPeer) {\n          updateNetworkStatus({ type: \"RECONNECTING\", peerIndex });\n          peer.reconnect();\n          setTimeout(() => {\n            if (peer.disconnected && !peer.destroyed && peer === myPeer) {\n              console.log(\"reconnect failed, re-initializing\");\n              peer.destroy();\n              myPeer = null;\n              initMyPeer();\n            }\n          }, 60 * 1000);\n        }\n      }, 5 * 1000);\n    });\n  };\n  initMyPeer();\n\n  const showConnectedStatus = () => {\n    if (disposed) return;\n    const peerIndexList = connMap\n      .getConnectedPeerIds()\n      .map(getPeerIndexFromPeerId);\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n    console.log(\n      \"myPeer index:\",\n      myPeer?.id && getPeerIndexFromPeerId(myPeer.id),\n      \", connecting:\",\n      connMap.getNotConnectedPeerIds().map(getPeerIndexFromPeerId)\n    );\n  };\n\n  const connectPeer = (id: string) => {\n    if (disposed || !myPeer) return;\n    if (myPeer.id === id || myPeer.disconnected) return;\n    if (connMap.isConnectedPeerId(id)) return;\n    if (connMap.hasFreshConn(id)) return;\n    console.log(\"connectPeer\", id);\n    const conn = myPeer.connect(id);\n    initConnection(conn);\n  };\n\n  const broadcastData = (data: unknown) => {\n    if (disposed) return;\n    const peers = connMap.getConnectedPeerIds();\n    connMap.forEachConnectedConns((conn) => {\n      sendPayload(conn, { userId, data, peers, mediaTypes });\n    });\n  };\n\n  const sendData = (data: unknown, peerIndex: number) => {\n    if (disposed) return;\n    const conn = connMap.getConn(generatePeerId(roomId, peerIndex));\n    if (!conn) return;\n    const peers = connMap.getConnectedPeerIds();\n    sendPayload(conn, { userId, data, peers, mediaTypes });\n  };\n\n  const sendSDP = (\n    conn: Peer.DataConnection,\n    sdp: { offer: unknown } | { answer: unknown }\n  ) => {\n    const msid2mediaType = getMsid2MediaType();\n    sendPayload(conn, { SDP: { ...sdp, msid2mediaType } });\n  };\n\n  const handlePayloadSDP = async (conn: Peer.DataConnection, sdp: unknown) => {\n    if (!isObject(sdp)) return;\n    connMap.registerRemoteMediaType(conn, sdp);\n    if (hasObjectProp(sdp, \"offer\")) {\n      try {\n        await conn.peerConnection.setRemoteDescription(sdp.offer);\n        syncAllTracks(conn);\n        const answer = await conn.peerConnection.createAnswer();\n        await conn.peerConnection.setLocalDescription(answer);\n        sendSDP(conn, { answer });\n      } catch (e) {\n        console.info(\"handleSDP offer failed\", e);\n      }\n    } else if (hasObjectProp(sdp, \"answer\")) {\n      try {\n        await conn.peerConnection.setRemoteDescription(sdp.answer);\n      } catch (e) {\n        console.info(\"handleSDP answer failed\", e);\n        await sleep(Math.random() * 30 * 1000);\n        removeAllTracks(conn);\n        syncAllTracks(conn);\n      }\n    } else {\n      console.warn(\"unknown SDP\", sdp);\n    }\n  };\n\n  const handlePayloadUserId = (\n    conn: Peer.DataConnection,\n    payloadUserId: unknown\n  ) => {\n    if (typeof payloadUserId === \"string\") {\n      connMap.setUserId(conn, payloadUserId);\n    }\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Peer.DataConnection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setAcceptingMediaTypes(conn, payloadMediaTypes as string[]);\n      await sleep(5000);\n      syncAllTracks(conn);\n    }\n  };\n\n  const handlePayloadPeers = (peers: unknown) => {\n    if (Array.isArray(peers)) {\n      peers.forEach((peer) => {\n        if (isValidPeerId(roomId, peer)) {\n          connectPeer(peer);\n        }\n      });\n    }\n  };\n\n  const handlePayloadData = (conn: Peer.DataConnection, data: unknown) => {\n    const connUserId = connMap.getUserId(conn);\n    if (connUserId) {\n      const info: PeerInfo = {\n        userId: connUserId,\n        peerIndex: getPeerIndexFromConn(conn),\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      try {\n        receiveData(data, info);\n      } catch (e) {\n        console.warn(\"receiveData\", e);\n      }\n    }\n  };\n\n  const handlePayload = async (\n    conn: Peer.DataConnection,\n    encrypted: ArrayBuffer\n  ) => {\n    if (disposed) return;\n    try {\n      const payload = JSON.parse(await decryptString(encrypted, cryptoKey));\n      // console.log(\"decrypted payload\", conn.peer, payload);\n      if (!isObject(payload)) return;\n\n      handlePayloadSDP(conn, (payload as { SDP?: unknown }).SDP);\n      handlePayloadUserId(conn, (payload as { userId?: unknown }).userId);\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadPeers((payload as { peers?: unknown }).peers);\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, encrypted);\n    }\n  };\n\n  const sendPayload = async (conn: Peer.DataConnection, payload: unknown) => {\n    try {\n      const encrypted = await encryptString(JSON.stringify(payload), cryptoKey);\n      conn.send(encrypted);\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const initConnection = (conn: Peer.DataConnection) => {\n    if (connMap.isConnectedPeerId(conn.peer)) {\n      console.info(\"dataConnection already in map, overriding\", conn.peer);\n    }\n    connMap.addConn(conn);\n    let timer: NodeJS.Timeout;\n    const scheduleClose = () => {\n      clearTimeout(timer);\n      timer = setTimeout(() => {\n        const peerIndex = getPeerIndexFromConn(conn);\n        console.log(\"dataConnection inactive for 5min\", peerIndex);\n        conn.close();\n      }, 5 * 60 * 1000); // 5 minutes\n    };\n    scheduleClose();\n    conn.on(\"open\", () => {\n      scheduleClose();\n      connMap.markConnected(conn);\n      const peerIndex = getPeerIndexFromConn(conn);\n      console.log(\"dataConnection open\", peerIndex);\n      showConnectedStatus();\n      notifyNewPeer(peerIndex);\n    });\n    conn.on(\"data\", (buf: ArrayBuffer) => {\n      scheduleClose();\n      connMap.markConnected(conn);\n      handlePayload(conn, buf);\n    });\n    conn.peerConnection.addEventListener(\"icegatheringstatechange\", () => {\n      const pc = conn.peerConnection;\n      if (pc.iceGatheringState === \"complete\") {\n        pc.onicecandidate = () => undefined;\n      }\n    });\n    let negotiationScheduled = false;\n    conn.peerConnection.addEventListener(\"negotiationneeded\", async () => {\n      if (negotiationScheduled) return;\n      negotiationScheduled = true;\n      await sleep(5000);\n      negotiationScheduled = false;\n      if (!connMap.isConnectedConn(conn)) return;\n      if (!conn.peerConnection) return;\n      if (conn.peerConnection.signalingState === \"closed\") return;\n      const offer = await conn.peerConnection.createOffer();\n      await conn.peerConnection.setLocalDescription(offer);\n      sendSDP(conn, { offer });\n    });\n    conn.peerConnection.addEventListener(\"track\", (event: RTCTrackEvent) => {\n      if (!connMap.isConnectedConn(conn)) {\n        console.warn(\"received track from non-connected peer, ignoring\");\n        return;\n      }\n      const { mid } = event.transceiver;\n      const mType = mid && connMap.getRemoteMediaType(conn, mid);\n      if (!mType) {\n        console.warn(\"failed to find media type from mid\");\n        return;\n      }\n      const connUserId = connMap.getUserId(conn);\n      if (connUserId) {\n        const info: PeerInfo = {\n          userId: connUserId,\n          peerIndex: getPeerIndexFromPeerId(conn.peer),\n          mediaTypes: connMap.getAcceptingMediaTypes(conn),\n        };\n        receiveTrack(\n          mType,\n          setupTrackStopOnLongMute(event.track, conn.peerConnection),\n          info\n        );\n      }\n    });\n    conn.on(\"close\", () => {\n      clearTimeout(timer);\n      if (!connMap.delConn(conn)) return;\n      const peerIndex = getPeerIndexFromConn(conn);\n      updateNetworkStatus({ type: \"CONNECTION_CLOSED\", peerIndex });\n      showConnectedStatus();\n      if (connMap.getConnectedPeerIds().length === 0) {\n        reInitMyPeer(true);\n      } else if (\n        myPeer &&\n        guessSeed(conn.peer) &&\n        !myPeer.disconnected &&\n        !guessSeed(myPeer.id)\n      ) {\n        const waitSec = 10 * 60 + Math.floor(Math.random() * 10 * 60);\n        console.log(\n          `Disconnected seed peer: ${peerIndex}, reinit in ${waitSec}sec...`\n        );\n        setTimeout(reInitMyPeer, waitSec * 1000);\n      }\n    });\n  };\n\n  const reInitMyPeer = (force?: boolean) => {\n    if (!myPeer || myPeer.disconnected) return; // should already be handled\n    if (!force) {\n      if (guessSeed(myPeer.id)) return;\n      let existsAllSeeds = true;\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const id = generatePeerId(roomId, i);\n        if (!connMap.isConnectedPeerId(id)) {\n          existsAllSeeds = false;\n          break;\n        }\n      }\n      if (existsAllSeeds) {\n        showConnectedStatus();\n        return;\n      }\n    }\n    myPeer.destroy();\n    myPeer = null;\n    initMyPeer();\n  };\n\n  const acceptMediaTypes = (mTypes: string[]) => {\n    if (disposed) return;\n    if (mTypes.length !== mediaTypes.length) {\n      connMap.forEachConnectedConns((conn) => {\n        const connUserId = connMap.getUserId(conn);\n        if (connUserId) {\n          const info: PeerInfo = {\n            userId: connUserId,\n            peerIndex: getPeerIndexFromPeerId(conn.peer),\n            mediaTypes: connMap.getAcceptingMediaTypes(conn),\n          };\n          const transceivers = conn.peerConnection.getTransceivers();\n          conn.peerConnection.getReceivers().forEach((receiver) => {\n            const transceiver = transceivers.find(\n              (t) => t.receiver === receiver\n            );\n            const mid = transceiver?.mid;\n            const mType = mid && connMap.getRemoteMediaType(conn, mid);\n            if (!mType) {\n              console.warn(\"failed to find media type from mid\");\n              return;\n            }\n            if (\n              receiver.track.readyState === \"live\" &&\n              !mediaTypes.includes(mType) &&\n              mTypes.includes(mType)\n            ) {\n              receiveTrack(\n                mType,\n                setupTrackStopOnLongMute(receiver.track, conn.peerConnection),\n                info\n              );\n            }\n          });\n        }\n      });\n    }\n    mediaTypes = mTypes;\n    broadcastData(null);\n  };\n\n  const mediaTypeMap = new Map<\n    string,\n    {\n      stream: MediaStream;\n      track: MediaStreamTrack;\n    }\n  >();\n\n  const getMsid2MediaType = () => {\n    const msid2mediaType: Record<string, string> = {};\n    mediaTypeMap.forEach(({ stream }, mType) => {\n      msid2mediaType[stream.id] = mType;\n    });\n    return msid2mediaType;\n  };\n\n  const addTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (disposed) return;\n    if (mediaTypeMap.has(mediaType)) {\n      throw new Error(`track is already added for ${mediaType}`);\n    }\n    const stream = new MediaStream([track]);\n    mediaTypeMap.set(mediaType, { stream, track });\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      try {\n        conn.peerConnection.addTrack(track, stream);\n      } catch (e) {\n        if (e.name === \"InvalidAccessError\") {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n    });\n  };\n\n  const removeTrack = (mediaType: string) => {\n    if (disposed) return;\n    const item = mediaTypeMap.get(mediaType);\n    if (!item) {\n      console.log(\"track is already removed for\", mediaType);\n      return;\n    }\n    const { track } = item;\n    mediaTypeMap.delete(mediaType);\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      const senders = conn.peerConnection?.getSenders() ?? [];\n      const sender = senders.find((s) => s.track === track);\n      if (sender && conn.peerConnection.signalingState !== \"closed\") {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const syncAllTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection?.getSenders() ?? [];\n    const acceptingMediaTypes = connMap.getAcceptingMediaTypes(conn);\n    acceptingMediaTypes.forEach((mType) => {\n      const item = mediaTypeMap.get(mType);\n      if (!item) return;\n      const { stream, track } = item;\n      if (senders.every((sender) => sender.track !== track)) {\n        conn.peerConnection.addTrack(track, stream);\n      }\n    });\n    senders.forEach((sender) => {\n      if (!sender.track) return;\n      const isEffective = acceptingMediaTypes.some(\n        (mType) => mediaTypeMap.get(mType)?.track === sender.track\n      );\n      if (!isEffective && conn.peerConnection.signalingState !== \"closed\") {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n    if (senders.some((sender) => sender.track && !sender.transport)) {\n      conn.peerConnection.dispatchEvent(new Event(\"negotiationneeded\"));\n    }\n  };\n\n  const removeAllTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection?.getSenders() ?? [];\n    senders.forEach((sender) => {\n      if (sender.track && conn.peerConnection.signalingState !== \"closed\") {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const dispose = () => {\n    disposed = true;\n    if (myPeer) {\n      myPeer.destroy();\n      myPeer = null;\n    }\n  };\n\n  return {\n    broadcastData,\n    sendData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 661;"],"sourceRoot":""}