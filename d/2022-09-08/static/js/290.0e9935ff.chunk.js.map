{"version":3,"file":"static/js/290.0e9935ff.chunk.js","mappings":"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","sources":["network/pubsubUtils.ts","network/pubsubRoom.ts","network/trackUtils.ts"],"sourcesContent":["let peerIndexCounter = 0;\n\nconst getNextPeerIndex = () => {\n  peerIndexCounter += 1;\n  return peerIndexCounter;\n};\n\n// XXX It would be nice to reuse audio worker for all connections\nexport type Connection = {\n  peerIndex: number;\n  peer: string; // ipfsId\n  userId: string;\n  audioWorkers: Map<string, Worker>; // <mediaType, audioDecoder>\n  vidoeSetImages: Map<string, (s: string) => void>; // <mediaType, setImage>\n};\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Connection;\n    acceptingMediaTypes: string[];\n  };\n  const map = new Map<string, Value>();\n\n  const setAcceptingMediaTypes = (conn: Connection, mediaTypes: string[]) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.acceptingMediaTypes = mediaTypes;\n    }\n  };\n\n  const getAcceptingMediaTypes = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (!value) return [];\n    return value.acceptingMediaTypes;\n  };\n\n  const addConn = (peerId: string, userId: string) => {\n    const value = map.get(peerId);\n    if (value) {\n      throw new Error(\"addConn: already exists\");\n    }\n    const conn: Connection = {\n      peerIndex: getNextPeerIndex(),\n      peer: peerId,\n      userId,\n      audioWorkers: new Map(),\n      vidoeSetImages: new Map(),\n    };\n    map.set(conn.peer, {\n      conn,\n      acceptingMediaTypes: [],\n    });\n    return conn;\n  };\n\n  const getConn = (peerId: string) => {\n    const value = map.get(peerId);\n    if (!value) return null;\n    return value.conn;\n  };\n\n  const findConn = (peerIndex: number) => {\n    const value = Array.from(map.values()).find(\n      (v) => v.conn.peerIndex === peerIndex\n    );\n    if (value) return value.conn;\n    return null;\n  };\n\n  const delConn = (conn: Connection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n    } else {\n      throw new Error(\"delConn: does not exist\");\n    }\n  };\n\n  const getPeerIndexList = () =>\n    Array.from(map.values()).map((v) => v.conn.peerIndex);\n\n  const forEachConns = (callback: (conn: Connection) => void) => {\n    Array.from(map.values()).forEach((value) => {\n      callback(value.conn);\n    });\n  };\n\n  const size = () => map.size;\n\n  return {\n    setAcceptingMediaTypes,\n    getAcceptingMediaTypes,\n    addConn,\n    getConn,\n    findConn,\n    delConn,\n    getPeerIndexList,\n    forEachConns,\n    size,\n  };\n};\n","import { create as createUntyped } from \"ipfs\";\nimport type { create as createFn } from \"ipfs-core/types/src/components/index\";\nimport type { Message } from \"ipfs-core-types/types/src/pubsub/index\";\n\nimport { sleep } from \"../utils/sleep\";\nimport {\n  sha256,\n  secureRandomId,\n  importCryptoKey,\n  encryptStringToChunks,\n  decryptStringFromChunks,\n  encryptBufferFromChunks,\n  decryptBufferToChunks,\n} from \"../utils/crypto\";\nimport { getWebrtcStarFromUrl } from \"../utils/url\";\nimport { isObject } from \"../utils/types\";\nimport { ROOM_ID_PREFIX_LEN, PeerInfo, CreateRoom } from \"./common\";\nimport { Connection, createConnectionMap } from \"./pubsubUtils\";\nimport {\n  loopbackPeerConnection,\n  videoTrackToImageConverter,\n  imageToVideoTrackConverter,\n} from \"./trackUtils\";\n\nconst create = createUntyped as typeof createFn;\n\nconst topicsForMediaTypes = new Map<string, string>();\n\nconst getTopicForMediaType = async (roomId: string, mediaType: string) => {\n  const key = `${roomId} ${mediaType}`;\n  let topic = topicsForMediaTypes.get(key);\n  if (!topic) {\n    topic = (await sha256(key)).slice(0, ROOM_ID_PREFIX_LEN);\n    topicsForMediaTypes.set(key, topic);\n  }\n  return topic;\n};\n\nexport const createRoom: CreateRoom = async (\n  roomId,\n  userId,\n  updateNetworkStatus,\n  notifyNewPeer,\n  receiveData,\n  receiveTrack\n) => {\n  let disposed = false;\n  const connMap = createConnectionMap();\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myConnMap = connMap;\n  }\n  let mediaTypes: readonly string[] = [];\n\n  const roomTopic = roomId.slice(0, ROOM_ID_PREFIX_LEN);\n  const cryptoKey = await importCryptoKey(roomId.slice(ROOM_ID_PREFIX_LEN));\n\n  updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex: 0 });\n  const myIpfs = await create({\n    repo: secureRandomId(),\n    config: {\n      Addresses: {\n        Swarm: [\n          getWebrtcStarFromUrl() ||\n            \"/dns4/wrtc-star1.par.dwebops.pub/tcp/443/wss/p2p-webrtc-star/\",\n        ],\n      },\n      Bootstrap: [], // not sure why this helps\n    },\n  });\n  const myPeerId = (await myIpfs.id()).id;\n  await myIpfs.pubsub.subscribe(roomTopic, (msg) => pubsubHandler(msg));\n  await myIpfs.pubsub.subscribe(`${roomTopic} ${myPeerId}`, (msg) =>\n    pubsubHandler(msg)\n  );\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).myIpfs = myIpfs;\n  }\n\n  const parsePayload = async (encrypted: ArrayBuffer): Promise<unknown> => {\n    try {\n      const str = await decryptStringFromChunks(encrypted, cryptoKey);\n      if (str === null) return undefined;\n      const payload = JSON.parse(str);\n      console.log(\"decrypted payload\", payload);\n      return payload;\n    } catch (e) {\n      console.info(\"Error in parsePayload\", e, encrypted);\n      return undefined;\n    }\n  };\n\n  const sendPayload = async (topic: string, payload: unknown) => {\n    try {\n      console.log(\"payload to encrypt\", topic, payload);\n      for await (const encrypted of encryptStringToChunks(\n        JSON.stringify(payload),\n        cryptoKey\n      )) {\n        await myIpfs.pubsub.publish(topic, new Uint8Array(encrypted), {});\n      }\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const sendPayloadDirectly = async (conn: Connection, payload: unknown) => {\n    const topic = `${roomTopic} ${conn.peer}`;\n    // XXX this doesn't seem to work in ipfs v0.48.0\n    await sendPayload(topic, payload);\n  };\n\n  const broadcastData = async (data: unknown) => {\n    if (disposed) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayload(roomTopic, payload);\n  };\n\n  const sendData = async (data: unknown, peerIndex: number) => {\n    if (disposed) return;\n    const conn = connMap.findConn(peerIndex);\n    if (!conn) return;\n    const payload = { userId, data, mediaTypes };\n    await sendPayloadDirectly(conn, payload);\n  };\n  if (process.env.NODE_ENV !== \"production\") {\n    (window as any).sendData = sendData;\n  }\n\n  const mediaTypeDisposeMap = new Map<string, (() => void)[]>();\n\n  const acceptAudioMedia = async (mediaType: string) => {\n    const disposeList: (() => void)[] = [];\n    mediaTypeDisposeMap.set(mediaType, disposeList);\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const audioHandler = async (msg: Message) => {\n      if (!(\"from\" in msg)) return;\n      if (msg.from.toString() === myPeerId.toString()) return;\n      const conn = connMap.getConn(msg.from.toString());\n      if (!conn) {\n        console.warn(\"conn not ready\");\n        return;\n      }\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      if (!conn.audioWorkers.has(mediaType)) {\n        const audioCtx = new AudioContext();\n        const destination = audioCtx.createMediaStreamDestination();\n        let currTime = 0;\n        let pending = 0;\n        const worker = new Worker(\"audio-decoder.js\", { type: \"module\" });\n        worker.onmessage = (e) => {\n          const buffer = new Float32Array(e.data);\n          if (!pending) {\n            currTime = audioCtx.currentTime;\n          }\n          currTime += 0.06; // 60ms\n          pending += 1;\n          const audioBuffer = audioCtx.createBuffer(1, 2880, 48000);\n          audioBuffer.copyToChannel(buffer, 0);\n          const audioBufferSource = audioCtx.createBufferSource();\n          audioBufferSource.buffer = audioBuffer;\n          audioBufferSource.connect(destination);\n          audioBufferSource.onended = () => {\n            pending -= 1;\n          };\n          audioBufferSource.start(currTime);\n        };\n        conn.audioWorkers.set(mediaType, worker);\n        const audioTrack = destination.stream.getAudioTracks()[0];\n        receiveTrack(mediaType, await loopbackPeerConnection(audioTrack), info);\n        // XXX currently no way to detect track stop\n        disposeList.push(() => {\n          audioCtx.close();\n          audioTrack.dispatchEvent(new Event(\"ended\"));\n          worker.terminate();\n          conn.audioWorkers.delete(mediaType);\n        });\n      }\n      const bufList = await decryptBufferToChunks(\n        msg.data.buffer,\n        msg.data.byteOffset,\n        msg.data.byteLength,\n        cryptoKey\n      );\n      const worker = conn.audioWorkers.get(mediaType);\n      if (worker) {\n        bufList.forEach((buf) => {\n          worker.postMessage([buf], [buf]);\n        });\n      }\n    };\n    myIpfs.pubsub.subscribe(topic, audioHandler);\n    disposeList.unshift(() => {\n      myIpfs.pubsub.unsubscribe(topic, audioHandler);\n    });\n  };\n\n  const acceptVideoMedia = async (mediaType: string) => {\n    const disposeList: (() => void)[] = [];\n    mediaTypeDisposeMap.set(mediaType, disposeList);\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const videoHandler = async (msg: Message) => {\n      if (!(\"from\" in msg)) return;\n      if (msg.from.toString() === myPeerId.toString()) return;\n      const conn = connMap.getConn(msg.from.toString());\n      if (!conn) {\n        console.warn(\"conn not ready\");\n        return;\n      }\n      const info: PeerInfo = {\n        userId: conn.userId,\n        peerIndex: conn.peerIndex,\n        mediaTypes: connMap.getAcceptingMediaTypes(conn),\n      };\n      if (!conn.vidoeSetImages.has(mediaType)) {\n        const { videoTrack, setImage } = imageToVideoTrackConverter();\n        conn.vidoeSetImages.set(mediaType, setImage);\n        receiveTrack(mediaType, videoTrack, info);\n        // XXX currently no way to detect track stop\n        disposeList.push(() => {\n          videoTrack.dispatchEvent(new Event(\"ended\"));\n          conn.vidoeSetImages.delete(mediaType);\n        });\n      }\n      const setImage = conn.vidoeSetImages.get(mediaType);\n      try {\n        const dataURL = await decryptStringFromChunks(msg.data, cryptoKey);\n        if (setImage && dataURL) {\n          setImage(dataURL);\n        }\n      } catch (e) {\n        console.info(\"Error in parse for video media\", e);\n      }\n    };\n    myIpfs.pubsub.subscribe(topic, videoHandler);\n    disposeList.unshift(() => {\n      myIpfs.pubsub.unsubscribe(topic, videoHandler);\n    });\n  };\n\n  const acceptMediaTypes = (mTypes: readonly string[]) => {\n    if (disposed) return;\n    mediaTypeDisposeMap.forEach((disposeList, existingMediaType) => {\n      if (!mTypes.includes(existingMediaType)) {\n        disposeList.forEach((dispose) => dispose());\n        mediaTypeDisposeMap.delete(existingMediaType);\n      }\n    });\n    mTypes.forEach((mediaType) => {\n      if (mediaTypeDisposeMap.has(mediaType)) return;\n      if (mediaType.endsWith(\"Audio\")) {\n        acceptAudioMedia(mediaType);\n      } else if (mediaType.endsWith(\"Video\")) {\n        acceptVideoMedia(mediaType);\n      } else {\n        throw new Error(\"pubsubRoom: cannot guess mediaType (Audio/Video)\");\n      }\n    });\n    mediaTypes = mTypes;\n    broadcastData(null);\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Connection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setAcceptingMediaTypes(conn, payloadMediaTypes as string[]);\n    }\n  };\n\n  const handlePayloadData = (conn: Connection, data: unknown) => {\n    const info: PeerInfo = {\n      userId: conn.userId,\n      peerIndex: conn.peerIndex,\n      mediaTypes: connMap.getAcceptingMediaTypes(conn),\n    };\n    try {\n      receiveData(data, info);\n    } catch (e) {\n      console.warn(\"receiveData\", e);\n    }\n  };\n\n  const handlePayload = async (conn: Connection, payload: unknown) => {\n    try {\n      if (!isObject(payload)) return;\n\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, payload);\n    }\n  };\n\n  const initConnection = (peerId: string, payloadUserId: string) => {\n    const conn = connMap.addConn(peerId, payloadUserId);\n    notifyNewPeer(conn.peerIndex);\n    updateNetworkStatus({\n      type: \"NEW_CONNECTION\",\n      peerIndex: conn.peerIndex,\n    });\n    return conn;\n  };\n\n  const getUserIdFromPayload = (payload: unknown) => {\n    if (!isObject(payload)) return null;\n    const payloadUserId = (payload as { userId: unknown }).userId;\n    if (typeof payloadUserId !== \"string\") return null;\n    return payloadUserId;\n  };\n\n  const pubsubHandler = async (msg: Message) => {\n    if (disposed) return;\n    if (!(\"from\" in msg)) return;\n    if (msg.from.toString() === myPeerId.toString()) return;\n    const payload = await parsePayload(msg.data);\n    if (payload === undefined) return;\n    const payloadUserId = getUserIdFromPayload(payload);\n    let conn = connMap.getConn(msg.from.toString());\n    if (!conn) {\n      if (payloadUserId) {\n        conn = initConnection(msg.from.toString(), payloadUserId);\n      } else {\n        console.warn(\"cannot initialize conn without user id\");\n      }\n    }\n    if (conn) {\n      await handlePayload(conn, payload);\n    }\n    const peerIndexList = connMap.getPeerIndexList();\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const checkPeers = async () => {\n    if (disposed) return;\n    const peers = await myIpfs.pubsub.peers(roomTopic);\n    connMap.forEachConns((conn) => {\n      if (!peers.some((peer) => peer.toString() === conn.peer)) {\n        connMap.delConn(conn);\n        updateNetworkStatus({\n          type: \"CONNECTION_CLOSED\",\n          peerIndex: conn.peerIndex,\n        });\n      }\n    });\n    if (!peers.length) {\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      await sleep(1000);\n      checkPeers();\n      return;\n    }\n    if (!connMap.size()) {\n      await broadcastData(null);\n    }\n    await sleep(5000);\n    checkPeers();\n  };\n  checkPeers();\n\n  const trackDisposeMap = new WeakMap<MediaStreamTrack, () => void>();\n  const runDispose = (dispose?: () => void) => {\n    if (dispose) {\n      dispose();\n    }\n  };\n\n  const addAudioTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    runDispose(trackDisposeMap.get(track));\n    const stream = new MediaStream([track]);\n    const audioCtx = new AudioContext();\n    const trackSource = audioCtx.createMediaStreamSource(stream);\n    await audioCtx.audioWorklet.addModule(\"audio-encoder.js\");\n    const audioEncoder = new AudioWorkletNode(audioCtx, \"audio-encoder\");\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const bufList: ArrayBuffer[] = [];\n    audioEncoder.port.onmessage = async (event) => {\n      bufList.push(event.data);\n      if (bufList.length < 17) return;\n      const encrypted = await encryptBufferFromChunks(\n        bufList.splice(0, bufList.length),\n        cryptoKey\n      );\n      myIpfs.pubsub.publish(topic, new Uint8Array(encrypted), {});\n    };\n    trackSource.connect(audioEncoder);\n    trackDisposeMap.set(track, () => {\n      audioCtx.close();\n    });\n  };\n\n  const addVideoTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    runDispose(trackDisposeMap.get(track));\n    const topic = await getTopicForMediaType(roomId, mediaType);\n    const { getImage } = await videoTrackToImageConverter(track);\n    let videoDisposed = false;\n    const loop = async () => {\n      if (videoDisposed) return;\n      const dataURL = await getImage();\n      if (dataURL) {\n        for await (const encrypted of encryptStringToChunks(\n          dataURL,\n          cryptoKey\n        )) {\n          if (videoDisposed) return;\n          await myIpfs.pubsub.publish(topic, new Uint8Array(encrypted), {});\n          await sleep(1000);\n        }\n      } else {\n        await sleep(5000);\n      }\n      loop();\n    };\n    loop();\n    trackDisposeMap.set(track, () => {\n      videoDisposed = true;\n    });\n  };\n\n  const mediaTypeMap = new Map<string, MediaStreamTrack>();\n\n  const addTrack = async (mediaType: string, track: MediaStreamTrack) => {\n    if (disposed) return;\n    if (mediaTypeMap.has(mediaType)) {\n      throw new Error(`track is already added for ${mediaType}`);\n    }\n    mediaTypeMap.set(mediaType, track);\n    if (mediaType.endsWith(\"Audio\")) {\n      addAudioTrack(mediaType, track);\n    } else if (mediaType.endsWith(\"Video\")) {\n      addVideoTrack(mediaType, track);\n    } else {\n      throw new Error(\"pubsubRoom: cannot guess mediaType (Audio/Video)\");\n    }\n  };\n\n  const removeTrack = (mediaType: string) => {\n    if (disposed) return;\n    const track = mediaTypeMap.get(mediaType);\n    if (!track) {\n      console.log(\"track is already removed for\", mediaType);\n      return;\n    }\n    mediaTypeMap.delete(mediaType);\n    runDispose(trackDisposeMap.get(track));\n  };\n\n  const dispose = async () => {\n    disposed = true;\n    await myIpfs.pubsub.unsubscribe(`${roomTopic} ${myPeerId}`, pubsubHandler);\n    await myIpfs.pubsub.unsubscribe(roomTopic, pubsubHandler);\n    await myIpfs.stop();\n  };\n\n  return {\n    broadcastData,\n    sendData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n","const setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = (timeout = 1000) => {\n    if (track.readyState === \"ended\") return;\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    } else if (timeout < 64000) {\n      setTimeout(() => {\n        onmute(timeout * 2);\n      }, timeout);\n    }\n  };\n  track.addEventListener(\"mute\", () => onmute());\n  return track;\n};\n\nexport const loopbackPeerConnection = (\n  track: MediaStreamTrack\n): Promise<MediaStreamTrack> =>\n  // eslint-disable-next-line no-async-promise-executor\n  new Promise(async (resolve, reject) => {\n    try {\n      const pcIn = new RTCPeerConnection();\n      const pcOut = new RTCPeerConnection();\n      pcIn.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcOut.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"icecandidate\", ({ candidate }) => {\n        if (candidate) {\n          pcIn.addIceCandidate(candidate);\n        }\n      });\n      pcOut.addEventListener(\"track\", (event) => {\n        resolve(event.track);\n      });\n      track.addEventListener(\"ended\", () => {\n        pcIn.close();\n        pcOut.close();\n      });\n      pcIn.addTrack(track);\n      const offer = await pcIn.createOffer();\n      await pcIn.setLocalDescription(offer);\n      await pcOut.setRemoteDescription(offer);\n      const answer = await pcOut.createAnswer();\n      await pcOut.setLocalDescription(answer);\n      await pcIn.setRemoteDescription(answer);\n    } catch (e) {\n      reject(e);\n    }\n  });\n\nexport const videoTrackToImageConverter = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") {\n    throw new Error(\"track kind is not video\");\n  }\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const imageCapture = new ImageCapture(track);\n  const getImage = async () => {\n    try {\n      const bitmap = await imageCapture.grabFrame();\n      canvas.width = bitmap.width;\n      canvas.height = bitmap.height;\n      ctx.drawImage(bitmap, 0, 0);\n      return canvas.toDataURL(\"image/jpeg\");\n    } catch (e) {\n      console.log(\"failed to grab frame from viedeo track\", e);\n      return null;\n    }\n  };\n  return { getImage };\n};\n\nconst createImage = (src: string): Promise<HTMLImageElement> =>\n  new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n    img.src = src;\n  });\n\nexport const imageToVideoTrackConverter = () => {\n  const canvas = document.createElement(\"canvas\");\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const [videoTrack] = canvasStream.getVideoTracks();\n  const setImage = async (dataURL: string) => {\n    const img = await createImage(dataURL);\n    canvas.width = img.width;\n    canvas.height = img.height;\n    ctx.drawImage(img, 0, 0);\n  };\n  return { videoTrack, setImage };\n};\n"],"names":["peerIndexCounter","create","createUntyped","topicsForMediaTypes","Map","getTopicForMediaType","async","roomId","mediaType","key","topic","get","sha256","slice","ROOM_ID_PREFIX_LEN","set","createRoom","userId","updateNetworkStatus","notifyNewPeer","receiveData","receiveTrack","disposed","connMap","map","setAcceptingMediaTypes","conn","mediaTypes","value","peer","acceptingMediaTypes","getAcceptingMediaTypes","addConn","peerId","Error","peerIndex","audioWorkers","vidoeSetImages","getConn","findConn","Array","from","values","find","v","delConn","delete","getPeerIndexList","forEachConns","callback","forEach","size","createConnectionMap","roomTopic","cryptoKey","importCryptoKey","type","myIpfs","repo","secureRandomId","config","Addresses","Swarm","getWebrtcStarFromUrl","Bootstrap","myPeerId","id","pubsub","subscribe","msg","pubsubHandler","sendPayload","payload","console","log","encrypted","encryptStringToChunks","JSON","stringify","publish","Uint8Array","e","error","broadcastData","data","mediaTypeDisposeMap","handlePayload","isObject","payloadMediaTypes","isArray","every","x","handlePayloadMediaTypes","info","warn","handlePayloadData","toString","str","decryptStringFromChunks","parse","parsePayload","undefined","payloadUserId","getUserIdFromPayload","initConnection","peerIndexList","checkPeers","peers","some","length","sleep","trackDisposeMap","WeakMap","runDispose","dispose","mediaTypeMap","sendData","sendPayloadDirectly","acceptMediaTypes","mTypes","disposeList","existingMediaType","includes","has","endsWith","audioHandler","audioCtx","AudioContext","destination","createMediaStreamDestination","currTime","pending","worker","Worker","onmessage","buffer","Float32Array","currentTime","audioBuffer","createBuffer","copyToChannel","audioBufferSource","createBufferSource","connect","onended","start","audioTrack","stream","getAudioTracks","loopbackPeerConnection","push","close","dispatchEvent","Event","terminate","bufList","decryptBufferToChunks","byteOffset","byteLength","buf","postMessage","unshift","unsubscribe","acceptAudioMedia","videoHandler","videoTrack","setImage","imageToVideoTrackConverter","dataURL","acceptVideoMedia","addTrack","track","MediaStream","trackSource","createMediaStreamSource","audioWorklet","addModule","audioEncoder","AudioWorkletNode","port","event","encryptBufferFromChunks","splice","addAudioTrack","getImage","videoTrackToImageConverter","videoDisposed","loop","addVideoTrack","removeTrack","stop","setupMap","setupTrackStopOnLongMute","pc","onmute","timeout","readyState","transceiver","getTransceivers","t","receiver","currentDirection","setTimeout","addEventListener","Promise","resolve","reject","pcIn","RTCPeerConnection","pcOut","candidate","addIceCandidate","offer","createOffer","setLocalDescription","setRemoteDescription","answer","createAnswer","kind","canvas","document","createElement","ctx","getContext","imageCapture","ImageCapture","bitmap","grabFrame","width","height","drawImage","toDataURL","canvasStream","captureStream","getVideoTracks","img","src","Image","onload","onerror"],"sourceRoot":""}