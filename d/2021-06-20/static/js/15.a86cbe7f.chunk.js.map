{"version":3,"sources":["media/screen.ts","hooks/useNicknameMap.ts","components/MediaShare.tsx","hooks/useMediaShare.ts"],"names":["getScreenStream","a","constraints","video","navigator","mediaDevices","getDisplayMedia","stream","getVideoTracks","track","dispose","stop","useNicknameMap","roomId","userId","useState","nicknameMap","setNicknameMap","useEffect","map","getRoomState","ydoc","getMap","listener","prev","copied","changed","forEach","data","uid","x","isObject","info","nickname","observe","unobserve","Video","React","memo","videoRef","useRef","current","srcObject","className","ref","autoPlay","muted","MediaShare","uniqueId","videoDevices","useVideoDevices","videoDeviceId","setVideoDeviceId","mediaId","setMediaId","close","useCallback","uniqueShareId","videoType","videoStream","setVideoStream","videoStreamMap","setVideoStreamMap","cleanupFns","fn","trackMap","useSnapshot","Object","entries","readyState","getTracks","includes","MediaStream","onended","addEventListener","push","removeEventListener","roomState","addMediaType","removeMediaType","cleanup","resultOrNull","result","getVideoStream","addTrack","removeTrack","useMediaShare","displayMode","setDisplayMode","numOfVideos","values","filter","length","sqrtNumOfVideos","Math","ceil","sqrt","gridRows","displayStyle","gridTemplateColumns","gridTemplateRows","Array","fill","join","containerRef","fullscreenMode","setFullscreenMode","enterFullscreen","requestFullscreen","onfullscreenchange","document","fullscreenElement","exitFullscreen","e","type","onClick","value","onChange","target","disabled","videoDevice","deviceId","label","style","keys","mediaUserId"],"mappings":"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","file":"static/js/15.a86cbe7f.chunk.js","sourcesContent":["export const getScreenStream = async () => {\n  try {\n    const constraints = { video: true };\n    const stream = (await (navigator.mediaDevices as any).getDisplayMedia(\n      constraints\n    )) as MediaStream;\n    const [track] = stream.getVideoTracks();\n    const dispose = () => {\n      track.stop();\n    };\n    return {\n      stream,\n      dispose,\n    };\n  } catch (e) {\n    return null;\n  }\n};\n","import { useEffect, useState } from \"react\";\n\nimport { isObject } from \"../utils/types\";\nimport { getRoomState } from \"../states/roomMap\";\n\nconst hasInfoNickname = (x: unknown): x is { info: { nickname: string } } =>\n  isObject(x) &&\n  isObject((x as { info: unknown }).info) &&\n  typeof (x as { info: { nickname: unknown } }).info.nickname === \"string\";\n\ntype NicknameMap = {\n  [userId: string]: string;\n};\n\nexport const useNicknameMap = (roomId: string, userId: string) => {\n  const [nicknameMap, setNicknameMap] = useState<NicknameMap>({});\n\n  useEffect(() => {\n    const roomState = getRoomState(roomId, userId);\n    const map = roomState.ydoc.getMap(\"faceImages\");\n    const listener = () => {\n      setNicknameMap((prev) => {\n        const copied = { ...prev };\n        let changed = false;\n        map.forEach((data, uid) => {\n          if (uid === userId) return;\n          if (!hasInfoNickname(data)) return;\n          if (!copied[uid]) {\n            copied[uid] = data.info.nickname;\n            changed = true;\n          } else if (data.info.nickname !== copied[uid]) {\n            copied[uid] = data.info.nickname;\n            changed = true;\n          }\n        });\n        if (changed) {\n          return copied;\n        }\n        return prev;\n      });\n    };\n    map.observe(listener);\n    listener();\n    return () => {\n      map.unobserve(listener);\n    };\n  }, [roomId, userId]);\n\n  return nicknameMap;\n};\n","import React, { useCallback, useState, useRef, useEffect } from \"react\";\n\nimport \"./MediaShare.css\";\nimport { useMediaShare } from \"../hooks/useMediaShare\";\nimport { useVideoDevices } from \"../hooks/useAvailableDevices\";\nimport { useNicknameMap } from \"../hooks/useNicknameMap\";\n\nconst Video = React.memo<{\n  nickname: string;\n  stream: MediaStream;\n}>(({ nickname, stream }) => {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  useEffect(() => {\n    if (stream && videoRef.current) {\n      videoRef.current.srcObject = stream;\n    }\n  }, [stream]);\n  return (\n    <div className=\"MediaShare-card\">\n      <video className=\"MediaShare-video\" ref={videoRef} autoPlay muted />\n      <div className=\"MediaShare-nickname\">{nickname}</div>\n    </div>\n  );\n});\n\nexport const MediaShare = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n  uniqueId?: string;\n}>(({ roomId, userId, nickname, uniqueId }) => {\n  const videoDevices = useVideoDevices();\n  const [videoDeviceId, setVideoDeviceId] = useState<string>(\"\");\n  const [mediaId, setMediaId] = useState<{ video: string } | \"SCREEN\" | null>(\n    null\n  );\n  const close = useCallback(() => {\n    setMediaId(null);\n  }, []);\n  const { videoStream, videoStreamMap } = useMediaShare(\n    roomId,\n    userId,\n    mediaId,\n    close,\n    uniqueId\n  );\n  const nicknameMap = useNicknameMap(roomId, userId);\n  const [displayMode, setDisplayMode] = useState<\"grid\" | \"vertical\">(\"grid\");\n  const numOfVideos =\n    (videoStream ? 1 : 0) +\n    Object.values(videoStreamMap).filter((x) => x).length;\n  const sqrtNumOfVideos = Math.ceil(Math.sqrt(numOfVideos));\n  const gridRows = Math.ceil(numOfVideos / sqrtNumOfVideos);\n  const displayStyle =\n    displayMode === \"grid\"\n      ? {\n          gridTemplateColumns: `repeat(${sqrtNumOfVideos}, 1fr)`,\n          gridTemplateRows: `repeat(${gridRows}, ${100 / gridRows}%)`,\n        }\n      : {\n          gridTemplateRows: Array(numOfVideos).fill(\"100%\").join(\" \"),\n        };\n\n  const containerRef = useRef<HTMLDivElement>(null);\n  const [fullscreenMode, setFullscreenMode] = useState(false);\n  const enterFullscreen = async () => {\n    if (containerRef.current) {\n      try {\n        await containerRef.current.requestFullscreen();\n        setFullscreenMode(true);\n        containerRef.current.onfullscreenchange = () => {\n          setFullscreenMode(\n            document.fullscreenElement === containerRef.current\n          );\n        };\n      } catch (e) {\n        // ignored\n      }\n    }\n  };\n  const exitFullscreen = async () => {\n    try {\n      document.exitFullscreen();\n      setFullscreenMode(false);\n    } catch (e) {\n      // ignored\n    }\n  };\n\n  return (\n    <div className=\"MediaShare-container\" ref={containerRef}>\n      <div className=\"MediaShare-toolbar\">\n        {!fullscreenMode && (\n          <button type=\"button\" onClick={enterFullscreen}>\n            Enter Fullscreen\n          </button>\n        )}\n        {fullscreenMode && (\n          <button type=\"button\" onClick={exitFullscreen}>\n            Exit Fullscreen\n          </button>\n        )}\n        <select\n          value={displayMode}\n          onChange={(e) => setDisplayMode(e.target.value as typeof displayMode)}\n        >\n          <option value=\"grid\">Display in Grid</option>\n          <option value=\"vertical\">Display Vertically</option>\n        </select>\n        {mediaId !== null && (\n          <button type=\"button\" onClick={close}>\n            Stop sharing\n          </button>\n        )}\n        {mediaId === null && (\n          <button type=\"button\" onClick={() => setMediaId(\"SCREEN\")}>\n            Start Screen Share\n          </button>\n        )}\n        {mediaId === null && (\n          <>\n            <select\n              value={videoDeviceId}\n              onChange={(e) => setVideoDeviceId(e.target.value)}\n            >\n              <option value=\"\" disabled>\n                Select Camera to Share\n              </option>\n              {videoDevices.map((videoDevice) => (\n                <option key={videoDevice.deviceId} value={videoDevice.deviceId}>\n                  {videoDevice.label}\n                </option>\n              ))}\n            </select>\n            {videoDeviceId && (\n              <button\n                type=\"button\"\n                onClick={() => setMediaId({ video: videoDeviceId })}\n              >\n                Start Video Share\n              </button>\n            )}\n          </>\n        )}\n      </div>\n      <div className=\"MediaShare-body\" style={displayStyle}>\n        {videoStream && <Video nickname={nickname} stream={videoStream} />}\n        {Object.keys(videoStreamMap).map((mediaUserId) => {\n          const stream = videoStreamMap[mediaUserId];\n          if (!stream) return null;\n          return (\n            <Video\n              key={mediaUserId}\n              nickname={nicknameMap[mediaUserId] || \"No Name\"}\n              stream={stream}\n            />\n          );\n        })}\n      </div>\n    </div>\n  );\n});\n\nexport default MediaShare;\n","import { useEffect, useState, useRef } from \"react\";\nimport { useSnapshot } from \"valtio\";\n\nimport { getScreenStream } from \"../media/screen\";\nimport { getVideoStream } from \"../media/video\";\nimport { getRoomState } from \"../states/roomMap\";\n\nexport const useMediaShare = (\n  roomId: string,\n  userId: string,\n  mediaId: { video: string } | \"SCREEN\" | null,\n  close: () => void,\n  uniqueShareId?: string\n) => {\n  const videoType = `${uniqueShareId || \"mediaShare\"}Video`;\n  const [videoStream, setVideoStream] = useState<MediaStream | null>(null);\n  const [videoStreamMap, setVideoStreamMap] = useState<{\n    [userId: string]: MediaStream | null;\n  }>({});\n\n  type CleanupFn = () => void;\n  const cleanupFns = useRef<CleanupFn[]>([]);\n  useEffect(() => {\n    const cleanup = () => {\n      cleanupFns.current.forEach((fn) => fn());\n    };\n    return cleanup;\n  }, []);\n\n  const onTrack = ([uid, track]: [string, MediaStreamTrack]) => {\n    if (track.readyState === \"ended\") return;\n    if (videoStreamMap[uid]?.getTracks().includes(track)) return;\n    setVideoStreamMap((prev) => ({\n      ...prev,\n      [uid]: new MediaStream([track]),\n    }));\n    const onended = () => {\n      setVideoStreamMap((prev) => ({\n        ...prev,\n        [uid]: null,\n      }));\n    };\n    track.addEventListener(\"ended\", onended);\n    cleanupFns.current.push(() => {\n      track.removeEventListener(\"ended\", onended);\n    });\n  };\n\n  const trackMap = useSnapshot(getRoomState(roomId, userId).trackMap);\n  Object.entries(trackMap[videoType] || {}).forEach(onTrack);\n\n  useEffect(() => {\n    const roomState = getRoomState(roomId, userId);\n    roomState.addMediaType(videoType);\n    return () => {\n      roomState.removeMediaType(videoType);\n    };\n  }, [roomId, userId, videoType]);\n\n  useEffect(() => {\n    const roomState = getRoomState(roomId, userId);\n    let cleanup: (() => void) | null | false = null;\n    if (mediaId) {\n      (async () => {\n        let result: { stream: MediaStream; dispose: () => void };\n        if (mediaId === \"SCREEN\") {\n          const resultOrNull = await getScreenStream();\n          if (!resultOrNull) {\n            close();\n            return;\n          }\n          result = resultOrNull;\n        } else {\n          result = await getVideoStream(mediaId.video);\n        }\n        const [track] = result.stream.getVideoTracks();\n        roomState.addTrack(videoType, track);\n        setVideoStream(result.stream);\n        track.addEventListener(\"ended\", () => {\n          if (cleanup) cleanup();\n          cleanup = null;\n        });\n        const dispose = () => {\n          roomState.removeTrack(videoType);\n          result.dispose();\n          setVideoStream(null);\n          close();\n        };\n        if (cleanup === false) {\n          dispose();\n        } else {\n          cleanup = dispose;\n        }\n      })();\n    }\n    return () => {\n      if (cleanup) cleanup();\n      cleanup = false;\n    };\n  }, [roomId, userId, videoType, mediaId, close]);\n\n  return { videoStream, videoStreamMap };\n};\n"],"sourceRoot":""}