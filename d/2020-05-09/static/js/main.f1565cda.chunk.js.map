{"version":3,"sources":["../../node_modules/peerjs/dist sync","components/ErrorFallback.tsx","utils/crypto.ts","network/peerUtils.ts","utils/url.ts","utils/storage.ts","utils/sleep.ts","utils/types.ts","network/trackUtils.ts","network/room.ts","hooks/useRoom.ts","hooks/useNicknameMap.ts","media/devices.ts","hooks/useAvailableDevices.ts","media/capture.ts","hooks/useFaceImages.ts","media/video.ts","media/audio.ts","hooks/useFaceVideos.ts","components/FaceImages.tsx","hooks/useMomentaryChat.ts","utils/emoji.ts","components/MomentaryChat.tsx","media/screen.ts","hooks/useScreenShare.ts","components/ScreenShare.tsx","hooks/useVideoShare.ts","components/VideoShare.tsx","utils/excalidraw.ts","components/CollabWhiteBoard.tsx","components/UserProfile.tsx","components/SingleRoom.tsx","components/SingleRoomEntrance.tsx","components/App.tsx","serviceWorker.ts","index.tsx"],"names":["webpackEmptyContext","req","e","Error","code","keys","resolve","module","exports","id","ErrorFallback","React","memo","err","useState","waitSec","setWaitSec","useEffect","setTimeout","window","location","reload","name","message","secureRandomId","len","buf","crypto","getRandomValues","Uint8Array","arr","Array","from","hex","map","b","toString","padStart","join","rand4","Uint16Array","generateCryptoKey","a","subtle","generateKey","length","key","exportKey","importCryptoKey","usages","size","i","parseInt","slice","importKey","cryptoKey","encrypt","data","encoder","TextEncoder","iv","encode","encrypted","byteLength","set","decrypt","decrypted","decoder","TextDecoder","decode","generatePeerId","roomId","peerIndex","getPeerIndexFromPeerId","peerId","Number","split","getPeerIndexFromConn","conn","peer","extractRoomIdFromLink","link","hash","URL","URLSearchParams","get","getServerConfigFromUrl","server","url","secure","protocol","defaultPort","host","port","path","pathname","setStringItem","value","localStorage","setItem","console","info","getStringItem","getItem","sleep","ms","Promise","isObject","x","setupMap","WeakMap","setupTrackStopOnLongMute","track","pc","has","onmute","transceiver","getTransceivers","find","t","receiver","currentDirection","stop","dispatchEvent","Event","addEventListener","guessSeed","createRoom","userId","updateNetworkStatus","receiveData","receiveTrack","disposed","myPeer","lastBroadcastData","connMap","Map","addConn","close","mediaTypes","markConnected","connected","isConnected","setUserId","getUserId","setMediaTypes","getMediaTypes","hasConn","delConn","delete","getConnectedPeerIds","filter","k","forEachConnectedConns","callback","values","forEach","forEachConnsAcceptingMedia","mediaType","includes","clearAll","log","clear","createConnectionMap","localStream","showConnectedStatus","peerIndexList","type","connectPeer","connect","initConnection","broadcastData","replaceLastData","peers","sendPayload","sendSDP","sdp","SDP","handlePayloadSDP","offer","peerConnection","setRemoteDescription","syncAllTracks","createAnswer","answer","setLocalDescription","Math","random","removeAllTracks","warn","handlePayloadUserId","payloadUserId","handlePayloadMediaTypes","payloadMediaTypes","isArray","every","handlePayloadData","connUserId","handlePayload","JSON","payload","parse","startsWith","isValidPeerId","stringify","send","error","on","iceGatheringState","onicecandidate","scheduledNegotiation","createOffer","event","reInitMyPeer","disconnected","floor","initMyPeer","index","isSeed","Peer","debug","seedId","destroy","destroyed","reconnect","force","existsAllSeeds","oldPeer","trackMediaTypeMap","senders","getSenders","mTypes","getTracks","mType","sender","addTrack","removeTrack","some","transport","acceptMediaTypes","MediaStream","getReceivers","s","dispose","roomEntryMap","register","networkStatusListener","dataListener","trackListener","roomEntryKey","entry","networkStatusListeners","Set","dataListeners","trackListeners","room","status","listener","count","add","mediaTypeSet","prevSize","definedEntry","unregister","useRoomNetworkStatus","onNetworkStatus","networkStatus","ns","useBroadcastData","broadcastDataRef","useRef","useCallback","current","registered","useRoomData","onRoomData","undefined","useRoomMedia","onTrack","functions","setFunctions","result","cache","createMapFromCache","nickname","useNicknameMap","nicknameMap","setNicknameMap","findIndex","now","Date","lastUpdated","push","splice","prev","Object","getVideoDeviceInfoList","navigator","mediaDevices","enumerateDevices","devices","list","kind","label","deviceId","getAudioDeviceInfoList","useVideoDevices","setDevices","deviceInfoList","captureImage","stream","ImageCapture","imageCapture","takePhoto","blob","createImageBitmap","srcImg","grabFrame","srcW","width","srcH","height","video","document","getElementById","style","display","savedSrcObject","srcObject","revert","videoWidth","videoHeight","constraints","getUserMedia","getVideoTracks","canvas","ctx","getContext","dstW","dstH","ratio","max","min","y","drawImage","toDataURL","isImageData","image","liveMode","isFaceInfo","getVideoStream","getFaceVideoStream","loop","timer","canvasStream","captureStream","clearTimeout","checkVideTrackFaceSize","createElement","videoTrackFaceSizeMap","isVideoTrackFaceSize","promise","getAudioStream","audio","getAudioTracks","applyConstraints","echoCancellation","echoCancellationType","ideal","noiseSuppression","addTrackToStream","disposeStream","newStream","FaceImage","statusMesg","obsoleted","speakerOn","className","opacity","ref","videoEle","autoPlay","muted","src","alt","title","FaceImages","micOn","videoDeviceId","audioDeviceId","myImage","setMyImage","roomImages","setRoomImages","fatalError","setFatalError","roomImage","received","item","changed","next","checkObsoletedImage","twoMinAgo","tenMinAgo","useFaceImages","videoEnabled","audioEnabled","faceStream","setFaceStream","faceStreamMap","setFaceStreamMap","isMounted","addVideoTrack","removeVideoTrack","addAudioTrack","removeAudioTrack","videoStream","disposeVideo","videoTrack","audioStream","disposeAudio","audioTrack","enabled","useFaceVideos","compareReply","countDiff","useMomentaryChat","chatSeqRef","receivedSeqMap","chatList","setChatList","addChatItem","chatData","chatSeq","chatInReplyTo","chatText","replyTo","replyMap","replies","entries","sort","time","chatItem","text","toLocaleString","sendChat","replyChat","inReplyTo","EmojiPicker","Picker","MomentaryChatContentPart","openEmojiPicker","setOpenEmojiPicker","reply","onSelect","native","onClick","MomentaryChatContent","onUpdateLayout","chatListRef","useLayoutEffect","scrollHeight","MomentaryChat","containerRef","setText","scrollTop","onSubmit","preventDefault","onChange","target","placeholder","disabled","getScreenStream","getDisplayMedia","isScreenTrack","isFaceSize","Screen","videoRef","ScreenShare","setEnabled","screenStream","setScreenStream","screenStreamMap","setScreenStreamMap","cleanupFns","fn","onended","removeEventListener","useScreenShare","screenUserId","isVideoTrack","Video","VideoShare","videoDevices","setVideoDeviceId","setVideoStream","videoStreamMap","setVideoStreamMap","useVideoShare","numOfVideos","videoDevice","gridTemplateColumns","ceil","sqrt","generateExcalidrawURL","imported","CollabWhiteBoard","setUrl","excalidrawUrl","TextField","initialText","onUpdate","buttonLabel","clearOnUpdate","UserProfile","initialNickname","emoji","onUpdateNickname","onUpdateStatusMesg","onUpdateEmoji","initialConfigOpen","initialVideoDeviceId","initialAudioDeviceId","SingleRoom","setNickname","setStatusMesg","setEmoji","searchParams","setRoomIdToUrl","audioDevices","useAudioDevices","setAudioDeviceId","setLiveMode","setMicOn","setSpeakerOn","screenShareMode","setScreenShareMode","videoShareMode","setVideoShareMode","collabWBOpen","setCollabWBOpen","configOpen","setConfigOpen","appLink","href","replace","o","readOnly","audioDevice","checked","roomIdFromUrl","getRoomIdFromUrl","SingleRoomEntrance","setRoomId","linkText","setLinkText","onCreateNew","ROOM_ID_PREFIX_LEN","ErrorBoundary","state","children","this","props","PureComponent","App","Boolean","hostname","match","ReactDOM","render","StrictMode","serviceWorker","ready","then","registration","catch"],"mappings":"+MAAA,SAASA,EAAoBC,GAC5B,IAAIC,EAAI,IAAIC,MAAM,uBAAyBF,EAAM,KAEjD,MADAC,EAAEE,KAAO,mBACHF,EAEPF,EAAoBK,KAAO,WAAa,MAAO,IAC/CL,EAAoBM,QAAUN,EAC9BO,EAAOC,QAAUR,EACjBA,EAAoBS,GAAK,I,8QCNZC,EAAgBC,IAAMC,MAEhC,YAAc,IAAXC,EAAU,EAAVA,IAAU,EACgBC,mBAAS,IADzB,mBACPC,EADO,KACEC,EADF,KAad,OAVAC,qBAAU,WACJF,EAAU,EACZG,YAAW,WACTF,EAAWD,EAAU,KACpB,KAEHI,OAAOC,SAASC,YAKlB,6BACE,6DACCR,GACC,4BACGA,EAAIS,KADP,KACeT,EAAIU,SAGrB,kDAAwBR,EAAxB,a,uBChBOS,G,MAAiB,WAAe,IAAdC,EAAa,uDAAP,GAC7BC,EAAMP,OAAOQ,OAAOC,gBAAgB,IAAIC,WAAWJ,IACnDK,EAAMC,MAAMC,KAAKN,GACjBO,EAAMH,EAAII,KAAI,SAACC,GAAD,OAAOA,EAAEC,SAAS,IAAIC,SAAS,EAAG,QAAMC,KAAK,IACjE,OAAOL,IAGIM,EAAQ,WAEnB,OAAO,IADMpB,OAAOQ,OAAOC,gBAAgB,IAAIY,YAAY,IAAI,GACzC,KAGXC,EAAiB,uCAAG,kCAAAC,EAAA,sEACbvB,OAAOQ,OAAOgB,OAAOC,YACrC,CAAEtB,KAAM,UAAWuB,OAAQ,MAC3B,EACA,CAAC,UAAW,YAJiB,cACzBC,EADyB,gBAMb3B,OAAOQ,OAAOgB,OAAOI,UAAU,MAAOD,GANzB,cAMzBpB,EANyB,OAOzBI,EAAMC,MAAMC,KAAK,IAAIH,WAAWH,IAChCO,EAAMH,EAAII,KAAI,SAACC,GAAD,OAAOA,EAAEC,SAAS,IAAIC,SAAS,EAAG,QAAMC,KAAK,IARlC,kBASxBL,GATwB,2CAAH,qDAYjBe,EAAe,uCAAG,WAC7BF,EACAG,GAF6B,qBAAAP,EAAA,sDAM7B,IAFMQ,EAAOJ,EAAID,OAAS,EACpBnB,EAAM,IAAIG,WAAWqB,GAClBC,EAAI,EAAGA,EAAID,EAAMC,GAAK,EAC7BzB,EAAIyB,GAAKC,SAASN,EAAIO,MAAU,EAAJF,EAAW,EAAJA,EAAQ,GAAI,IAPpB,gBASLhC,OAAOQ,OAAOgB,OAAOW,UAC3C,MACA5B,EACA,CAAEJ,KAAM,UAAWuB,OAAQ,MAC3B,EACAI,GAd2B,cASvBM,EATuB,yBAgBtBA,GAhBsB,2CAAH,wDAmBfC,EAAO,uCAAG,WAAOC,EAAcX,GAArB,uBAAAJ,EAAA,6DACfgB,EAAU,IAAIC,YADC,SAEGX,EAAgBF,EAAK,CAAC,YAFzB,cAEfS,EAFe,OAGfK,EAAKzC,OAAOQ,OAAOC,gBAAgB,IAAIC,WAAW,KAHnC,SAIGV,OAAOQ,OAAOgB,OAAOa,QAC3C,CAAElC,KAAM,UAAWsC,MACnBL,EACAG,EAAQG,OAAOJ,IAPI,cAIfK,EAJe,QASfpC,EAAM,IAAIG,WAAW+B,EAAGf,OAASiB,EAAUC,aAC7CC,IAAIJ,GACRlC,EAAIsC,IAAI,IAAInC,WAAWiC,GAAYF,EAAGf,QAXjB,kBAYdnB,GAZc,4CAAH,wDAePuC,EAAO,uCAAG,WAAOvC,EAAkBoB,GAAzB,qBAAAJ,EAAA,sEACGM,EAAgBF,EAAK,CAAC,YADzB,cACfS,EADe,gBAEGpC,OAAOQ,OAAOgB,OAAOsB,QAC3C,CAAE3C,KAAM,UAAWsC,GAAIlC,EAAI2B,MAAM,EAAG,KACpCE,EACA7B,EAAI2B,MAAM,KALS,cAEfa,EAFe,OAOfC,EAAU,IAAIC,YAAY,SAC1BX,EAAOU,EAAQE,OAAO,IAAIxC,WAAWqC,IARtB,kBASdT,GATc,2CAAH,wDCxDPa,EAAiB,SAACC,EAAgBC,GAAjB,gBACzBD,EAAOlB,MAAM,EAVgB,IASJ,YACcmB,IAE/BC,EAAyB,SAACC,GAAD,OACpCC,OAAOD,EAAOE,MAAM,KAAK,KAEdC,EAAuB,SAACC,GAAD,OAClCL,EAAuBK,EAAKC,OClBjBC,EAAwB,SAACC,GACpC,IACE,IAAMC,EAAO,IAAIC,IAAIF,GAAMC,KAAK7B,MAAM,GAEtC,OADqB,IAAI+B,gBAAgBF,GACrBG,IAAI,UACxB,MAAOnF,GACP,OAAO,OAiBEoF,EAAyB,WACpC,IAAMJ,EAAO/D,OAAOC,SAAS8D,KAAK7B,MAAM,GAElCkC,EADe,IAAIH,gBAAgBF,GACbG,IAAI,UAChC,IACE,IAAMG,EAAM,IAAIL,IAAII,GAAU,IACxBE,EAA0B,WAAjBD,EAAIE,SACbC,EAAcF,EAAS,IAAM,GACnC,MAAO,CACLG,KAAMJ,EAAII,KAAKhB,MAAM,KAAK,GAC1BiB,KAAML,EAAIK,KAAOlB,OAAOa,EAAIK,MAAQF,EACpCG,KAAMN,EAAIO,SACVN,UAEF,MAAOvF,IAGT,OAAO,MChCI8F,G,MAAgB,SAAC1E,EAAsB2E,GAClD,IACE9E,OAAO+E,aAAaC,QAAQ7E,EAAM2E,GAClC,MAAO/F,GACPkG,QAAQC,KAAK,wCAAyCnG,MAI7CoG,EAAgB,SAAChF,GAC5B,IACE,OAAOH,OAAO+E,aAAaK,QAAQjF,IAAS,GAC5C,MAAOpB,GAEP,MAAO,K,yBCrBEsG,EAAQ,SAACC,GAAD,OACnB,IAAIC,SAAQ,SAACpG,GAAD,OAAaY,WAAWZ,EAASmG,OCDlCE,EAAW,SAACC,GAAD,MACT,kBAANA,GAAwB,OAANA,GCCrBC,EAAW,IAAIC,QAIRC,EAA2B,SACtCC,EACAC,GAEA,GAAIJ,EAASK,IAAIF,GACf,OAAOA,EAETH,EAAS7C,IAAIgD,GAAO,GACpB,IAAMG,EAAM,uCAAG,4BAAAzE,EAAA,sEACP8D,EAAM,KADC,SAEPY,EAAcH,EACjBI,kBACAC,MAAK,SAACC,GAAD,OAAOA,EAAEC,SAASR,QAAUA,OAGA,aAAjCI,EAAYK,kBACsB,aAAjCL,EAAYK,mBAEdT,EAAMU,OAENV,EAAMW,cAAc,IAAIC,MAAM,WAZnB,2CAAH,qDAgBZ,OADAZ,EAAMa,iBAAiB,OAAQV,GACxBH,GCZHc,EAAY,SAACrH,GACjB,IAAM+D,EAAYC,EAAuBhE,GACzC,OAJ0B,IAII+D,GAAaA,GAHjB,IA0BfuD,EAAa,SACxBxD,EACAyD,EACAC,EACAC,EACAC,GAEA,IAAIC,GAAW,EACXC,EAAsB,KACtBC,EAAoC,KAClCC,ENjC2B,WAOjC,IAAMrG,EAAM,IAAIsG,IA0FhB,MAAO,CACLC,QAzFc,SAAC3D,GACf,IAAMmB,EAAQ/D,EAAImD,IAAIP,EAAKC,MACvBkB,GACFA,EAAMnB,KAAK4D,QAEbxG,EAAI8B,IAAIc,EAAKC,KAAM,CAAED,OAAM6D,WAAY,MAqFvCC,cAlFoB,SAAC9D,GACrB,IAAMmB,EAAQ/D,EAAImD,IAAIP,EAAKC,MACvBkB,IACFA,EAAM4C,WAAY,IAgFpBC,YA5EkB,SAACpE,GACnB,IAAMuB,EAAQ/D,EAAImD,IAAIX,GACtB,OAAQuB,GAASA,EAAM4C,YAAc,GA2ErCE,UAxEgB,SAACjE,EAA2BkD,GAC5C,IAAM/B,EAAQ/D,EAAImD,IAAIP,EAAKC,MACvBkB,IACFA,EAAM+B,OAASA,IAsEjBgB,UAlEgB,SAAClE,GACjB,IAAMmB,EAAQ/D,EAAImD,IAAIP,EAAKC,MAC3B,OAAOkB,GAASA,EAAM+B,QAiEtBiB,cA9DoB,SAACnE,EAA2B6D,GAChD,IAAM1C,EAAQ/D,EAAImD,IAAIP,EAAKC,MACvBkB,IACFA,EAAM0C,WAAaA,IA4DrBO,cAxDoB,SAACpE,GACrB,IAAMmB,EAAQ/D,EAAImD,IAAIP,EAAKC,MAC3B,OAAQkB,GAASA,EAAM0C,YAAe,IAuDtCQ,QApDc,SAACzE,GAAD,OAAoBxC,EAAIgF,IAAIxC,IAqD1C0E,QAnDc,SAACtE,GACf,IAAMmB,EAAQ/D,EAAImD,IAAIP,EAAKC,MACvBkB,GAASA,EAAMnB,OAASA,GAC1B5C,EAAImH,OAAOvE,EAAKC,OAiDlBuE,oBA7C0B,kBAC1BvH,MAAMC,KAAKE,EAAI7B,QAAQkJ,QAAO,SAACC,GAAD,uBAAOtH,EAAImD,IAAImE,UAAf,aAAO,EAAYX,cA6CjDY,sBA3C4B,SAC5BC,GAEA3H,MAAMC,KAAKE,EAAIyH,UAAUC,SAAQ,SAAC3D,GAC5BA,EAAM4C,WACRa,EAASzD,EAAMnB,UAuCnB+E,2BAlCiC,SACjCC,EACAJ,GAEA3H,MAAMC,KAAKE,EAAIyH,UAAUC,SAAQ,SAAC3D,GAE9BA,EAAM4C,WACN5C,EAAM0C,YACN1C,EAAM0C,WAAWoB,SAASD,IAE1BJ,EAASzD,EAAMnB,UAyBnBkF,SApBe,WACX9H,EAAIgB,MACNkD,QAAQ6D,IAAI,yBAA0B/H,GAExCA,EAAIgI,UM7DUC,GACZxB,EAAuB,GACvByB,EAAkC,KAEhCC,EAAsB,WAC1B,IAAIjC,EAAJ,CACA,IAAMkC,EAAgB/B,EACnBe,sBACApH,IAAIuC,GACPwD,EAAoB,CAAEsC,KAAM,kBAAmBD,oBAG3CE,EAAc,SAAC/J,GACnB,IAAI2H,GACCC,GAAUA,EAAO5H,KAAOA,IACzB8H,EAAQY,QAAQ1I,GAApB,CACA2F,QAAQ6D,IAAI,cAAexJ,GAC3B,IAAMqE,EAAOuD,EAAOoC,QAAQhK,GAC5BiK,EAAe5F,KAGX6F,EAAgB,SAAClH,EAAemH,GACpC,IAAIxC,EAAJ,CACIwC,IACFtC,EAAoB7E,GAEtB,IAAMoH,EAAQtC,EAAQe,sBACtBf,EAAQkB,uBAAsB,SAAC3E,GAC7BgG,EAAYhG,EAAM,CAAEkD,SAAQvE,OAAMoH,QAAOlC,oBAIvCoC,EAAU,SAACjG,EAA2BkG,GAC1CF,EAAYhG,EAAM,CAAEmG,IAAKD,KAGrBE,EAAgB,uCAAG,WAAOpG,EAA2BkG,GAAlC,mBAAAtI,EAAA,yDAClBiE,EAASqE,GADS,qDAEnBrE,EAAUqE,EAA2BG,OAFlB,wBAGbA,EAAUH,EAAVG,MAHa,kBAKbrG,EAAKsG,eAAeC,qBAAqBF,GAL5B,cAMnBG,EAAcxG,GANK,UAOEA,EAAKsG,eAAeG,eAPtB,eAObC,EAPa,iBAQb1G,EAAKsG,eAAeK,oBAAoBD,GAR3B,QASnBT,EAAQjG,EAAM,CAAE0G,WATG,kDAWnBpF,QAAQC,KAAK,yBAAb,MAXmB,oCAaZM,EAAUqE,EAA4BQ,QAb1B,wBAcbA,EAAWR,EAAXQ,OAda,oBAgBb1G,EAAKsG,eAAeC,qBAAqBG,GAhB5B,kEAkBnBpF,QAAQC,KAAK,0BAAb,MAlBmB,UAmBbG,EAAsB,GAAhBkF,KAAKC,SAAgB,KAnBd,QAoBnBC,EAAgB9G,GAChBwG,EAAcxG,GArBK,gCAwBrBsB,QAAQyF,KAAK,cAAeb,GAxBP,kEAAH,wDA4BhBc,EAAsB,SAC1BhH,EACAiH,GAE6B,kBAAlBA,GACTxD,EAAQQ,UAAUjE,EAAMiH,IAItBC,EAAuB,uCAAG,WAC9BlH,EACAmH,GAF8B,SAAAvJ,EAAA,0DAK5BX,MAAMmK,QAAQD,KACdA,EAAkBE,OAAM,SAACvF,GAAD,MAAoB,kBAANA,KANV,uBAQ5B2B,EAAQU,cAAcnE,EAAMmH,GARA,SAStBzF,EAAM,KATgB,OAU5B8E,EAAcxG,GAVc,2CAAH,wDAwBvBsH,EAAoB,SAACtH,EAA2BrB,GACpD,IAAM4I,EAAa9D,EAAQS,UAAUlE,GACrC,GAAIuH,EAAY,CACd,IAAMhG,EAAiB,CACrB2B,OAAQqE,EACR7H,UAAWK,EAAqBC,GAChC6D,WAAYJ,EAAQW,cAAcpE,IAEpC,IACEoD,EAAYzE,EAAM4C,GAClB,MAAOnG,GACPkG,QAAQyF,KAAK,cAAe3L,MAK5BoM,EAAa,uCAAG,WACpBxH,EACAhB,GAFoB,eAAApB,EAAA,0DAIhB0F,EAJgB,sEAMFmE,KANE,SAOVtI,EAAQH,EAAWS,EAAOlB,MN3KN,KMoKV,sBAMZmJ,EANY,KAMGC,MANH,gBASlBrG,QAAQ6D,IAAI,oBAAqBnF,EAAKC,KAAMyH,GACvC7F,EAAS6F,GAVI,mDAYlBtB,EAAiBpG,EAAO0H,EAA8BvB,KACtDa,EAAoBhH,EAAO0H,EAAiCxE,QAC5DgE,EACElH,EACC0H,EAAqC7D,YA1ChBkC,EA4CJ2B,EAAgC3B,MA3ClD9I,MAAMmK,QAAQrB,IAChBA,EAAMjB,SAAQ,SAAC7E,IN1IQ,SAC3BR,EACAG,GAF2B,MAIT,kBAAXA,GACPA,EAAOgI,WAAP,UAAqBnI,EAAOlB,MAAM,EAPF,IAOhC,OMsIUsJ,CAAcpI,EAAQQ,IACxByF,EAAYzF,MAyChBqH,EAAkBtH,EAAO0H,EAA+B/I,MAnBtC,kDAqBlB2C,QAAQC,KAAK,yBAAb,KAA0CvC,GArBxB,kCA1BK,IAAC+G,IA0BN,qBAAH,wDAyBbC,EAAW,uCAAG,WAAOhG,EAA2B0H,GAAlC,eAAA9J,EAAA,+EAEQc,EACtB+I,KAAKK,UAAUJ,GACfjI,EAAOlB,MNjMmB,KM6LZ,OAEVS,EAFU,OAMhBgB,EAAK+H,KAAK/I,GANM,gDAQhBsC,QAAQ0G,MAAM,cAAd,MARgB,yDAAH,wDAYXpC,EAAiB,SAAC5F,GACtB,GAAIyD,EAAQO,YAAYhE,EAAKC,MAC3BD,EAAK4D,YADP,CAIAH,EAAQE,QAAQ3D,GAChBA,EAAKiI,GAAG,QAAQ,WAId,GAHAxE,EAAQK,cAAc9D,GACtBsB,QAAQ6D,IAAI,sBAAuBnF,GACnCuF,IACI/B,EAAmB,CACrB,IAAM7E,EAAO6E,EACPuC,EAAQtC,EAAQe,sBACtBwB,EAAYhG,EAAM,CAAEkD,SAAQvE,OAAMoH,QAAOlC,mBAG7C7D,EAAKiI,GAAG,QAAQ,SAACrL,GAAD,OAAsB4K,EAAcxH,EAAMpD,MAC1DoD,EAAKsG,eAAevD,iBAAiB,2BAA2B,WAC9D,IAAMZ,EAAKnC,EAAKsG,eACa,aAAzBnE,EAAG+F,oBACL/F,EAAGgG,eAAiB,iBAGxB,IAAMC,EAAuB,IAAIpG,QACjChC,EAAKsG,eAAevD,iBAAiB,oBAArC,sBAA0D,4BAAAnF,EAAA,0DACpDwK,EAAqBhG,IAAIpC,GAD2B,wDAExDoI,EAAqBlJ,IAAIc,GAAM,GAFyB,SAGlD0B,EAAM,KAH4C,UAIxD0G,EAAqB7D,OAAOvE,GACvByD,EAAQO,YAAYhE,EAAKC,MAL0B,kEAMpCD,EAAKsG,eAAe+B,cANgB,eAMlDhC,EANkD,iBAOlDrG,EAAKsG,eAAeK,oBAAoBN,GAPU,QAQxDJ,EAAQjG,EAAM,CAAEqG,UARwC,6CAU1DrG,EAAKsG,eAAevD,iBAAiB,SAAS,SAACuF,GAC7C,IAAMf,EAAa9D,EAAQS,UAAUlE,GACrC,GAAIuH,EAAY,CACd,IAAMhG,EAAiB,CACrB2B,OAAQqE,EACR7H,UAAWC,EAAuBK,EAAKC,MACvC4D,WAAYJ,EAAQW,cAAcpE,IAEpCqD,EACEpB,EAAyBqG,EAAMpG,MAAOlC,EAAKsG,gBAC3C/E,OAINvB,EAAKiI,GAAG,SAAS,WAQf,GAPAxE,EAAQa,QAAQtE,GAChBsB,QAAQ6D,IAAI,wBAAyBnF,GACrCmD,EAAoB,CAClBsC,KAAM,oBACN/F,UAAWK,EAAqBC,KAElCuF,IAC6C,IAAzC9B,EAAQe,sBAAsBzG,OAChCwK,GAAa,QACR,GACLvF,EAAUhD,EAAKC,OACfsD,IACCA,EAAOiF,eACPxF,EAAUO,EAAO5H,IAClB,CACA,IAAMM,EAAU,GAAK2K,KAAK6B,MAAsB,GAAhB7B,KAAKC,UACrCvF,QAAQ6D,IAAR,kCAC6BxF,EACzBK,EAAKC,MAFT,uBAGkBhE,EAHlB,WAKAG,WAAWmM,EAAwB,IAAVtM,SAKzByM,EAAa,SAAbA,IAA+C,IAAjCC,EAAgC,uDAtQ1B,GAuQxB,IAAIrF,IACAC,EAAJ,CACAE,EAAQyB,WACR,IAAM0D,EA1QkB,IA0QcD,GAASA,GAzQvB,GA0QlBjJ,EAAYkJ,EAASD,EAAQlL,IACnC0F,EAAoB,CAAEsC,KAAM,oBAAqB/F,cACjD,IAAM/D,EAAK6D,EAAeC,EAAQC,GAClC4B,QAAQ6D,IAAI,mBAAoBwD,EAAOhN,GACvC,IAAMsE,EAAO,IAAI4I,IAAKlN,EAAT,eACP6E,KAA4B,GADrB,CAEXsI,MAAO,KAETvF,EAAStD,EACTA,EAAKgI,GAAG,QAAQ,WACd1E,EAAStD,EAITkD,EAAoB,CAAEsC,KAAM,0BAC5B,IAAK,IAAIpH,EA1Ra,GA0RYA,GAzRZ,GAyRsCA,GAAK,EAAG,CAClE,IAAM0K,EAASvJ,EAAeC,EAAQpB,GACtCqH,EAAYqD,OAGhB9I,EAAKgI,GAAG,SAAS,SAAClM,GACC,mBAAbA,EAAI0J,MACNlC,EAAS,KACTtD,EAAK+I,UACLN,EAAWC,EAAQ,IACG,qBAAb5M,EAAI0J,OAES,iBAAb1J,EAAI0J,MACbnE,QAAQ6D,IAAI,gCAAiCwD,EAAO5M,GACpDkE,EAAK+I,WACiB,YAAbjN,EAAI0J,KACbnE,QAAQ6D,IAAI,2BAA4BwD,EAAO5M,GACzB,iBAAbA,EAAI0J,MACbnE,QAAQ6D,IAAI,0BAA2BwD,EAAO5M,GAC9CoH,EAAoB,CAAEsC,KAAM,mBAE5BnE,QAAQ0G,MAAM,2BAA4BW,EAAO5M,EAAI0J,KAAM1J,GAC3DoH,EAAoB,CAAEsC,KAAM,gBAAiB1J,aAGjDkE,EAAKgI,GAAG,cAAc,SAACjI,GACjBuD,IAAWtD,GAIfqB,QAAQ6D,IAAI,0BAA2BnF,GACvCmD,EAAoB,CAClBsC,KAAM,iBACN/F,UAAWK,EAAqBC,KAElC4F,EAAe5F,IARbA,EAAK4D,WAUT3D,EAAKgI,GAAG,gBAAgB,WACtB3G,QAAQ6D,IAAI,0BAA2BwD,GACvCvM,YAAW,WACLmH,IAAWtD,GAASA,EAAKgJ,YAC3B3H,QAAQ6D,IAAI,0BAA2BwD,GACvCxF,EAAoB,CAAEsC,KAAM,iBAC5BxF,EAAKiJ,eAEN,QAELjJ,EAAKgI,GAAG,SAAS,WACX1E,IAAWtD,GACbqB,QAAQ6D,IAAI,qCAAsCwD,GAClDpF,EAAS,KACTnH,WAAWsM,EAAY,MAEvBpH,QAAQ6D,IAAI,8BAA+BwD,QAIjDD,IAEA,IAAMH,EAAe,SAACY,GACpB,GAAK5F,IACDA,EAAOiF,aAAX,CACA,IAAKW,EAAO,CACV,GAAInG,EAAUO,EAAO5H,IAAK,OAE1B,IADA,IAAIyN,GAAiB,EACZ/K,EA3Va,GA2VYA,GA1VZ,GA0VsCA,GAAK,EAAG,CAClE,IAAM1C,EAAK6D,EAAeC,EAAQpB,GAClC,IAAKoF,EAAQO,YAAYrI,GAAK,CAC5ByN,GAAiB,EACjB,OAGJ,GAAIA,EAEF,YADA7D,IAIJ,IAAM8D,EAAU9F,EAChBA,EAAS,KACT8F,EAAQL,UACRN,MA+BIY,EAAoB,IAAItH,QAiCxBwE,EAAgB,SAACxG,GACrB,IAAMuJ,EAAUvJ,EAAKsG,eAAekD,aAC9BC,EAAShG,EAAQW,cAAcpE,GACjCsF,GACFA,EAAYoE,YAAY5E,SAAQ,SAAC5C,GAC/B,IAAMyH,EAAQL,EAAkB/I,IAAI2B,GAElCoD,GACAqE,GACAF,EAAOxE,SAAS0E,IAChBJ,EAAQlC,OAAM,SAACuC,GAAD,OAAYA,EAAO1H,QAAUA,MAE3ClC,EAAKsG,eAAeuD,SAAS3H,EAAOoD,MAI1CiE,EAAQzE,SAAQ,SAAC8E,GACf,GAAIA,EAAO1H,MAAO,CAChB,IAAMyH,EAAQL,EAAkB/I,IAAIqJ,EAAO1H,OACtCyH,GAAUF,EAAOxE,SAAS0E,IAC7B3J,EAAKsG,eAAewD,YAAYF,OAIlCL,EAAQQ,MAAK,SAACH,GAAD,OAAYA,EAAO1H,QAAU0H,EAAOI,cACnDhK,EAAKsG,eAAezD,cAAc,IAAIC,MAAM,uBAI1CgE,EAAkB,SAAC9G,GACPA,EAAKsG,eAAekD,aAC5B1E,SAAQ,SAAC8E,GACXA,EAAO1H,OACTlC,EAAKsG,eAAewD,YAAYF,OAYtC,MAAO,CACL/D,gBACAoE,iBA5GuB,SAACR,IACxB5F,EAAa4F,GACE1L,OACRuH,IACHA,EAAc,IAAI4E,YAClBzG,EAAQkB,uBAAsB,SAAC3E,GAC7B,IAAMuH,EAAa9D,EAAQS,UAAUlE,GACrC,GAAIuH,EAAY,CACd,IAAMhG,EAAiB,CACrB2B,OAAQqE,EACR7H,UAAWC,EAAuBK,EAAKC,MACvC4D,WAAYJ,EAAQW,cAAcpE,IAEpCA,EAAKsG,eAAe6D,eAAerF,SAAQ,SAACpC,GAC1CW,EACEpB,EAAyBS,EAASR,MAAOlC,EAAKsG,gBAC9C/E,WAOV+D,EAAc,KAEhBO,EAAc,OAoFdgE,SA/Ee,SAAC7E,EAAmB9C,GAC9BoD,IACLgE,EAAkBpK,IAAIgD,EAAO8C,GAC7BM,EAAYuE,SAAS3H,GACrBuB,EAAQsB,2BAA2BC,GAAW,SAAChF,GAC7C,IACE,IAAKsF,EAAa,OAClBtF,EAAKsG,eAAeuD,SAAS3H,EAAOoD,GACpC,MAAOlK,GACP,GAAe,uBAAXA,EAAEoB,KAGJ,MAAMpB,QAoEZ0O,YA9DkB,SAAC9E,EAAmB9C,GAClCoD,GACFA,EAAYwE,YAAY5H,GAE1BuB,EAAQsB,2BAA2BC,GAAW,SAAChF,GAC7C,IACM4J,EADU5J,EAAKsG,eAAekD,aACbhH,MAAK,SAAC4H,GAAD,OAAOA,EAAElI,QAAUA,KAC3C0H,GACF5J,EAAKsG,eAAewD,YAAYF,OAuDpCS,QAZc,WACd/G,GAAW,EACPC,GACFA,EAAOyF,aCldPsB,EAAe,IAAI5G,IACnB6G,EAAW,SACf9K,EACAyD,EACAsH,EACAC,EACAC,GAEA,IAAMC,EAAY,UAAMlL,EAAN,YAAgByD,GAC9B0H,EAAQN,EAAa/J,IAAIoK,GAC7B,IAAKC,EAAO,CACV,IAAMC,EAAyB,IAAIC,IAC7BC,EAAgB,IAAID,IACpBE,EAAiB,IAAIF,IAuB3BF,EAAQ,CACNK,KARWhI,EACXxD,EACAyD,GAjB0B,SAACgI,GAC3BL,EAAuB/F,SAAQ,SAACqG,GAC9BA,EAASD,SAGO,SAACvM,EAAe4C,GAClCwJ,EAAcjG,SAAQ,SAACqG,GACrBA,EAASxM,EAAM4C,SAGE,SAACW,EAAyBX,GAC7CyJ,EAAelG,SAAQ,aACrBqG,EADuC,EAAfA,UACfjJ,EAAOX,SAYlBsJ,yBACAE,gBACAC,iBACAI,MAAO,GAETd,EAAapL,IAAIyL,EAAcC,GAQjC,GANIJ,GACFI,EAAMC,uBAAuBQ,IAAIb,GAE/BC,GACFG,EAAMG,cAAcM,IAAIZ,GAEtBC,EAAe,CACjB,IAAMY,EAAe,IAAIR,IACvB7N,MAAMC,KAAK0N,EAAMI,gBAAgB5N,KAAI,SAAC0E,GAAD,OAAOA,EAAEkD,cAE1CuG,EAAWD,EAAalN,KAC9BwM,EAAMI,eAAeK,IAAIX,GACzBY,EAAaD,IAAIX,EAAc1F,WAC3BuG,IAAaD,EAAalN,MAC5BwM,EAAMK,KAAKhB,iBAAiBhN,MAAMC,KAAKoO,IAG3CV,EAAMQ,OAAS,EACf,IAAMI,EAAeZ,EA2BrB,MAAO,CACL/E,cAAe+E,EAAMK,KAAKpF,cAC1BgE,SAAUe,EAAMK,KAAKpB,SACrBC,YAAac,EAAMK,KAAKnB,YACxB2B,WA9BiB,WAOjB,GANIjB,GACFgB,EAAaX,uBAAuBtG,OAAOiG,GAEzCC,GACFe,EAAaT,cAAcxG,OAAOkG,GAEhCC,EAAe,CACjB,IAAIY,EAAe,IAAIR,IACrB7N,MAAMC,KAAKsO,EAAaR,gBAAgB5N,KAAI,SAAC0E,GAAD,OAAOA,EAAEkD,cAEjDuG,EAAWD,EAAalN,KAC9BoN,EAAaR,eAAezG,OAAOmG,GAI/Ba,KAHJD,EAAe,IAAIR,IACjB7N,MAAMC,KAAKsO,EAAaR,gBAAgB5N,KAAI,SAAC0E,GAAD,OAAOA,EAAEkD,eAEzB5G,MAC5BoN,EAAaP,KAAKhB,iBAAiBhN,MAAMC,KAAKoO,IAGlDE,EAAaJ,OAAS,EAClBI,EAAaJ,OAAS,IACxBI,EAAaP,KAAKZ,UAClBC,EAAa/F,OAAOoG,OAWbe,EAAuB,SAClCjM,EACAyD,EACAyI,GACI,IAAD,EAC0C3P,qBAD1C,mBACI4P,EADJ,KACmBzI,EADnB,KAEH,GAAIyI,GAAwC,kBAAvBA,EAAcnG,KACjC,MAAM,IAAIpK,MAAJ,yBAA4BuQ,EAAc7P,IAAIU,UAStD,OAPAN,qBAAU,WAKR,OAJuBoO,EAAS9K,EAAQyD,GAAQ,SAAC2I,GAC/C1I,EAAoB0I,GAChBF,GAAiBA,EAAgBE,MAF/BJ,aAKP,CAAChM,EAAQyD,EAAQyI,IACbC,GAKIE,EAAmB,SAACrM,EAAgByD,GAC/C,IAAM6I,EAAmBC,mBACnBnG,EAAgBoG,uBAAY,WAC5BF,EAAiBG,SACnBH,EAAiBG,QAAjB,MAAAH,EAAgB,aAIjB,IAMH,OALA5P,qBAAU,WACR,IAAMgQ,EAAa5B,EAAS9K,EAAQyD,GAEpC,OADA6I,EAAiBG,QAAUC,EAAWtG,cAC/BsG,EAAWV,aACjB,CAAChM,EAAQyD,IACL2C,GAGIuG,EAAc,SACzB3M,EACAyD,EACAmJ,GAEAlQ,qBAAU,WAER,OADuBoO,EAAS9K,EAAQyD,OAAQoJ,EAAWD,GAAnDZ,aAEP,CAAChM,EAAQyD,EAAQmJ,KAGTE,EAAe,SAC1B9M,EACAyD,EACAsJ,EACAxH,GACI,IAAD,EAC+BhJ,mBAG/B,IAJA,mBACIyQ,EADJ,KACeC,EADf,KAwBH,OAnBAvQ,qBAAU,WACR,GAAI6I,EAAW,CACb,IAAM2H,EAASpC,EAAS9K,EAAQyD,OAAQoJ,OAAWA,EAAW,CAC5DtH,YACAmG,SAAUqB,IAQZ,OANAE,EAAa,CACX7C,SAAU,SAAC3H,GAAD,OACRyK,EAAO9C,SAAS7E,EAAW9C,IAC7B4H,YAAa,SAAC5H,GAAD,OACXyK,EAAO7C,YAAY9E,EAAW9C,MAE3B,WACLwK,EAAa,IACbC,EAAOlB,iBAIV,CAAChM,EAAQyD,EAAQsJ,EAASxH,IACtByH,GCtLHG,EAAiB,GAGjBC,EAAqB,SAACpN,GAC1B,IAAMrC,EAAoC,GAM1C,OALAwP,EAAM9H,SAAQ,SAAC8F,GACTA,EAAMnL,SAAWA,IACnBrC,EAAIwN,EAAM1H,QAAU0H,EAAMkC,aAGvB1P,GAQI2P,EAAiB,SAACtN,EAAgByD,GAAoB,IAAD,EAC1BlH,oBAEnC,kBAAM6Q,EAAmBpN,MAHoC,mBACzDuN,EADyD,KAC5CC,EAD4C,KA+ChE,OA3CAb,EACE3M,EACAyD,EACA+I,uBACE,SAACtN,EAAM4C,GACL,GAbNM,EADuBC,EAcInD,IAZ3BkD,EAAUC,EAAwBP,OAC8B,kBAAxDO,EAAsCP,KAAKuL,SAW7C,CAdgB,IAAChL,EAeX6G,EAAQiE,EAAMM,WAClB,SAACtC,GAAD,OAAWA,EAAMnL,SAAWA,GAAUmL,EAAM1H,SAAW3B,EAAK2B,UAExDiK,EAAMC,KAAKD,MACbxE,GAAS,GACPiE,EAAMjE,GAAOmE,WAAanO,EAAK4C,KAAKuL,WACtCF,EAAMjE,GAAOmE,SAAWnO,EAAK4C,KAAKuL,UAEpCF,EAAMjE,GAAO0E,YAAcF,GAE3BP,EAAMU,KAAK,CACT7N,SACAyD,OAAQ3B,EAAK2B,OACb4J,SAAUnO,EAAK4C,KAAKuL,SACpBO,YAAaF,IAGjB,IAAK,IAAI9O,EAAIuO,EAAM7O,OAAS,EAAGM,GAAK,EAAGA,GAAK,EACtCuO,EAAMvO,GAAGgP,YA7CX,IA6C+BF,GAC/BP,EAAMW,OAAOlP,EAAG,GAGpB4O,GAAe,SAACO,GACd,IAAMpQ,EAAMyP,EAAmBpN,GACzBlE,EAAOkS,OAAOlS,KAAK6B,GACzB,OACE7B,EAAKwC,SAAW0P,OAAOlS,KAAKiS,GAAMzP,QAClCxC,EAAK8L,OAAM,SAACrJ,GAAD,OAASZ,EAAIY,KAASwP,EAAKxP,MAE/BwP,EAEFpQ,QAGX,CAACqC,KAGEuN,GCvEIU,EAAsB,uCAAG,8BAAA9P,EAAA,+EAEZ+P,UAAUC,aAAaC,mBAFX,cAE5BC,EAF4B,OAG5BC,EAAqBD,EACxBrJ,QAAO,kBAAuB,eAAvB,EAAGuJ,QACV5Q,KAAI,kBAA0B,CAAE6Q,MAA5B,EAAGA,MAAgCC,SAAnC,EAAUA,aALiB,kBAM3BH,GAN2B,yDAS3B,IAT2B,yDAAH,qDAatBI,EAAsB,uCAAG,8BAAAvQ,EAAA,+EAEZ+P,UAAUC,aAAaC,mBAFX,cAE5BC,EAF4B,OAG5BC,EAAqBD,EACxBrJ,QAAO,kBAAuB,eAAvB,EAAGuJ,QACV5Q,KAAI,kBAA0B,CAAE6Q,MAA5B,EAAGA,MAAgCC,SAAnC,EAAUA,aALiB,kBAM3BH,GAN2B,yDAS3B,IAT2B,yDAAH,qDCLtBK,EAAkB,WAAO,IAAD,EACLpS,mBAA8B,IADzB,mBAC5B8R,EAD4B,KACnBO,EADmB,KAQnC,OANAlS,qBAAU,WACR,sBAAC,4BAAAyB,EAAA,sEAC8B8P,IAD9B,OACOY,EADP,OAECD,EAAWC,GAFZ,0CAAD,KAIC,IACIR,G,gBCnBHS,EAAY,uCAAG,WAAOC,EAAqBtM,GAA5B,mCAAAtE,EAAA,yDACS,qBAAjB6Q,aADQ,wBAEXC,EAAe,IAAID,aAAavM,GAFrB,SAGXR,EAAM,KAHK,gCAMIgN,EAAaC,YANjB,cAMTC,EANS,iBAOAC,kBAAkBD,GAPlB,QAOfE,EAPe,0EASAJ,EAAaK,YATb,QASfD,EATe,sBAWXE,EAAOF,EAAOG,MACdC,EAAOJ,EAAOK,OAZH,kBAaV,CAAEL,SAAQE,OAAME,SAbN,eAebE,EAAQC,SAASC,eAAe,mBAChCC,MAAMC,QAAU,QAChBC,EAAiBL,EAAMM,UACvBC,EAAS,WACbP,EAAMM,UAAYD,GAEpBL,EAAMM,UAAYlB,EArBC,UAsBb9M,EAAM,KAtBO,eAuBboN,EAASM,EACTJ,EAAOI,EAAMQ,WACbV,EAAOE,EAAMS,YAzBA,kBA0BZ,CAAEf,SAAQE,OAAME,OAAMS,WA1BV,0DAAH,wDA6BLhB,EAAS,uCAAG,WAAOT,GAAP,mDAAAtQ,EAAA,6DACjBkS,EAAc5B,EAChB,CACEkB,MAAO,CAAElB,aAEX,CAAEkB,OAAO,GALU,SAMFzB,UAAUC,aAAamC,aAAaD,GANlC,cAMjBtB,EANiB,SAOPA,EAAOwB,iBAPA,mBAOhB9N,EAPgB,KAQjB+N,EAASZ,SAASC,eACtB,mBAEIY,EAAMD,EAAOE,WAAW,MACxBC,EAAO,GACPC,EAAO,GACbJ,EAAOhB,MAAQmB,EACfH,EAAOd,OAASkB,EAfO,UAgBsB9B,EAAaC,EAAQtM,GAhB3C,wBAgBf4M,EAhBe,EAgBfA,OAAQE,EAhBO,EAgBPA,KAAME,EAhBC,EAgBDA,KAAMS,EAhBL,EAgBKA,OACtBW,EAAQ1J,KAAK2J,IAAIH,EAAOpB,EAAMqB,EAAOnB,GACrCD,EAAQrI,KAAK4J,IAAIxB,EAAMoB,EAAOE,GAC9BnB,EAASvI,KAAK4J,IAAItB,EAAMmB,EAAOC,GAC/BxO,GAAKkN,EAAOC,GAAS,EACrBwB,GAAKvB,EAAOC,GAAU,EAC5Be,EAAIQ,UAAU5B,EAAQhN,EAAG2O,EAAGxB,EAAOE,EAAQ,EAAG,EAAGiB,EAAMC,GACnDV,GACFA,IAEFzN,EAAMU,OA1BiB,kBA2BhBqN,EAAOU,UAAU,eA3BD,4CAAH,sDCFhBC,EAAc,SAAC9O,GAAD,OAClBD,EAASC,IACkC,kBAAnCA,EAAyB+O,OARhB,SAAC/O,GAAD,OACjBD,EAASC,IACwC,kBAAzCA,EAA4BgL,UACW,kBAAvChL,EAA2BrF,SACc,mBAAzCqF,EAA4BgP,SAKpCC,CAAYjP,EAAwBP,O,2BC9BzByP,GAAc,uCAAG,WAAO9C,GAAP,yBAAAtQ,EAAA,6DACtBkS,EAAc5B,EAChB,CACEkB,MAAO,CAAElB,aAEX,CAAEkB,OAAO,GALe,SAMPzB,UAAUC,aAAamC,aAAaD,GAN7B,cAMtBtB,EANsB,SAOZA,EAAOwB,iBAPK,mBAOrB9N,EAPqB,KAQtBmI,EAAU,WACdnI,EAAMU,QAToB,kBAWrB,CACL4L,SACAnE,YAb0B,2CAAH,sDAiBd4G,GAAkB,uCAAG,WAAO/C,GAAP,iDAAAtQ,EAAA,6DAC1BkS,EAAc5B,EAChB,CACEkB,MAAO,CAAElB,aAEX,CAAEkB,OAAO,GALmB,SAMXzB,UAAUC,aAAamC,aAAaD,GANzB,cAM1BtB,EAN0B,SAOhBA,EAAOwB,iBAPS,mBAOzB9N,EAPyB,MAQ1BkN,EAAQC,SAASC,eAAe,mBAChCC,MAAMC,QAAU,QACtBJ,EAAMM,UAAYlB,EAVc,UAW1B9M,EAAM,KAXoB,eAY1BsN,EAAOI,EAAMQ,WACbV,EAAOE,EAAMS,YACbI,EAASZ,SAASC,eACtB,mBAEIY,EAAMD,EAAOE,WAAW,MACjB,GACA,GACbF,EAAOhB,MAFM,GAGbgB,EAAOd,OAFM,GAGPmB,EAAQ1J,KAAK2J,IAJN,GAIiBvB,EAHjB,GAG8BE,GACrCD,EAAQrI,KAAK4J,IAAIxB,EALV,GAKuBsB,GAC9BnB,EAASvI,KAAK4J,IAAItB,EALX,GAKwBoB,GAC/BxO,GAAKkN,EAAOC,GAAS,EACrBwB,GAAKvB,EAAOC,GAAU,EAEf,SAAP+B,IACJhB,EAAIQ,UAAUtB,EAAOtN,EAAG2O,EAAGxB,EAAOE,EAAQ,EAAG,EAXlC,GACA,IAWXgC,EAAQ/U,WAAW8U,EAAM,IAAO,IAElCA,GACME,EAAgBnB,EAAeoB,gBAC/BhH,EAAU,WACd+E,EAAMG,MAAMC,QAAU,OACtB8B,aAAaH,GACbjP,EAAMU,OACNwO,EAAapB,iBAAiB,GAAGpN,QAtCH,kBAwCzB,CACL4L,OAAQ4C,EACR/G,YA1C8B,4CAAH,sDA8CzBkH,GAAsB,uCAAG,WAAOrP,GAAP,qBAAAtE,EAAA,gEAErBwR,EAAQC,SAASmC,cAAc,UAC/B9B,UAAY,IAAIxF,YAAY,CAAChI,IAC1B7D,EAAI,EAJc,YAIXA,EAAI,IAJO,iCAMnBqD,EAAM,KANa,UAOnBuN,EAAQG,EAAMQ,WACdT,EAASC,EAAMS,cACjBZ,EAAQ,GAAKE,EAAS,GATD,0CAUN,KAAVF,GAA2B,KAAXE,GAVA,QAIH9Q,GAAK,EAJF,iDAapB,GAboB,4DAepB,GAfoB,0DAAH,sDAmBtBoT,GAAwB,IAAIzP,QAErB0P,GAAuB,SAACxP,GACnC,GAAIuP,GAAsBrP,IAAIF,GAC5B,OAAOuP,GAAsBlR,IAAI2B,GAEnC,IAAMyP,EAAUJ,GAAuBrP,GAEvC,OADAuP,GAAsBvS,IAAIgD,EAAOyP,GAC1BA,GC5FIC,GAAc,uCAAG,WAAO1D,GAAP,yBAAAtQ,EAAA,6DACtBkS,EAAc5B,EAChB,CACE2D,MAAO,CAAE3D,aAEX,CAAE2D,OAAO,GALe,SAMPlE,UAAUC,aAAamC,aAAaD,GAN7B,cAMtBtB,EANsB,SAOZA,EAAOsD,iBAPK,mBAOrB5P,EAPqB,cAQtBA,EAAM6P,iBAAiB,CAC3BC,kBAAkB,EAClBC,qBAAsB,CAAEC,MAAO,UAC/BC,iBAAkB,CAAED,OAAO,KAXD,cAatB7H,EAAU,WACdnI,EAAMU,QAdoB,kBAgBrB,CACL4L,SACAnE,YAlB0B,2CAAH,sDCMrB+H,GAAmB,SACvBlQ,EACAsM,EACA6D,GAEA,IAAMC,EAAY9D,GAAU,IAAItE,YAQhC,OAPAoI,EAAUzI,SAAS3H,GACnBA,EAAMa,iBAAiB,SAAS,WAC9BuP,EAAUxI,YAAY5H,GACe,IAAjCoQ,EAAU5I,YAAY3L,QACxBsU,OAGGC,GCVHC,GAAY1W,IAAMC,MAStB,gBAAG+U,EAAH,EAAGA,MAAO/D,EAAV,EAAUA,SAAU0F,EAApB,EAAoBA,WAAYC,EAAhC,EAAgCA,UAAW3B,EAA3C,EAA2CA,SAAUtC,EAArD,EAAqDA,OAAQkE,EAA7D,EAA6DA,UAA7D,OACE,yBAAKC,UAAU,kBAAkBpD,MAAO,CAAEqD,QAASH,EAAY,GAAM,IAClE3B,IAAa2B,GAAajE,EACzB,2BACEmE,UAAU,mBACVE,IAAK,SAACC,GACAA,GAAYA,EAASpD,YAAclB,IAErCsE,EAASpD,UAAYlB,IAGzBuE,UAAQ,EACRC,OAAQN,IAGV,yBACEO,IAAKpC,GA3Bb,qHA4BQ8B,UAAU,mBACVO,IAAI,WAGR,yBAAKP,UAAU,mBAAmB7F,GAClC,yBAAK6F,UAAU,mBAAmBH,GACjC1B,IAAa2B,GAAajE,GACzB,yBAAKmE,UAAU,4BAA4BQ,MAAM,gBAAjD,UAIDrC,IAAa2B,IAAcjE,GAC1B,yBAAKmE,UAAU,4BAA4BQ,MAAM,uBAAjD,cAQKC,GAAavX,IAAMC,MAW9B,YAUO,IATL2D,EASI,EATJA,OACAyD,EAQI,EARJA,OACA4J,EAOI,EAPJA,SACA0F,EAMI,EANJA,WACA1B,EAKI,EALJA,SACAuC,EAII,EAJJA,MACAX,EAGI,EAHJA,UACAY,EAEI,EAFJA,cACAC,EACI,EADJA,cACI,EJ1CqB,SAC3B9T,EACAyD,EACA4J,EACA0F,EACA1B,EACA5C,GACI,IAAD,EAC2BlS,qBAD3B,mBACIwX,EADJ,KACaC,EADb,OAEiCzX,mBAAsB,IAFvD,mBAEI0X,EAFJ,KAEgBC,EAFhB,OAGiC3X,qBAHjC,mBAGI4X,EAHJ,KAGgBC,EAHhB,KAKH,GAAID,EACF,MAAMA,EAGR,IAAM/N,EAAgBiG,EAAiBrM,EAAQyD,GA4F/C,OA3FAkJ,EACE3M,EACAyD,EACA+I,uBAAY,SAACtN,EAAM4C,GACjB,GAAKqP,EAAYjS,GAAjB,CACA,IAAMmV,EAAS,eACVnV,EADU,CAEbuE,OAAQ3B,EAAK2B,OACb6Q,SAAU3G,KAAKD,MACfsF,WAAW,EACX/S,UAAW6B,EAAK7B,YAElBiU,GAAc,SAACnG,GAEb,OADcA,EAAKhL,MAAK,SAACwR,GAAD,OAAUA,EAAK9Q,SAAW4Q,EAAU5Q,UAIrDsK,EAAKpQ,KAAI,SAAC4W,GAAD,OACdA,EAAK9Q,SAAW4Q,EAAU5Q,OAAS4Q,EAAYE,KAHzC,GAAN,mBAAWxG,GAAX,CAAiBsG,UAMpB,KAGLpI,EACEjM,EACAyD,EACA+I,uBAAY,SAACL,GACX,GAAIA,GAAwC,sBAAvBA,EAAcnG,KAA8B,CAAC,IACxD/F,EAAckM,EAAdlM,UACRiU,GAAc,SAACnG,GACb,IAAIyG,GAAU,EACRC,EAAO1G,EAAKpQ,KAAI,SAAC4W,GACrB,OAAIA,EAAKtU,YAAcA,GACrBuU,GAAU,EACH,eAAKD,EAAZ,CAAkBvB,WAAW,KAExBuB,KAET,OAAOC,EAAUC,EAAO1G,QAG3B,KAGLrR,qBAAU,WACR,IAsBIgV,EAtBEgD,EAAsB,WAC1B,IAAMC,EAAYhH,KAAKD,MAAQ,KACzBkH,EAAYjH,KAAKD,MAAQ,IAC/BwG,GAAc,SAACnG,GACb,IAAIyG,GAAU,EACRC,EAAO1G,EACVpQ,KAAI,SAAC4W,GACJ,OAAIA,EAAKD,SAAWK,IAAcJ,EAAKvB,WACrCwB,GAAU,EACH,eAAKD,EAAZ,CAAkBvB,WAAW,KAE3BuB,EAAKD,SAAWM,GAAaL,EAAKvB,WACpCwB,GAAU,EACH,MAEFD,KAERvP,QAAO,SAACuP,GAAD,OAAUA,KAEpB,OAAOC,EAAUC,EAAO1G,MAItB0D,EAAI,uCAAG,4BAAAtT,EAAA,sEAETuW,IAFS,SAGWxF,EAAUT,GAHrB,OAGH2C,EAHG,OAIT4C,EAAW5C,GAMXhL,EAJwB,CACtBgL,QACAtP,KAHqB,CAAEuL,WAAUrQ,QAAS+V,EAAY1B,cAKpC,GAVX,kDAYT+C,EAAc,EAAD,IAZJ,QAcX1C,EAAQ/U,WAAW8U,EAAM,MAdd,0DAAH,qDAiBV,OADAA,IACO,WACLI,aAAaH,MAEd,CAAC1R,EAAQyD,EAAQgL,EAAUpB,EAAU0F,EAAY1B,EAAUjL,IAEvD,CACL2N,UACAE,cInEgCY,CAC9B7U,EACAyD,EACA4J,EACA0F,EACA1B,EACAwC,GANME,EADJ,EACIA,QAASE,EADb,EACaA,WADb,EDtDqB,SAC3BjU,EACAyD,EACAqR,EACAC,EACAnB,EACAC,EACAC,GACI,IAAD,EACiCvX,mBAA6B,MAD9D,mBACIyY,EADJ,KACgBC,EADhB,OAEuC1Y,mBAEvC,IAJA,mBAEI2Y,EAFJ,KAEmBC,EAFnB,KAMGC,EAAY7I,kBAAO,GACzB7P,qBAAU,WACR0Y,EAAU3I,SAAU,IACnB,IAEH,IAAMM,EAAUP,sBAAW,uCAAC,WAAO/J,EAAOX,GAAd,eAAA3D,EAAA,8DACP,UAAfsE,EAAM8L,MADgB,qCACY0D,GAAqBxP,GADjC,qFAIpBmQ,EAAgB,WAChBwC,EAAU3I,SACZ0I,GAAiB,SAACpH,GAAU,IAAD,EAChBjM,EAAK2B,OAAwBsK,EADb,GAEzB,OAFyB,aACaA,EADb,mBAM/BoH,GAAiB,SAACpH,GAChB,IAAMgB,EAAShB,EAAKjM,EAAK2B,QACnBoP,EAAYF,GAAiBlQ,EAAOsM,EAAQ6D,GAClD,OAAI7D,IAAW8D,EACN9E,EAEF,eAAKA,EAAZ,gBAAmBjM,EAAK2B,OAASoP,OAlBT,2CAAD,wDAoBxB,IA/BA,EAoCC/F,EACF9M,EACAyD,EACAsJ,EACA+H,EAAe,iBAAcjI,GANnBwI,EAlCT,EAkCDjL,SACakL,EAnCZ,EAmCDjL,YAnCC,EA8CCyC,EACF9M,EACAyD,EACAsJ,EACAgI,EAAe,iBAAclI,GANnB0I,EA5CT,EA4CDnL,SACaoL,EA7CZ,EA6CDnL,YA8EF,OAtEA3N,qBAAU,WACR,IAAIkO,EAA+B,KAyBnC,OAxBIkK,GAAgBO,GAAiBC,GACnC,sBAAC,wCAAAnX,EAAA,sEAIWqT,GAAmBqC,GAJ9B,gBAEW4B,EAFX,EAEG1G,OACS2G,EAHZ,EAGG9K,QAHH,EAKsB6K,EAAYlF,iBALlC,mBAKQoF,EALR,KAMCN,EAAcM,GACR/C,EAAgB,WAChBwC,EAAU3I,SACZwI,EAAc,OAGlBA,GAAc,SAAClH,GAAD,OACZ4E,GAAiBgD,EAAY5H,EAAM6E,MAErChI,EAAU,WACR0K,EAAiBK,GACjBD,IAEAC,EAAWvS,cAAc,IAAIC,MAAM,WAnBtC,2CAAD,GAuBK,WACDuH,GAASA,OAEd,CAAC5K,EAAQ8U,EAAcjB,EAAewB,EAAeC,IAExD5Y,qBAAU,WACR,IAAIkO,EAA+B,KAyBnC,OAxBImK,GAAgBQ,GAAiBC,GACnC,sBAAC,wCAAArX,EAAA,sEAIWgU,GAAe2B,GAJ1B,gBAEW8B,EAFX,EAEG7G,OACS8G,EAHZ,EAGGjL,QAHH,EAKsBgL,EAAYvD,iBALlC,mBAKQyD,EALR,KAMCP,EAAcO,GACRlD,EAAgB,WAChBwC,EAAU3I,SACZwI,EAAc,OAGlBA,GAAc,SAAClH,GAAD,OACZ4E,GAAiBmD,EAAY/H,EAAM6E,MAErChI,EAAU,WACR4K,EAAiBM,GACjBD,IAEAC,EAAW1S,cAAc,IAAIC,MAAM,WAnBtC,2CAAD,GAuBK,WACDuH,GAASA,OAEd,CAAC5K,EAAQ+U,EAAcjB,EAAeyB,EAAeC,IACxD9Y,qBAAU,WACR,GAAIsY,EAAY,CAAC,IAAD,EACOA,EAAW3C,iBAAzByD,EADO,oBAEVA,IACFA,EAAWC,QAAUnC,MAGxB,CAACoB,EAAYpB,IAET,CAAEoB,aAAYE,iBCpEmBc,CACpChW,EACAyD,EACA4N,EACAA,EACAuC,EACAC,EACAC,GAPMkB,EATJ,EASIA,WAAYE,EAThB,EASgBA,cAUpB,OACE,yBAAKhC,UAAU,uBACb,kBAACJ,GAAD,CACE1B,MAAO2C,EACP1G,SAAUA,EACV0F,WAAYA,EACZ1B,SAAUA,EACVtC,OAAQiG,QAAcnI,IAEvBoH,EAAWtW,KAAI,SAAC4W,GAAD,OACd,kBAACzB,GAAD,CACEvU,IAAKgW,EAAK9Q,OACV2N,MAAOmD,EAAKnD,MACZ/D,SAAUkH,EAAKzS,KAAKuL,SACpB0F,WAAYwB,EAAKzS,KAAK9E,QACtBgW,UAAWuB,EAAKvB,UAChB3B,SAAUkD,EAAKzS,KAAKuP,SACpBtC,OAASsC,GAAY6D,EAAcX,EAAK9Q,cAAYoJ,EACpDoG,UAAWA,WCxEjBgD,I,MAAe,SAAC9X,EAAUP,GAC9B,IAAMsY,EAAYtY,EAAE,GAAKO,EAAE,GAC3B,OAAkB,IAAd+X,EACK/X,EAAE,GAAGG,OAASV,EAAE,GAAGU,OAErB4X,IAGIC,GAAmB,SAC9BnW,EACAyD,EACA4J,GAEA,IAAM+I,EAAa7J,iBAAO,GACpB8J,EAAiB9J,iBAAO,IAAItI,KAF/B,EAG6B1H,mBAAqB,IAHlD,mBAGI+Z,EAHJ,KAGcC,EAHd,KAKGC,EAAchK,uBAAY,SAACiK,GAC/B,IAAKJ,EAAe5J,QAAQ3L,IAAI2V,EAAShT,SAAW,GAAKgT,EAASC,QAKlE,GAJEL,EAAe5J,QAAQhN,IAAIgX,EAAShT,OAAQgT,EAASC,SAInDD,EAASE,cAAe,CAAC,IACnBC,EAA4BH,EAA5BG,SAAUD,EAAkBF,EAAlBE,cAClBJ,GAAY,SAACxI,GAAD,OACVA,EAAKpQ,KAAI,SAAC4W,GACR,GACEA,EAAKsC,QAAQpT,SAAWkT,EAAclT,QACtC8Q,EAAKsC,QAAQH,UAAYC,EAAcD,QACvC,CACA,IAAMI,EAAW,IAAI7S,IAAIsQ,EAAKwC,SAC9BD,EAASrX,IAAImX,GAAWE,EAAShW,IAAI8V,IAAa,GAAK,GACvD,IAAMG,EAAO,YAAOD,EAASE,WAE7B,OADAD,EAAQE,KAAKhB,IACN,eAAK1B,EAAZ,CAAkBwC,YAEpB,OAAOxC,YAGN,CACL,IAAM2C,EAAO,IAAIvJ,KACXwJ,EAAqB,CACzB5Y,IAAI,GAAD,OAAKkY,EAAShT,OAAd,YAAwBgT,EAASC,SACpCG,QAAS,CACPpT,OAAQgT,EAAShT,OACjBiT,QAASD,EAASC,SAEpBrJ,SAAUoJ,EAASpJ,SACnB+J,KAAMX,EAASG,SACfG,QAAS,GACTG,KAAMA,EAAKG,iBAAiBhX,MAAM,KAAK,GAAGvB,MAAM,GAAI,IAEtDyX,GAAY,SAACxI,GAAD,MAAU,CAACoJ,GAAD,mBAAcpJ,IAAMjP,MAAM,EAzF3B,WA2FtB,IAEGsH,EAAgBiG,EAAiBrM,EAAQyD,GA4C/C,OA3CAkJ,EACE3M,EACAyD,EACA+I,uBACE,SAACtN,GArFY,IAACmD,GAClBD,EADkBC,EAsFInD,IApFuB,kBAArCmD,EAA0BoB,QACe,kBAAzCpB,EAA4BgL,UACW,kBAAvChL,EAA2BqU,SACc,kBAAzCrU,EAA4BuU,UACwB,qBAAnDvU,EAAiCsU,eAE1B,kBADNtU,EAA6CsU,cAClDlT,QAEY,kBADPpB,EAA8CsU,cACnDD,SA6ECF,EAAYtX,KAEd,CAACsX,KAmCE,CACLF,WACAgB,SAjCe9K,uBACf,SAAC4K,GACC,IAAMlY,EAAiB,CACrBuE,SACA4J,WACAqJ,QAASN,EAAW3J,QACpBmK,SAAUQ,GAEZhB,EAAW3J,SAAW,EACtBrG,EAAclH,GACdsX,EAAYtX,KAEd,CAACkH,EAAe3C,EAAQ4J,EAAUmJ,IAsBlCe,UAnBgB/K,uBAChB,SAAC4K,EAAcI,GACb,IAAMtY,EAAiB,CACrBuE,SACA4J,WACAqJ,QAASN,EAAW3J,QACpBmK,SAAUQ,EACVT,cAAea,GAEjBpB,EAAW3J,SAAW,EACtBrG,EAAclH,GACdsX,EAAYtX,KAEd,CAACkH,EAAe3C,EAAQ4J,EAAUmJ,M,iBCnIzBiB,GAAcC,KCCrBC,GAA2Bvb,IAAMC,MAGpC,YAA0B,IAAvBkY,EAAsB,EAAtBA,KAAMgD,EAAgB,EAAhBA,UAAgB,EACoBhb,oBAAS,GAD7B,mBACnBqb,EADmB,KACFC,EADE,KAEpBC,EAAQ,SAACV,GAAD,OAAkBG,EAAUH,EAAM7C,EAAKsC,UACrD,OACE,wBAAItY,IAAKgW,EAAKhW,IAAK2U,UAAU,0BAC1B0E,GACC,kBAACH,GAAD,CACEM,SAAU,SAACpc,GACTmc,EAAMnc,EAAEqc,QACRH,GAAmB,MAIzB,yBAAK3E,UAAU,iCACb,yBAAKA,UAAU,sCACb,yBAAKA,UAAU,4BACb,4BACElN,KAAK,SACLiS,QAAS,WACPJ,GAAoBD,KAHxB,OAUJ,0BAAM1E,UAAU,0BACbqB,EAAKlH,UAAY,WAEpB,0BAAM6F,UAAU,sBAAsBqB,EAAK2C,OAE7C,6BAAM3C,EAAK6C,MACV7C,EAAKwC,QAAQpZ,KAAI,mCAAEyZ,EAAF,KAAQzL,EAAR,YAChB,4BACEpN,IAAK6Y,EACLlE,UAAU,qBACVlN,KAAK,SACLiS,QAAS,kBAAMH,EAAMV,KAEpBA,EANH,IAMUzL,UAOZuM,GAAuB9b,IAAMC,MAIhC,YAA8C,IAA3Cia,EAA0C,EAA1CA,SAAUiB,EAAgC,EAAhCA,UAAWY,EAAqB,EAArBA,eACnBC,EAAc7L,iBAAgC,MAOpD,OANA8L,2BAAgB,WACVD,EAAY3L,SACd0L,EAAeC,EAAY3L,QAAQ6L,iBAKrC,wBAAIpF,UAAU,qBAAqBE,IAAKgF,GACrC9B,EAAS3Y,KAAI,SAAC4W,GAAD,OACZ,kBAACoD,GAAD,CACEpZ,IAAKgW,EAAKhW,IACVgW,KAAMA,EACNgD,UAAWA,WAORgB,GAAgBnc,IAAMC,MAIhC,YAAmC,IAAhC2D,EAA+B,EAA/BA,OAAQyD,EAAuB,EAAvBA,OAAQ4J,EAAe,EAAfA,SACdmL,EAAejM,iBAA8B,MADhB,EAEO4J,GACxCnW,EACAyD,EACA4J,GAHMiJ,EAF2B,EAE3BA,SAAUgB,EAFiB,EAEjBA,SAAUC,EAFO,EAEPA,UAFO,EAQXhb,mBAAS,IARE,mBAQ5B6a,EAR4B,KAQtBqB,EARsB,KAiBnC,OACE,yBAAKvF,UAAU,0BAA0BE,IAAKoF,GAC5C,kBAACN,GAAD,CACE5B,SAAUA,EACViB,UAAWA,EACXY,eAAgB,SAACzI,GACX8I,EAAa/L,UACf+L,EAAa/L,QAAQiM,UAAYhJ,MAIvC,0BAAMiJ,SAnBO,SAAC9P,GAChBA,EAAM+P,iBACFxB,IACFE,EAASF,GACTqB,EAAQ,OAgBN,yBAAKvF,UAAU,oCACb,2BACExR,MAAO0V,EACPyB,SAAU,SAACld,GAAD,OAAO8c,EAAQ9c,EAAEmd,OAAOpX,QAClCqX,YAAY,uBAEd,4BAAQ/S,KAAK,SAASgT,UAAW5B,GAAjC,cC1HG6B,I,MAAe,uCAAG,sCAAA9a,EAAA,sEAErBkS,EAAc,CAAEV,OAAO,GAFF,SAGJzB,UAAUC,aAAqB+K,gBACpD7I,GAJyB,cAGrBtB,EAHqB,SAMXA,EAAOwB,iBANI,mBAMpB9N,EANoB,KAOrBmI,EAAU,WACdnI,EAAMU,QARmB,kBAUpB,CACL4L,SACAnE,YAZyB,2DAepB,MAfoB,0DAAH,sDCMtBuO,GAAa,uCAAG,WAAO1W,GAAP,eAAAtE,EAAA,yDACD,UAAfsE,EAAM8L,KADU,0CACe,GADf,uBAEK0D,GAAqBxP,GAF1B,cAEd2W,EAFc,0BAGZA,GAHY,2CAAH,sDCAbC,GAASjd,IAAMC,MAGlB,YAA2B,IAAxBgR,EAAuB,EAAvBA,SAAU0B,EAAa,EAAbA,OACRuK,EAAW/M,iBAAyB,MAM1C,OALA7P,qBAAU,WACJqS,GAAUuK,EAAS7M,UACrB6M,EAAS7M,QAAQwD,UAAYlB,KAE9B,CAACA,IAEF,6BACE,yBAAKmE,UAAU,wBAAwB7F,GACvC,2BAAO6F,UAAU,oBAAoBE,IAAKkG,EAAUhG,UAAQ,EAACC,OAAK,QAK3DgG,GAAcnd,IAAMC,MAI9B,YAAmC,IAAhC2D,EAA+B,EAA/BA,OAAQyD,EAAuB,EAAvBA,OAAQ4J,EAAe,EAAfA,SAAe,EACL9Q,oBAAS,GADJ,mBAC5BwZ,EAD4B,KACnByD,EADmB,ODhBP,SAC5BxZ,EACAyD,EACAsS,EACAyD,GACI,IAAD,EACqCjd,mBAA6B,MADlE,mBACIkd,EADJ,KACkBC,EADlB,OAE2Cnd,mBAE3C,IAJA,mBAEIod,EAFJ,KAEqBC,EAFrB,KAOGC,EAAatN,iBAAoB,IACvC7P,qBAAU,WAIR,OAHgB,WACdmd,EAAWpN,QAAQpH,SAAQ,SAACyU,GAAD,OAAQA,UAGpC,IAEH,IAAM/M,EAAUP,sBAAW,uCAAC,WAAO/J,EAAOX,GAAd,eAAA3D,EAAA,sEACdgb,GAAc1W,GADA,kEAE1BmX,GAAmB,SAAC7L,GAAD,sBACdA,EADc,gBAEhBjM,EAAK2B,OAAS,IAAIgH,YAAY,CAAChI,SAE5BsX,EAAU,WACdH,GAAmB,SAAC7L,GAAD,sBACdA,EADc,gBAEhBjM,EAAK2B,OAAS,WAGnBhB,EAAMa,iBAAiB,QAASyW,GAChCF,EAAWpN,QAAQoB,MAAK,WACtBpL,EAAMuX,oBAAoB,QAASD,MAdX,2CAAD,wDAgBxB,IA/BA,EAiC+BjN,EAChC9M,EACAyD,EACAsJ,EACA,eAJM3C,EAjCL,EAiCKA,SAAUC,EAjCf,EAiCeA,YAoClB,OA7BA3N,qBAAU,WACR,IAAIkO,EAA+B,KAuBnC,OAtBImL,GAAW3L,GAAYC,GACzB,sBAAC,kCAAAlM,EAAA,sEACsB8a,KADtB,UACO/L,EADP,8BAGGsM,GAAW,GAHd,4BAMiBtM,EAAO6B,OAAOwB,iBAN/B,mBAMQ9N,EANR,KAOC2H,EAAS3H,GACTiX,EAAgBxM,EAAO6B,QACvBnE,EAAU,WACRP,EAAY5H,GACZyK,EAAOtC,UACP8O,EAAgB,MAChBF,GAAW,IAEb/W,EAAMa,iBAAiB,SAAS,WAC1BsH,GAASA,IACbA,EAAU,QAjBb,2CAAD,GAqBK,WACDA,GAASA,OAEd,CAAC5K,EAAQ+V,EAASyD,EAAYpP,EAAUC,IAEpC,CAAEoP,eAAcE,mBCxDmBM,CACxCja,EACAyD,EACAsS,EACAyD,GAJMC,EAF2B,EAE3BA,aAAcE,EAFa,EAEbA,gBAMhBpM,EAAcD,EAAetN,EAAQyD,GAE3C,OACE,yBAAKyP,UAAU,yBACb,4BAAQlN,KAAK,SAASiS,QAAS,kBAAMuB,GAAYzD,KAC9CA,EAAU,oBAAsB,sBAElC0D,GAAgB,kBAACJ,GAAD,CAAQhM,SAAUA,EAAU0B,OAAQ0K,IACpDzL,OAAOlS,KAAK6d,GAAiBhc,KAAI,SAACuc,GACjC,IAAMnL,EAAS4K,EAAgBO,GAC/B,OAAKnL,EAEH,kBAACsK,GAAD,CACE9a,IAAK2b,EACL7M,SAAUE,EAAY2M,IAAiB,UACvCnL,OAAQA,IALQ,YCzCtBoL,I,MAAY,uCAAG,WAAO1X,GAAP,eAAAtE,EAAA,yDACA,UAAfsE,EAAM8L,KADS,0CACgB,GADhB,uBAEM0D,GAAqBxP,GAF3B,cAEb2W,EAFa,0BAGXA,GAHW,2CAAH,uDCEZgB,GAAQhe,IAAMC,MAGjB,YAA2B,IAAxBgR,EAAuB,EAAvBA,SAAU0B,EAAa,EAAbA,OACRuK,EAAW/M,iBAAyB,MAM1C,OALA7P,qBAAU,WACJqS,GAAUuK,EAAS7M,UACrB6M,EAAS7M,QAAQwD,UAAYlB,KAE9B,CAACA,IAEF,6BACE,yBAAKmE,UAAU,uBAAuB7F,GACtC,2BAAO6F,UAAU,mBAAmBE,IAAKkG,EAAUhG,UAAQ,EAACC,OAAK,QAK1D8G,GAAaje,IAAMC,MAI7B,YAAmC,IAAhC2D,EAA+B,EAA/BA,OAAQyD,EAAuB,EAAvBA,OAAQ4J,EAAe,EAAfA,SACdiN,EAAe3L,IADc,EAEOpS,qBAFP,mBAE5BsX,EAF4B,KAEb0G,EAFa,OAGLhe,oBAAS,GAHJ,mBAG5BwZ,EAH4B,KAGnByD,EAHmB,ODlBR,SAC3BxZ,EACAyD,EACAsS,EACAyD,EACA3F,GACI,IAAD,EACmCtX,mBAA6B,MADhE,mBACIkZ,EADJ,KACiB+E,EADjB,OAEyCje,mBAEzC,IAJA,mBAEIke,EAFJ,KAEoBC,EAFpB,KAOGb,EAAatN,iBAAoB,IACvC7P,qBAAU,WAIR,OAHgB,WACdmd,EAAWpN,QAAQpH,SAAQ,SAACyU,GAAD,OAAQA,UAGpC,IAEH,IAAM/M,EAAUP,sBAAW,uCAAC,WAAO/J,EAAOX,GAAd,eAAA3D,EAAA,sEACdgc,GAAa1X,GADC,kEAE1BiY,GAAkB,SAAC3M,GAAD,sBACbA,EADa,gBAEfjM,EAAK2B,OAAS,IAAIgH,YAAY,CAAChI,SAE5BsX,EAAU,WACdW,GAAkB,SAAC3M,GAAD,sBACbA,EADa,gBAEfjM,EAAK2B,OAAS,WAGnBhB,EAAMa,iBAAiB,QAASyW,GAChCF,EAAWpN,QAAQoB,MAAK,WACtBpL,EAAMuX,oBAAoB,QAASD,MAdX,2CAAD,wDAgBxB,IA/BA,EAiC+BjN,EAChC9M,EACAyD,EACAsJ,EACA,eAJM3C,EAjCL,EAiCKA,SAAUC,EAjCf,EAiCeA,YAgClB,OAzBA3N,qBAAU,WACR,IAAIkO,EAA+B,KAmBnC,OAlBImL,GAAW3L,GAAYC,GACzB,sBAAC,kCAAAlM,EAAA,sEACsBoT,GAAesC,GADrC,OACO3G,EADP,SAEiBA,EAAO6B,OAAOwB,iBAF/B,mBAEQ9N,EAFR,KAGC2H,EAAS3H,GACT+X,EAAetN,EAAO6B,QACtBnE,EAAU,WACRP,EAAY5H,GACZyK,EAAOtC,UACP4P,EAAe,MACfhB,GAAW,IAEb/W,EAAMa,iBAAiB,SAAS,WAC1BsH,GAASA,IACbA,EAAU,QAbb,0CAAD,GAiBK,WACDA,GAASA,OAEd,CAAC5K,EAAQ6T,EAAekC,EAASyD,EAAYpP,EAAUC,IAEnD,CAAEoL,cAAagF,kBCjDkBE,CACtC3a,EACAyD,EACAsS,EACAyD,EACA3F,GALM4B,EAJ2B,EAI3BA,YAAagF,EAJc,EAIdA,eAOflN,EAAcD,EAAetN,EAAQyD,GACrCmX,GACHnF,EAAc,EAAI,GACnBzH,OAAO5I,OAAOqV,GAAgBzV,QAAO,SAAC3C,GAAD,OAAOA,KAAG/D,OAEjD,OACE,yBAAK4U,UAAU,wBACb,8CACiB,IACf,4BACExR,MAAOmS,EACPgF,SAAU,SAACld,GAAD,OAAO4e,EAAiB5e,EAAEmd,OAAOpX,SAE1C4Y,EAAa3c,KAAI,SAACkd,GAAD,OAChB,4BAAQtc,IAAKsc,EAAYpM,SAAU/M,MAAOmZ,EAAYpM,UACnDoM,EAAYrM,YAKrB,4BAAQxI,KAAK,SAASiS,QAAS,kBAAMuB,GAAYzD,KAC9CA,EAAU,mBAAqB,qBAElC,yBACE7C,UAAU,kBACVpD,MAAO,CACLgL,oBAAoB,UAAD,OAAY3T,KAAK4T,KAClC5T,KAAK6T,KAAKJ,IADO,YAKpBnF,GAAe,kBAAC2E,GAAD,CAAO/M,SAAUA,EAAU0B,OAAQ0G,IAClDzH,OAAOlS,KAAK2e,GAAgB9c,KAAI,SAACuc,GAChC,IAAMnL,EAAS0L,EAAeP,GAC9B,OAAKnL,EAEH,kBAACqL,GAAD,CACE7b,IAAK2b,EACL7M,SAAUE,EAAY2M,IAAiB,UACvCnL,OAAQA,IALQ,aCvEjBkM,I,MAAqB,uCAAG,WAAOjb,GAAP,mBAAA7B,EAAA,6DAC7BjC,EAAK8D,EAAOlB,MAAM,EAAG,IADQ,SAEZL,EAAgBuB,EAAOlB,MzBHd,IyBGyC,CACvE,UACA,YAJiC,cAE7Boc,EAF6B,gBAMhBte,OAAOQ,OAAOgB,OAAOI,UAAU,MAAO0c,GANtB,cAM7B3c,EAN6B,OAMiC0G,EANjC,yDAOI/I,EAPJ,YAOUqC,IAPV,2CAAH,uDCErB4c,GAAmB/e,IAAMC,MAEnC,YAAiB,IAAd2D,EAAa,EAAbA,OAAa,EACKzD,qBADL,mBACV0E,EADU,KACLma,EADK,KAQjB,OANA1e,qBAAU,WACR,sBAAC,4BAAAyB,EAAA,sEAC6B8c,GAAsBjb,GADnD,OACOqb,EADP,OAECD,EAAOC,GAFR,0CAAD,KAIC,CAACrb,IAEF,yBAAKkT,UAAU,8BACZjS,GAAO,4BAAQyS,MAAM,aAAaF,IAAKvS,QCZxCqa,I,MAAYlf,IAAMC,MAMrB,YAAyE,IAAtEkf,EAAqE,EAArEA,YAAaC,EAAwD,EAAxDA,SAAUC,EAA8C,EAA9CA,YAAa1C,EAAiC,EAAjCA,YAAa2C,EAAoB,EAApBA,cAAoB,EACjDnf,mBAASgf,GADwC,mBAClEnE,EADkE,KAC5DqB,EAD4D,KAYzE,OACE,0BAAME,SAXS,SAAC9P,GAChBA,EAAM+P,iBACFxB,IACFoE,EAASpE,GACLsE,GACFjD,EAAQ,OAOV,2BACE/W,MAAO0V,EACPyB,SAAU,SAACld,GAAD,OAAO8c,EAAQ9c,EAAEmd,OAAOpX,QAClCqX,YAAaA,IAEd0C,GACC,4BAAQzV,KAAK,SAASgT,UAAW5B,GAC9BqE,QAOEE,GAAcvf,IAAMC,MAO/B,YAMO,IALLuf,EAKI,EALJA,gBACAC,EAII,EAJJA,MACAC,EAGI,EAHJA,iBACAC,EAEI,EAFJA,mBACAC,EACI,EADJA,cACI,EAC0Czf,oBAAS,GADnD,mBACGqb,EADH,KACoBC,EADpB,KAEJ,OACE,yBAAK3E,UAAU,yBACb,yBAAKA,UAAU,wBACb,kBAACoI,GAAD,CACEC,YAAaK,EACbJ,SAAUM,EACV/C,YAAY,kBACZ0C,YAAY,SAGhB,yBAAKvI,UAAU,2BACb,yBAAKA,UAAU,qBACb,4BACElN,KAAK,SACLiS,QAAS,WACPJ,GAAoBD,KAGrBiE,EAAQ,kBAAC,KAAD,CAAOA,MAAOA,EAAOld,KAAM,KAAS,OAGjD,yBAAKuU,UAAU,0BACb,kBAACoI,GAAD,CACEC,YAAY,GACZC,SAAUO,EACVhD,YAAY,uBACZ0C,YAAY,SAGhB,4BACEzV,KAAK,SACLiS,QAAS,WACP+D,EAAc,MACdD,EAAmB,IACnBlE,GAAmB,KALvB,UAWDD,GACC,kBAACH,GAAD,CACEM,SAAU,SAACpc,GACTqgB,EAAcrgB,GACdkc,GAAmB,UClF3B+D,GAAkB7Z,EAAc,YAChCka,GAAuD,SAAnCla,EAAc,iBAClCma,GAAuBna,EAAc,6BACrCoa,GAAuBpa,EAAc,6BAE9Bqa,GAAahgB,IAAMC,MAG7B,YAAyB,IAAtB2D,EAAqB,EAArBA,OAAQyD,EAAa,EAAbA,OAAa,EACOlH,mBAASqf,IADhB,mBAClBvO,EADkB,KACRgP,EADQ,OAEW9f,mBAAS,IAFpB,mBAElBwW,EAFkB,KAENuJ,EAFM,OAGC/f,mBAA+B,MAHhC,mBAGlBsf,EAHkB,KAGXU,EAHW,KAIzB7f,qBAAU,Y3BZkB,SAACsD,GAC7B,IAAMW,EAAO/D,OAAOC,SAAS8D,KAAK7B,MAAM,GAClC0d,EAAe,IAAI3b,gBAAgBF,GACzC6b,EAAa/c,IAAI,SAAUO,GAC3BpD,OAAOC,SAAS8D,KAAO6b,EAAa3e,W2BSlC4e,CAAezc,KACd,CAACA,IAEJ,IAAMsa,EAAe3L,IACf+N,ElBHuB,WAAO,IAAD,EACLngB,mBAA8B,IADzB,mBAC5B8R,EAD4B,KACnBO,EADmB,KAQnC,OANAlS,qBAAU,WACR,sBAAC,4BAAAyB,EAAA,sEAC8BuQ,IAD9B,OACOG,EADP,OAECD,EAAWC,GAFZ,0CAAD,KAIC,IACIR,EkBLcsO,GATI,EAUiBpgB,mBAAS2f,IAV1B,mBAUlBrI,EAVkB,KAUH0G,EAVG,OAWiBhe,mBAAS4f,IAX1B,mBAWlBrI,EAXkB,KAWH8I,EAXG,OAYOrgB,oBAAS,GAZhB,mBAYlB8U,EAZkB,KAYRwL,EAZQ,OAaCtgB,oBAAS,GAbV,mBAalBqX,EAbkB,KAaXkJ,EAbW,OAcSvgB,oBAAS,GAdlB,mBAclB0W,EAdkB,KAcP8J,EAdO,OAeqBxgB,oBAAS,GAf9B,mBAelBygB,EAfkB,KAeDC,EAfC,OAgBmB1gB,oBAAS,GAhB5B,mBAgBlB2gB,EAhBkB,KAgBFC,GAhBE,QAiBe5gB,oBAAS,GAjBxB,qBAiBlB6gB,GAjBkB,MAiBJC,GAjBI,SAmBW9gB,mBAAS0f,IAnBpB,qBAmBlBqB,GAnBkB,MAmBNC,GAnBM,MAoBzB7gB,qBAAU,WACR+E,EAAc,gBAAiB6b,GAAa,QAAU,UACrD,CAACA,KAEJ,IAAMnR,GAAgBF,EAAqBjM,EAAQyD,GACnD6J,EAAetN,EAAQyD,GAEvB,IAAM+Z,GAAO,yBAAqB5gB,OAAOC,SAAS4gB,KAAKC,QACrD,cACA,KAGF,OACE,oCACE,yBAAKxK,UAAU,mBACb,kBAAC,GAAD,CACElT,OAAQA,EACRyD,OAAQA,EACRoQ,cAAeA,EACfC,cAAeA,EACfzG,SAAUA,EACV0F,WAAU,WAAU,OAAL8I,QAAK,IAALA,OAAA,EAAAA,EAAO7D,SAAU,IAAtB,OAA2BjF,GACrC1B,SAAUA,EACVuC,MAAOA,EACPX,UAAWA,IAEb,yBAAKC,UAAU,yBACb,kBAAC,GAAD,CACE0I,gBAAiBA,GACjBC,MAAOA,EACPC,iBAAkB,SAAC1E,GACjBiF,EAAYjF,GACZ3V,EAAc,WAAY2V,IAE5B2E,mBAAoB,SAAC3E,GACnBkF,EAAclF,IAEhB4E,cAAe,SAACrgB,GACd4gB,EAAS5gB,MAGb,6BACE,4BACEqK,KAAK,SACLkN,UAAU,2BACV+E,QAAS,kBAAMsF,IAAc,SAACI,GAAD,OAAQA,OAHvC,UAKUL,GAAa,8CAAe,+CAErCA,IACC,yBAAKpK,UAAU,qBACb,kDAEE,2BAAOxR,MAAO9E,OAAOC,SAAS4gB,KAAMG,UAAQ,IAF9C,yCAIE,uBAAGH,KAAMD,IAAT,aAEF,8CACiB,IACf,4BACE9b,MAAOmS,EACPgF,SAAU,SAACld,GACT4e,EAAiB5e,EAAEmd,OAAOpX,OAC1BD,EACE,4BACA9F,EAAEmd,OAAOpX,SAIZ4Y,EAAa3c,KAAI,SAACkd,GAAD,OAChB,4BACEtc,IAAKsc,EAAYpM,SACjB/M,MAAOmZ,EAAYpM,UAElBoM,EAAYrM,YAKrB,2CACc,IACZ,4BACE9M,MAAOoS,EACP+E,SAAU,SAACld,GACTihB,EAAiBjhB,EAAEmd,OAAOpX,OAC1BD,EACE,4BACA9F,EAAEmd,OAAOpX,SAIZgb,EAAa/e,KAAI,SAACkgB,GAAD,OAChB,4BACEtf,IAAKsf,EAAYpP,SACjB/M,MAAOmc,EAAYpP,UAElBoP,EAAYrP,YAKrB,0CACa,IACX,4BAAQxI,KAAK,SAASiS,QAAS,kBAAM4E,GAAY,SAACxa,GAAD,OAAQA,OACtDgP,EAAW,UAAY,UAEzBA,GAAY,8CACZA,GACC,6BACE,+BACE,2BACErL,KAAK,WACL8X,QAASlK,EACTiF,SAAU,SAACld,GAAD,OAAOmhB,EAASnhB,EAAEmd,OAAOgF,YAJvC,UAQA,+BACE,2BACE9X,KAAK,WACL8X,QAAS7K,EACT4F,SAAU,SAACld,GAAD,OAAOohB,EAAaphB,EAAEmd,OAAOgF,YAJ3C,gBAWN,6CACgB,IACd,4BACE9X,KAAK,SACLiS,QAAS,kBAAMgF,GAAmB,SAAC5a,GAAD,OAAQA,OAEzC2a,EAAkB,QAAU,QAE9BA,GAAmB,+CAEtB,4CACe,IACb,4BACEhX,KAAK,SACLiS,QAAS,kBAAMkF,IAAkB,SAAC9a,GAAD,OAAQA,OAExC6a,EAAiB,QAAU,QAE7BA,GAAkB,+CAErB,mDACsB,IACpB,4BACElX,KAAK,SACLiS,QAAS,kBAAMoF,IAAgB,SAAChb,GAAD,OAAQA,OAEtC+a,GAAe,QAAU,QAE3BA,IAAgB,+CAEnB,yBAAKlK,UAAU,qBACZlL,KAAKK,UAAU8D,OAKxB,kBAAC,GAAD,CAAenM,OAAQA,EAAQyD,OAAQA,EAAQ4J,SAAUA,KAE3D,yBAAK6F,UAAU,yBACZ8J,GACC,kBAAC,GAAD,CAAahd,OAAQA,EAAQyD,OAAQA,EAAQ4J,SAAUA,IAExD6P,GACC,kBAAC,GAAD,CAAYld,OAAQA,EAAQyD,OAAQA,EAAQ4J,SAAUA,IAEvD+P,IAAgB,kBAAC,GAAD,CAAkBpd,OAAQA,UCjN/C+d,G5BE0B,WAC9B,IAAMpd,EAAO/D,OAAOC,SAAS8D,KAAK7B,MAAM,GAExC,OADqB,IAAI+B,gBAAgBF,GACrBG,IAAI,U4BLJkd,GAChBva,GAASxG,IAEFghB,GAAqB7hB,IAAMC,MAAK,WAAO,IAAD,EACrBE,mBAAwBwhB,IADH,mBAC1C/d,EAD0C,KAClCke,EADkC,OAEjB3hB,mBAAS,IAFQ,mBAE1C4hB,EAF0C,KAEhCC,EAFgC,KAI3CC,EAAW,uCAAG,sBAAAlgB,EAAA,kEAClB+f,EADkB,KAEhBjhB,EAAeqhB,IAFC,SAEgCpgB,IAFhC,4FAAH,qDAUjB,OAAI8B,EACK,kBAAC,GAAD,CAAYA,OAAQA,EAAQyD,OAAQA,KAI3C,yBAAKyP,UAAU,2BACb,4BAAQlN,KAAK,SAASiS,QAASoG,GAA/B,qBADF,KAKE,2BACE3c,MAAOyc,EACPtF,SAAU,SAACld,GAAD,OAAOyiB,EAAYziB,EAAEmd,OAAOpX,QACtCqX,YAAY,uBAEd,4BACE/S,KAAK,SACLiS,QArBU,WACdiG,EAAUzd,EAAsB0d,KAqB5BnF,UAAWvY,EAAsB0d,IAHnC,kBClCAI,I,kNACJC,MAAyB,G,uDAMf,IACAC,EAAaC,KAAKC,MAAlBF,SACAniB,EAAQoiB,KAAKF,MAAbliB,IACR,OAAIA,EAAY,kBAACH,EAAD,CAAeG,IAAKA,IAC7BmiB,K,gDARuBniB,GAC9B,MAAO,CAAEA,W,GAJeF,IAAMwiB,gBAerBC,GAAMziB,IAAMC,MAAK,kBAC5B,yBAAK6W,UAAU,OACb,kBAAC,GAAD,KACE,kBAAC,GAAD,WCZc4L,QACW,cAA7BliB,OAAOC,SAASkiB,UAEe,UAA7BniB,OAAOC,SAASkiB,UAEhBniB,OAAOC,SAASkiB,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,GAAD,OAEFvP,SAASC,eAAe,SD8HpB,kBAAmB3B,WACrBA,UAAUkR,cAAcC,MACrBC,MAAK,SAACC,GACLA,EAAavT,gBAEdwT,OAAM,SAACjX,GACN1G,QAAQ0G,MAAMA,EAAMvL,c","file":"static/js/main.f1565cda.chunk.js","sourcesContent":["function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 40;","import React, { useEffect, useState } from \"react\";\n\nexport const ErrorFallback = React.memo<{\n  err: Error;\n}>(({ err }) => {\n  const [waitSec, setWaitSec] = useState(30);\n\n  useEffect(() => {\n    if (waitSec > 0) {\n      setTimeout(() => {\n        setWaitSec(waitSec - 1);\n      }, 1000);\n    } else {\n      window.location.reload();\n    }\n  });\n\n  return (\n    <div>\n      <h1>Unrecoverable error occurred.</h1>\n      {err && (\n        <h6>\n          {err.name}: {err.message}\n        </h6>\n      )}\n      <p>Will auto reload in {waitSec} sec.</p>\n    </div>\n  );\n});\n","export const sha256 = async (text: string) => {\n  const encoder = new TextEncoder();\n  const data = encoder.encode(text);\n  const buf = await window.crypto.subtle.digest(\"SHA-256\", data);\n  const arr = Array.from(new Uint8Array(buf));\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const secureRandomId = (len = 32) => {\n  const buf = window.crypto.getRandomValues(new Uint8Array(len));\n  const arr = Array.from(buf);\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const rand4 = () => {\n  const rand = window.crypto.getRandomValues(new Uint16Array(1))[0];\n  return 1000 + (rand % 9000);\n};\n\nexport const generateCryptoKey = async () => {\n  const key = await window.crypto.subtle.generateKey(\n    { name: \"AES-GCM\", length: 128 },\n    true,\n    [\"encrypt\", \"decrypt\"]\n  );\n  const buf = await window.crypto.subtle.exportKey(\"raw\", key);\n  const arr = Array.from(new Uint8Array(buf));\n  const hex = arr.map((b) => b.toString(16).padStart(2, \"0\")).join(\"\");\n  return hex;\n};\n\nexport const importCryptoKey = async (\n  key: string,\n  usages: (\"encrypt\" | \"decrypt\")[]\n) => {\n  const size = key.length / 2;\n  const buf = new Uint8Array(size);\n  for (let i = 0; i < size; i += 1) {\n    buf[i] = parseInt(key.slice(i * 2, i * 2 + 2), 16);\n  }\n  const cryptoKey = await window.crypto.subtle.importKey(\n    \"raw\",\n    buf,\n    { name: \"AES-GCM\", length: 128 },\n    true,\n    usages\n  );\n  return cryptoKey;\n};\n\nexport const encrypt = async (data: string, key: string) => {\n  const encoder = new TextEncoder();\n  const cryptoKey = await importCryptoKey(key, [\"encrypt\"]);\n  const iv = window.crypto.getRandomValues(new Uint8Array(12));\n  const encrypted = await window.crypto.subtle.encrypt(\n    { name: \"AES-GCM\", iv },\n    cryptoKey,\n    encoder.encode(data)\n  );\n  const buf = new Uint8Array(iv.length + encrypted.byteLength);\n  buf.set(iv);\n  buf.set(new Uint8Array(encrypted), iv.length);\n  return buf;\n};\n\nexport const decrypt = async (buf: ArrayBuffer, key: string) => {\n  const cryptoKey = await importCryptoKey(key, [\"decrypt\"]);\n  const decrypted = await window.crypto.subtle.decrypt(\n    { name: \"AES-GCM\", iv: buf.slice(0, 12) },\n    cryptoKey,\n    buf.slice(12)\n  );\n  const decoder = new TextDecoder(\"utf-8\");\n  const data = decoder.decode(new Uint8Array(decrypted));\n  return data;\n};\n","import Peer from \"peerjs\";\n\nexport const ROOM_ID_PREFIX_LEN = 32;\n\nexport const isValidPeerId = (\n  roomId: string,\n  peerId: unknown\n): peerId is string =>\n  typeof peerId === \"string\" &&\n  peerId.startsWith(`${roomId.slice(0, ROOM_ID_PREFIX_LEN)} `);\n\nexport const generatePeerId = (roomId: string, peerIndex: number) =>\n  `${roomId.slice(0, ROOM_ID_PREFIX_LEN)} ${peerIndex}`;\n\nexport const getPeerIndexFromPeerId = (peerId: string) =>\n  Number(peerId.split(\" \")[1]);\n\nexport const getPeerIndexFromConn = (conn: Peer.DataConnection) =>\n  getPeerIndexFromPeerId(conn.peer);\n\nexport const createConnectionMap = () => {\n  type Value = {\n    conn: Peer.DataConnection;\n    connected?: boolean;\n    userId?: string;\n    mediaTypes: string[];\n  };\n  const map = new Map<string, Value>();\n\n  const addConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.conn.close();\n    }\n    map.set(conn.peer, { conn, mediaTypes: [] });\n  };\n\n  const markConnected = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.connected = true;\n    }\n  };\n\n  const isConnected = (peerId: string) => {\n    const value = map.get(peerId);\n    return (value && value.connected) || false;\n  };\n\n  const setUserId = (conn: Peer.DataConnection, userId: string) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.userId = userId;\n    }\n  };\n\n  const getUserId = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    return value && value.userId;\n  };\n\n  const setMediaTypes = (conn: Peer.DataConnection, mediaTypes: string[]) => {\n    const value = map.get(conn.peer);\n    if (value) {\n      value.mediaTypes = mediaTypes;\n    }\n  };\n\n  const getMediaTypes = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    return (value && value.mediaTypes) || [];\n  };\n\n  const hasConn = (peerId: string) => map.has(peerId);\n\n  const delConn = (conn: Peer.DataConnection) => {\n    const value = map.get(conn.peer);\n    if (value && value.conn === conn) {\n      map.delete(conn.peer);\n    }\n  };\n\n  const getConnectedPeerIds = () =>\n    Array.from(map.keys()).filter((k) => map.get(k)?.connected);\n\n  const forEachConnectedConns = (\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (value.connected) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const forEachConnsAcceptingMedia = (\n    mediaType: string,\n    callback: (conn: Peer.DataConnection) => void\n  ) => {\n    Array.from(map.values()).forEach((value) => {\n      if (\n        value.connected &&\n        value.mediaTypes &&\n        value.mediaTypes.includes(mediaType)\n      ) {\n        callback(value.conn);\n      }\n    });\n  };\n\n  const clearAll = () => {\n    if (map.size) {\n      console.log(\"connectionMap garbage:\", map);\n    }\n    map.clear();\n  };\n\n  return {\n    addConn,\n    markConnected,\n    isConnected,\n    setUserId,\n    getUserId,\n    setMediaTypes,\n    getMediaTypes,\n    hasConn,\n    delConn,\n    getConnectedPeerIds,\n    forEachConnectedConns,\n    forEachConnsAcceptingMedia,\n    clearAll,\n  };\n};\n","export const extractRoomIdFromLink = (link: string) => {\n  try {\n    const hash = new URL(link).hash.slice(1);\n    const searchParams = new URLSearchParams(hash);\n    return searchParams.get(\"roomId\");\n  } catch (e) {\n    return null;\n  }\n};\n\nexport const getRoomIdFromUrl = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  return searchParams.get(\"roomId\");\n};\n\nexport const setRoomIdToUrl = (roomId: string) => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  searchParams.set(\"roomId\", roomId);\n  window.location.hash = searchParams.toString();\n};\n\nexport const getServerConfigFromUrl = () => {\n  const hash = window.location.hash.slice(1);\n  const searchParams = new URLSearchParams(hash);\n  const server = searchParams.get(\"server\");\n  try {\n    const url = new URL(server || \"\");\n    const secure = url.protocol === \"https:\";\n    const defaultPort = secure ? 443 : 80;\n    return {\n      host: url.host.split(\":\")[0],\n      port: url.port ? Number(url.port) : defaultPort,\n      path: url.pathname,\n      secure,\n    };\n  } catch (e) {\n    // ignore\n  }\n  return null;\n};\n","type StringItemName =\n  | \"nickname\"\n  | \"config_hidden\"\n  | \"faceimage_video_device_id\"\n  | \"faceimage_audio_device_id\";\n\ntype JsonItemName = \"TODO2\" | \"TODO3\";\n\nexport const setStringItem = (name: StringItemName, value: string) => {\n  try {\n    window.localStorage.setItem(name, value);\n  } catch (e) {\n    console.info(\"Failed to save string to localStorage\", e);\n  }\n};\n\nexport const getStringItem = (name: StringItemName) => {\n  try {\n    return window.localStorage.getItem(name) || \"\";\n  } catch (e) {\n    // ignore\n    return \"\";\n  }\n};\n\nexport const setJsonItem = (name: JsonItemName, value: unknown) => {\n  try {\n    window.localStorage.setItem(name, JSON.stringify(value));\n  } catch (e) {\n    console.info(\"Failed to save json to localStorage\", e);\n  }\n};\n\nexport const getJsonItem = (name: JsonItemName): unknown | null => {\n  try {\n    return JSON.parse(window.localStorage.getItem(name) || \"\");\n  } catch (e) {\n    // ignore\n    return null;\n  }\n};\n\nexport const removeItem = (name: StringItemName | JsonItemName) => {\n  try {\n    window.localStorage.removeItem(name);\n  } catch (e) {\n    // ignore\n  }\n};\n","export const sleep = (ms: number) =>\n  new Promise((resolve) => setTimeout(resolve, ms));\n","export const isObject = (x: unknown): x is object =>\n  typeof x === \"object\" && x !== null;\n","import { sleep } from \"../utils/sleep\";\n\nconst setupMap = new WeakMap<MediaStreamTrack, boolean>();\n\n// XXX we don't get \"ended\" event with removeTrack,\n// so a workaround is onmute and transceiver.currentDirection\nexport const setupTrackStopOnLongMute = (\n  track: MediaStreamTrack,\n  pc: RTCPeerConnection\n) => {\n  if (setupMap.has(track)) {\n    return track;\n  }\n  setupMap.set(track, true);\n  const onmute = async () => {\n    await sleep(5000);\n    const transceiver = pc\n      .getTransceivers()\n      .find((t) => t.receiver.track === track);\n    if (\n      transceiver &&\n      (transceiver.currentDirection === \"inactive\" ||\n        transceiver.currentDirection === \"sendonly\")\n    ) {\n      track.stop();\n      // XXX we need to manually dispatch ended event, why?\n      track.dispatchEvent(new Event(\"ended\"));\n    }\n  };\n  track.addEventListener(\"mute\", onmute);\n  return track;\n};\n","import Peer from \"peerjs\";\n\nimport { sleep } from \"../utils/sleep\";\nimport { rand4, encrypt, decrypt } from \"../utils/crypto\";\nimport { getServerConfigFromUrl } from \"../utils/url\";\nimport { isObject } from \"../utils/types\";\nimport {\n  ROOM_ID_PREFIX_LEN,\n  isValidPeerId,\n  generatePeerId,\n  getPeerIndexFromPeerId,\n  getPeerIndexFromConn,\n  createConnectionMap,\n} from \"./peerUtils\";\nimport { setupTrackStopOnLongMute } from \"./trackUtils\";\n\nconst MIN_SEED_PEER_INDEX = 10; // config\nconst MAX_SEED_PEER_INDEX = 14; // config\nconst guessSeed = (id: string) => {\n  const peerIndex = getPeerIndexFromPeerId(id);\n  return MIN_SEED_PEER_INDEX <= peerIndex && peerIndex <= MAX_SEED_PEER_INDEX;\n};\n\nexport type NetworkStatus =\n  | { type: \"CONNECTING_SEED_PEERS\" }\n  | { type: \"NEW_CONNECTION\"; peerIndex: number }\n  | { type: \"CONNECTION_CLOSED\"; peerIndex: number }\n  | { type: \"INITIALIZING_PEER\"; peerIndex: number }\n  | { type: \"RECONNECTING\" }\n  | { type: \"SERVER_ERROR\" }\n  | { type: \"UNKNOWN_ERROR\"; err: Error }\n  | { type: \"CONNECTED_PEERS\"; peerIndexList: number[] };\n\ntype UpdateNetworkStatus = (status: NetworkStatus) => void;\n\nexport type PeerInfo = {\n  userId: string;\n  peerIndex: number;\n  mediaTypes: string[];\n};\ntype ReceiveData = (data: unknown, info: PeerInfo) => void;\ntype ReceiveTrack = (track: MediaStreamTrack, info: PeerInfo) => void;\n\nexport const createRoom = (\n  roomId: string,\n  userId: string,\n  updateNetworkStatus: UpdateNetworkStatus,\n  receiveData: ReceiveData,\n  receiveTrack: ReceiveTrack\n) => {\n  let disposed = false;\n  let myPeer: Peer | null = null;\n  let lastBroadcastData: unknown | null = null;\n  const connMap = createConnectionMap();\n  let mediaTypes: string[] = [];\n  let localStream: MediaStream | null = null;\n\n  const showConnectedStatus = () => {\n    if (disposed) return;\n    const peerIndexList = connMap\n      .getConnectedPeerIds()\n      .map(getPeerIndexFromPeerId);\n    updateNetworkStatus({ type: \"CONNECTED_PEERS\", peerIndexList });\n  };\n\n  const connectPeer = (id: string) => {\n    if (disposed) return;\n    if (!myPeer || myPeer.id === id) return;\n    if (connMap.hasConn(id)) return;\n    console.log(\"connectPeer\", id);\n    const conn = myPeer.connect(id);\n    initConnection(conn);\n  };\n\n  const broadcastData = (data: unknown, replaceLastData?: boolean) => {\n    if (disposed) return;\n    if (replaceLastData) {\n      lastBroadcastData = data;\n    }\n    const peers = connMap.getConnectedPeerIds();\n    connMap.forEachConnectedConns((conn) => {\n      sendPayload(conn, { userId, data, peers, mediaTypes });\n    });\n  };\n\n  const sendSDP = (conn: Peer.DataConnection, sdp: unknown) => {\n    sendPayload(conn, { SDP: sdp });\n  };\n\n  const handlePayloadSDP = async (conn: Peer.DataConnection, sdp: unknown) => {\n    if (!isObject(sdp)) return;\n    if (isObject((sdp as { offer: unknown }).offer)) {\n      const { offer } = sdp as { offer: object };\n      try {\n        await conn.peerConnection.setRemoteDescription(offer as any);\n        syncAllTracks(conn);\n        const answer = await conn.peerConnection.createAnswer();\n        await conn.peerConnection.setLocalDescription(answer);\n        sendSDP(conn, { answer });\n      } catch (e) {\n        console.info(\"handleSDP offer failed\", e);\n      }\n    } else if (isObject((sdp as { answer: unknown }).answer)) {\n      const { answer } = sdp as { answer: object };\n      try {\n        await conn.peerConnection.setRemoteDescription(answer as any);\n      } catch (e) {\n        console.info(\"handleSDP answer failed\", e);\n        await sleep(Math.random() * 30 * 1000);\n        removeAllTracks(conn);\n        syncAllTracks(conn);\n      }\n    } else {\n      console.warn(\"unknown SDP\", sdp);\n    }\n  };\n\n  const handlePayloadUserId = (\n    conn: Peer.DataConnection,\n    payloadUserId: unknown\n  ) => {\n    if (typeof payloadUserId === \"string\") {\n      connMap.setUserId(conn, payloadUserId as string);\n    }\n  };\n\n  const handlePayloadMediaTypes = async (\n    conn: Peer.DataConnection,\n    payloadMediaTypes: unknown\n  ) => {\n    if (\n      Array.isArray(payloadMediaTypes) &&\n      payloadMediaTypes.every((x) => typeof x === \"string\")\n    ) {\n      connMap.setMediaTypes(conn, payloadMediaTypes as string[]);\n      await sleep(5000);\n      syncAllTracks(conn);\n    }\n  };\n\n  const handlePayloadPeers = (peers: unknown) => {\n    if (Array.isArray(peers)) {\n      peers.forEach((peer) => {\n        if (isValidPeerId(roomId, peer)) {\n          connectPeer(peer);\n        }\n      });\n    }\n  };\n\n  const handlePayloadData = (conn: Peer.DataConnection, data: unknown) => {\n    const connUserId = connMap.getUserId(conn);\n    if (connUserId) {\n      const info: PeerInfo = {\n        userId: connUserId,\n        peerIndex: getPeerIndexFromConn(conn),\n        mediaTypes: connMap.getMediaTypes(conn),\n      };\n      try {\n        receiveData(data, info);\n      } catch (e) {\n        console.warn(\"receiveData\", e);\n      }\n    }\n  };\n\n  const handlePayload = async (\n    conn: Peer.DataConnection,\n    encrypted: ArrayBuffer\n  ) => {\n    if (disposed) return;\n    try {\n      const payload = JSON.parse(\n        await decrypt(encrypted, roomId.slice(ROOM_ID_PREFIX_LEN))\n      );\n      console.log(\"decrypted payload\", conn.peer, payload);\n      if (!isObject(payload)) return;\n\n      handlePayloadSDP(conn, (payload as { SDP?: unknown }).SDP);\n      handlePayloadUserId(conn, (payload as { userId?: unknown }).userId);\n      handlePayloadMediaTypes(\n        conn,\n        (payload as { mediaTypes?: unknown }).mediaTypes\n      );\n      handlePayloadPeers((payload as { peers?: unknown }).peers);\n      handlePayloadData(conn, (payload as { data?: unknown }).data);\n    } catch (e) {\n      console.info(\"Error in handlePayload\", e, encrypted);\n    }\n  };\n\n  const sendPayload = async (conn: Peer.DataConnection, payload: unknown) => {\n    try {\n      const encrypted = await encrypt(\n        JSON.stringify(payload),\n        roomId.slice(ROOM_ID_PREFIX_LEN)\n      );\n      conn.send(encrypted);\n    } catch (e) {\n      console.error(\"sendPayload\", e);\n    }\n  };\n\n  const initConnection = (conn: Peer.DataConnection) => {\n    if (connMap.isConnected(conn.peer)) {\n      conn.close();\n      return;\n    }\n    connMap.addConn(conn);\n    conn.on(\"open\", () => {\n      connMap.markConnected(conn);\n      console.log(\"dataConnection open\", conn);\n      showConnectedStatus();\n      if (lastBroadcastData) {\n        const data = lastBroadcastData;\n        const peers = connMap.getConnectedPeerIds();\n        sendPayload(conn, { userId, data, peers, mediaTypes });\n      }\n    });\n    conn.on(\"data\", (buf: ArrayBuffer) => handlePayload(conn, buf));\n    conn.peerConnection.addEventListener(\"icegatheringstatechange\", () => {\n      const pc = conn.peerConnection;\n      if (pc.iceGatheringState === \"complete\") {\n        pc.onicecandidate = () => undefined;\n      }\n    });\n    const scheduledNegotiation = new WeakMap<Peer.DataConnection, boolean>();\n    conn.peerConnection.addEventListener(\"negotiationneeded\", async () => {\n      if (scheduledNegotiation.has(conn)) return;\n      scheduledNegotiation.set(conn, true);\n      await sleep(2000);\n      scheduledNegotiation.delete(conn);\n      if (!connMap.isConnected(conn.peer)) return;\n      const offer = await conn.peerConnection.createOffer();\n      await conn.peerConnection.setLocalDescription(offer);\n      sendSDP(conn, { offer });\n    });\n    conn.peerConnection.addEventListener(\"track\", (event: RTCTrackEvent) => {\n      const connUserId = connMap.getUserId(conn);\n      if (connUserId) {\n        const info: PeerInfo = {\n          userId: connUserId,\n          peerIndex: getPeerIndexFromPeerId(conn.peer),\n          mediaTypes: connMap.getMediaTypes(conn),\n        };\n        receiveTrack(\n          setupTrackStopOnLongMute(event.track, conn.peerConnection),\n          info\n        );\n      }\n    });\n    conn.on(\"close\", () => {\n      connMap.delConn(conn);\n      console.log(\"dataConnection closed\", conn);\n      updateNetworkStatus({\n        type: \"CONNECTION_CLOSED\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      showConnectedStatus();\n      if (connMap.getConnectedPeerIds().length === 0) {\n        reInitMyPeer(true);\n      } else if (\n        guessSeed(conn.peer) &&\n        myPeer &&\n        !myPeer.disconnected &&\n        !guessSeed(myPeer.id)\n      ) {\n        const waitSec = 30 + Math.floor(Math.random() * 60);\n        console.log(\n          `Disconnected seed peer: ${getPeerIndexFromPeerId(\n            conn.peer\n          )}, reinit in ${waitSec}sec...`\n        );\n        setTimeout(reInitMyPeer, waitSec * 1000);\n      }\n    });\n  };\n\n  const initMyPeer = (index = MIN_SEED_PEER_INDEX) => {\n    if (disposed) return;\n    if (myPeer) return;\n    connMap.clearAll();\n    const isSeed = MIN_SEED_PEER_INDEX <= index && index <= MAX_SEED_PEER_INDEX;\n    const peerIndex = isSeed ? index : rand4();\n    updateNetworkStatus({ type: \"INITIALIZING_PEER\", peerIndex });\n    const id = generatePeerId(roomId, peerIndex);\n    console.log(\"initMyPeer start\", index, id);\n    const peer = new Peer(id, {\n      ...(getServerConfigFromUrl() || {}),\n      debug: 3,\n    });\n    myPeer = peer;\n    peer.on(\"open\", () => {\n      myPeer = peer;\n      if (process.env.NODE_ENV !== \"production\") {\n        (window as any).myPeer = myPeer;\n      }\n      updateNetworkStatus({ type: \"CONNECTING_SEED_PEERS\" });\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const seedId = generatePeerId(roomId, i);\n        connectPeer(seedId);\n      }\n    });\n    peer.on(\"error\", (err) => {\n      if (err.type === \"unavailable-id\") {\n        myPeer = null;\n        peer.destroy();\n        initMyPeer(index + 1);\n      } else if (err.type === \"peer-unavailable\") {\n        // ignore\n      } else if (err.type === \"disconnected\") {\n        console.log(\"initMyPeer disconnected error\", index, err);\n        peer.destroy();\n      } else if (err.type === \"network\") {\n        console.log(\"initMyPeer network error\", index, err);\n      } else if (err.type === \"server-error\") {\n        console.log(\"initMyPeer server error\", index, err);\n        updateNetworkStatus({ type: \"SERVER_ERROR\" });\n      } else {\n        console.error(\"initMyPeer unknown error\", index, err.type, err);\n        updateNetworkStatus({ type: \"UNKNOWN_ERROR\", err });\n      }\n    });\n    peer.on(\"connection\", (conn) => {\n      if (myPeer !== peer) {\n        conn.close();\n        return;\n      }\n      console.log(\"new connection received\", conn);\n      updateNetworkStatus({\n        type: \"NEW_CONNECTION\",\n        peerIndex: getPeerIndexFromConn(conn),\n      });\n      initConnection(conn);\n    });\n    peer.on(\"disconnected\", () => {\n      console.log(\"initMyPeer disconnected\", index);\n      setTimeout(() => {\n        if (myPeer === peer && !peer.destroyed) {\n          console.log(\"initMyPeer reconnecting\", index);\n          updateNetworkStatus({ type: \"RECONNECTING\" });\n          peer.reconnect();\n        }\n      }, 5 * 1000);\n    });\n    peer.on(\"close\", () => {\n      if (myPeer === peer) {\n        console.log(\"initMyPeer closed, re-initializing\", index);\n        myPeer = null;\n        setTimeout(initMyPeer, 20 * 1000);\n      } else {\n        console.log(\"initMyPeer closed, ignoring\", index);\n      }\n    });\n  };\n  initMyPeer();\n\n  const reInitMyPeer = (force?: boolean) => {\n    if (!myPeer) return;\n    if (myPeer.disconnected) return; // should already be handled\n    if (!force) {\n      if (guessSeed(myPeer.id)) return;\n      let existsAllSeeds = true;\n      for (let i = MIN_SEED_PEER_INDEX; i <= MAX_SEED_PEER_INDEX; i += 1) {\n        const id = generatePeerId(roomId, i);\n        if (!connMap.isConnected(id)) {\n          existsAllSeeds = false;\n          break;\n        }\n      }\n      if (existsAllSeeds) {\n        showConnectedStatus();\n        return;\n      }\n    }\n    const oldPeer = myPeer;\n    myPeer = null;\n    oldPeer.destroy();\n    initMyPeer();\n  };\n\n  const acceptMediaTypes = (mTypes: string[]) => {\n    mediaTypes = mTypes;\n    if (mediaTypes.length) {\n      if (!localStream) {\n        localStream = new MediaStream();\n        connMap.forEachConnectedConns((conn) => {\n          const connUserId = connMap.getUserId(conn);\n          if (connUserId) {\n            const info: PeerInfo = {\n              userId: connUserId,\n              peerIndex: getPeerIndexFromPeerId(conn.peer),\n              mediaTypes: connMap.getMediaTypes(conn),\n            };\n            conn.peerConnection.getReceivers().forEach((receiver) => {\n              receiveTrack(\n                setupTrackStopOnLongMute(receiver.track, conn.peerConnection),\n                info\n              );\n            });\n          }\n        });\n      }\n    } else {\n      localStream = null;\n    }\n    broadcastData(null);\n  };\n\n  const trackMediaTypeMap = new WeakMap<MediaStreamTrack, string>();\n\n  const addTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (!localStream) return;\n    trackMediaTypeMap.set(track, mediaType);\n    localStream.addTrack(track);\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      try {\n        if (!localStream) return;\n        conn.peerConnection.addTrack(track, localStream);\n      } catch (e) {\n        if (e.name === \"InvalidAccessError\") {\n          // ignore\n        } else {\n          throw e;\n        }\n      }\n    });\n  };\n\n  const removeTrack = (mediaType: string, track: MediaStreamTrack) => {\n    if (localStream) {\n      localStream.removeTrack(track);\n    }\n    connMap.forEachConnsAcceptingMedia(mediaType, (conn) => {\n      const senders = conn.peerConnection.getSenders();\n      const sender = senders.find((s) => s.track === track);\n      if (sender) {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const syncAllTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection.getSenders();\n    const mTypes = connMap.getMediaTypes(conn);\n    if (localStream) {\n      localStream.getTracks().forEach((track) => {\n        const mType = trackMediaTypeMap.get(track);\n        if (\n          localStream &&\n          mType &&\n          mTypes.includes(mType) &&\n          senders.every((sender) => sender.track !== track)\n        ) {\n          conn.peerConnection.addTrack(track, localStream);\n        }\n      });\n    }\n    senders.forEach((sender) => {\n      if (sender.track) {\n        const mType = trackMediaTypeMap.get(sender.track);\n        if (!mType || !mTypes.includes(mType)) {\n          conn.peerConnection.removeTrack(sender);\n        }\n      }\n    });\n    if (senders.some((sender) => sender.track && !sender.transport)) {\n      conn.peerConnection.dispatchEvent(new Event(\"negotiationneeded\"));\n    }\n  };\n\n  const removeAllTracks = (conn: Peer.DataConnection) => {\n    const senders = conn.peerConnection.getSenders();\n    senders.forEach((sender) => {\n      if (sender.track) {\n        conn.peerConnection.removeTrack(sender);\n      }\n    });\n  };\n\n  const dispose = () => {\n    disposed = true;\n    if (myPeer) {\n      myPeer.destroy();\n    }\n  };\n\n  return {\n    broadcastData,\n    acceptMediaTypes,\n    addTrack,\n    removeTrack,\n    dispose,\n  };\n};\n","import { useEffect, useState, useCallback, useRef } from \"react\";\n\nimport { PeerInfo, createRoom, NetworkStatus } from \"../network/room\";\n\ntype NetworkStatusListener = (status: NetworkStatus) => void;\ntype DataListener = (data: unknown, info: PeerInfo) => void;\ntype TrackListener = {\n  mediaType: string;\n  listener: (track: MediaStreamTrack, info: PeerInfo) => void;\n};\ntype RoomEntry = {\n  room: ReturnType<typeof createRoom>;\n  networkStatusListeners: Set<NetworkStatusListener>;\n  dataListeners: Set<DataListener>;\n  trackListeners: Set<TrackListener>;\n  count: number;\n};\nconst roomEntryMap = new Map<string, RoomEntry>();\nconst register = (\n  roomId: string,\n  userId: string,\n  networkStatusListener?: NetworkStatusListener,\n  dataListener?: DataListener,\n  trackListener?: TrackListener\n) => {\n  const roomEntryKey = `${roomId}_${userId}`;\n  let entry = roomEntryMap.get(roomEntryKey);\n  if (!entry) {\n    const networkStatusListeners = new Set<NetworkStatusListener>();\n    const dataListeners = new Set<DataListener>();\n    const trackListeners = new Set<TrackListener>();\n    const updateNetworkStatus = (status: NetworkStatus) => {\n      networkStatusListeners.forEach((listener) => {\n        listener(status);\n      });\n    };\n    const receiveData = (data: unknown, info: PeerInfo) => {\n      dataListeners.forEach((listener) => {\n        listener(data, info);\n      });\n    };\n    const receiveTrack = (track: MediaStreamTrack, info: PeerInfo) => {\n      trackListeners.forEach(({ listener }) => {\n        listener(track, info);\n      });\n    };\n    const room = createRoom(\n      roomId,\n      userId,\n      updateNetworkStatus,\n      receiveData,\n      receiveTrack\n    );\n    entry = {\n      room,\n      networkStatusListeners,\n      dataListeners,\n      trackListeners,\n      count: 0,\n    };\n    roomEntryMap.set(roomEntryKey, entry);\n  }\n  if (networkStatusListener) {\n    entry.networkStatusListeners.add(networkStatusListener);\n  }\n  if (dataListener) {\n    entry.dataListeners.add(dataListener);\n  }\n  if (trackListener) {\n    const mediaTypeSet = new Set(\n      Array.from(entry.trackListeners).map((x) => x.mediaType)\n    );\n    const prevSize = mediaTypeSet.size;\n    entry.trackListeners.add(trackListener);\n    mediaTypeSet.add(trackListener.mediaType);\n    if (prevSize !== mediaTypeSet.size) {\n      entry.room.acceptMediaTypes(Array.from(mediaTypeSet));\n    }\n  }\n  entry.count += 1;\n  const definedEntry = entry;\n  const unregister = () => {\n    if (networkStatusListener) {\n      definedEntry.networkStatusListeners.delete(networkStatusListener);\n    }\n    if (dataListener) {\n      definedEntry.dataListeners.delete(dataListener);\n    }\n    if (trackListener) {\n      let mediaTypeSet = new Set(\n        Array.from(definedEntry.trackListeners).map((x) => x.mediaType)\n      );\n      const prevSize = mediaTypeSet.size;\n      definedEntry.trackListeners.delete(trackListener);\n      mediaTypeSet = new Set(\n        Array.from(definedEntry.trackListeners).map((x) => x.mediaType)\n      );\n      if (prevSize !== mediaTypeSet.size) {\n        definedEntry.room.acceptMediaTypes(Array.from(mediaTypeSet));\n      }\n    }\n    definedEntry.count -= 1;\n    if (definedEntry.count <= 0) {\n      definedEntry.room.dispose();\n      roomEntryMap.delete(roomEntryKey);\n    }\n  };\n  return {\n    broadcastData: entry.room.broadcastData,\n    addTrack: entry.room.addTrack,\n    removeTrack: entry.room.removeTrack,\n    unregister,\n  };\n};\n\nexport const useRoomNetworkStatus = (\n  roomId: string,\n  userId: string,\n  onNetworkStatus?: (networkStatus: NetworkStatus) => void\n) => {\n  const [networkStatus, updateNetworkStatus] = useState<NetworkStatus>();\n  if (networkStatus && networkStatus.type === \"UNKNOWN_ERROR\") {\n    throw new Error(`Network Error: ${networkStatus.err.message}`);\n  }\n  useEffect(() => {\n    const { unregister } = register(roomId, userId, (ns: NetworkStatus) => {\n      updateNetworkStatus(ns);\n      if (onNetworkStatus) onNetworkStatus(ns);\n    });\n    return unregister;\n  }, [roomId, userId, onNetworkStatus]);\n  return networkStatus;\n};\n\ntype BroadcastData = ReturnType<typeof createRoom>[\"broadcastData\"];\n\nexport const useBroadcastData = (roomId: string, userId: string) => {\n  const broadcastDataRef = useRef<BroadcastData>();\n  const broadcastData = useCallback((...args: Parameters<BroadcastData>) => {\n    if (broadcastDataRef.current) {\n      broadcastDataRef.current(...args);\n    } else {\n      // TODO pending queue\n    }\n  }, []);\n  useEffect(() => {\n    const registered = register(roomId, userId);\n    broadcastDataRef.current = registered.broadcastData;\n    return registered.unregister;\n  }, [roomId, userId]);\n  return broadcastData;\n};\n\nexport const useRoomData = (\n  roomId: string,\n  userId: string,\n  onRoomData: (data: unknown, info: PeerInfo) => void\n) => {\n  useEffect(() => {\n    const { unregister } = register(roomId, userId, undefined, onRoomData);\n    return unregister;\n  }, [roomId, userId, onRoomData]);\n};\n\nexport const useRoomMedia = (\n  roomId: string,\n  userId: string,\n  onTrack: (track: MediaStreamTrack, info: PeerInfo) => void,\n  mediaType?: string\n) => {\n  const [functions, setFunctions] = useState<{\n    addTrack?: (track: MediaStreamTrack) => void;\n    removeTrack?: (track: MediaStreamTrack) => void;\n  }>({});\n  useEffect(() => {\n    if (mediaType) {\n      const result = register(roomId, userId, undefined, undefined, {\n        mediaType,\n        listener: onTrack,\n      });\n      setFunctions({\n        addTrack: (track: MediaStreamTrack) =>\n          result.addTrack(mediaType, track),\n        removeTrack: (track: MediaStreamTrack) =>\n          result.removeTrack(mediaType, track),\n      });\n      return () => {\n        setFunctions({});\n        result.unregister();\n      };\n    }\n    return undefined;\n  }, [roomId, userId, onTrack, mediaType]);\n  return functions;\n};\n","import { useCallback, useState } from \"react\";\n\nimport { isObject } from \"../utils/types\";\nimport { useRoomData } from \"./useRoom\";\n\ntype Entry = {\n  roomId: string;\n  userId: string;\n  nickname: string;\n  lastUpdated: number;\n};\nconst cache: Entry[] = [];\nconst TTL = 10 * 60 * 1000; // 10min\n\nconst createMapFromCache = (roomId: string) => {\n  const map: { [userId: string]: string } = {};\n  cache.forEach((entry) => {\n    if (entry.roomId === roomId) {\n      map[entry.userId] = entry.nickname;\n    }\n  });\n  return map;\n};\n\nconst hasInfoNickname = (x: unknown): x is { info: { nickname: string } } =>\n  isObject(x) &&\n  isObject((x as { info: unknown }).info) &&\n  typeof (x as { info: { nickname: unknown } }).info.nickname === \"string\";\n\nexport const useNicknameMap = (roomId: string, userId: string) => {\n  const [nicknameMap, setNicknameMap] = useState<{\n    [userId: string]: string;\n  }>(() => createMapFromCache(roomId));\n  useRoomData(\n    roomId,\n    userId,\n    useCallback(\n      (data, info) => {\n        if (!hasInfoNickname(data)) return;\n        const index = cache.findIndex(\n          (entry) => entry.roomId === roomId && entry.userId === info.userId\n        );\n        const now = Date.now();\n        if (index >= 0) {\n          if (cache[index].nickname !== data.info.nickname) {\n            cache[index].nickname = data.info.nickname;\n          }\n          cache[index].lastUpdated = now;\n        } else {\n          cache.push({\n            roomId,\n            userId: info.userId,\n            nickname: data.info.nickname,\n            lastUpdated: now,\n          });\n        }\n        for (let i = cache.length - 1; i >= 0; i -= 1) {\n          if (cache[i].lastUpdated + TTL < now) {\n            cache.splice(i, 1);\n          }\n        }\n        setNicknameMap((prev) => {\n          const map = createMapFromCache(roomId);\n          const keys = Object.keys(map);\n          if (\n            keys.length === Object.keys(prev).length &&\n            keys.every((key) => map[key] === prev[key])\n          ) {\n            return prev;\n          }\n          return map;\n        });\n      },\n      [roomId]\n    )\n  );\n  return nicknameMap;\n};\n","type DeviceInfo = {\n  label: string;\n  deviceId: string;\n};\n\nexport const getVideoDeviceInfoList = async () => {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const list: DeviceInfo[] = devices\n      .filter(({ kind }) => kind === \"videoinput\")\n      .map(({ label, deviceId }) => ({ label, deviceId }));\n    return list;\n  } catch (e) {\n    // ignored\n    return [];\n  }\n};\n\nexport const getAudioDeviceInfoList = async () => {\n  try {\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const list: DeviceInfo[] = devices\n      .filter(({ kind }) => kind === \"audioinput\")\n      .map(({ label, deviceId }) => ({ label, deviceId }));\n    return list;\n  } catch (e) {\n    // ignored\n    return [];\n  }\n};\n","import { useEffect, useState } from \"react\";\n\nimport {\n  getVideoDeviceInfoList,\n  getAudioDeviceInfoList,\n} from \"../media/devices\";\n\ntype VideoDeviceInfoList = ReturnType<\n  typeof getVideoDeviceInfoList\n> extends Promise<infer T>\n  ? T\n  : never;\n\nexport const useVideoDevices = () => {\n  const [devices, setDevices] = useState<VideoDeviceInfoList>([]);\n  useEffect(() => {\n    (async () => {\n      const deviceInfoList = await getVideoDeviceInfoList();\n      setDevices(deviceInfoList);\n    })();\n  }, []);\n  return devices;\n};\n\ntype AudioDeviceInfoList = ReturnType<\n  typeof getAudioDeviceInfoList\n> extends Promise<infer T>\n  ? T\n  : never;\n\nexport const useAudioDevices = () => {\n  const [devices, setDevices] = useState<AudioDeviceInfoList>([]);\n  useEffect(() => {\n    (async () => {\n      const deviceInfoList = await getAudioDeviceInfoList();\n      setDevices(deviceInfoList);\n    })();\n  }, []);\n  return devices;\n};\n","import { sleep } from \"../utils/sleep\";\n\nconst captureImage = async (stream: MediaStream, track: MediaStreamTrack) => {\n  if (typeof ImageCapture !== \"undefined\") {\n    const imageCapture = new ImageCapture(track);\n    await sleep(2000);\n    let srcImg;\n    try {\n      const blob = await imageCapture.takePhoto();\n      srcImg = await createImageBitmap(blob);\n    } catch (e) {\n      srcImg = await imageCapture.grabFrame();\n    }\n    const srcW = srcImg.width;\n    const srcH = srcImg.height;\n    return { srcImg, srcW, srcH };\n  }\n  const video = document.getElementById(\"internal-video\") as HTMLVideoElement;\n  video.style.display = \"block\";\n  const savedSrcObject = video.srcObject;\n  const revert = () => {\n    video.srcObject = savedSrcObject;\n  };\n  video.srcObject = stream;\n  await sleep(2000);\n  const srcImg = video;\n  const srcW = video.videoWidth;\n  const srcH = video.videoHeight;\n  return { srcImg, srcW, srcH, revert };\n};\n\nexport const takePhoto = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        video: { deviceId },\n      }\n    : { video: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const [track] = stream.getVideoTracks();\n  const canvas = document.getElementById(\n    \"internal-canvas\"\n  ) as HTMLCanvasElement;\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const dstW = 72;\n  const dstH = 72;\n  canvas.width = dstW;\n  canvas.height = dstH;\n  const { srcImg, srcW, srcH, revert } = await captureImage(stream, track);\n  const ratio = Math.max(dstW / srcW, dstH / srcH);\n  const width = Math.min(srcW, dstW / ratio);\n  const height = Math.min(srcH, dstH / ratio);\n  const x = (srcW - width) / 2;\n  const y = (srcH - height) / 2;\n  ctx.drawImage(srcImg, x, y, width, height, 0, 0, dstW, dstH);\n  if (revert) {\n    revert();\n  }\n  track.stop();\n  return canvas.toDataURL(\"image/jpeg\");\n};\n","import { useCallback, useEffect, useState } from \"react\";\n\nimport { isObject } from \"../utils/types\";\nimport { takePhoto } from \"../media/capture\";\nimport { useRoomData, useBroadcastData, useRoomNetworkStatus } from \"./useRoom\";\n\ntype ImageUrl = string;\ntype FaceInfo = {\n  nickname: string;\n  message: string;\n  liveMode: boolean;\n};\ntype ImageData = {\n  image: ImageUrl;\n  info: FaceInfo;\n};\ntype RoomImage = ImageData & {\n  userId: string;\n  received: number; // in milliseconds\n  obsoleted: boolean;\n  peerIndex: number;\n};\n\nconst isFaceInfo = (x: unknown): x is FaceInfo =>\n  isObject(x) &&\n  typeof (x as { nickname: unknown }).nickname === \"string\" &&\n  typeof (x as { message: unknown }).message === \"string\" &&\n  typeof (x as { liveMode: unknown }).liveMode === \"boolean\";\n\nconst isImageData = (x: unknown): x is ImageData =>\n  isObject(x) &&\n  typeof (x as { image: unknown }).image === \"string\" &&\n  isFaceInfo((x as { info: unknown }).info);\n\nexport const useFaceImages = (\n  roomId: string,\n  userId: string,\n  nickname: string,\n  statusMesg: string,\n  liveMode: boolean,\n  deviceId?: string\n) => {\n  const [myImage, setMyImage] = useState<ImageUrl>();\n  const [roomImages, setRoomImages] = useState<RoomImage[]>([]);\n  const [fatalError, setFatalError] = useState<Error>();\n\n  if (fatalError) {\n    throw fatalError;\n  }\n\n  const broadcastData = useBroadcastData(roomId, userId);\n  useRoomData(\n    roomId,\n    userId,\n    useCallback((data, info) => {\n      if (!isImageData(data)) return;\n      const roomImage = {\n        ...data,\n        userId: info.userId,\n        received: Date.now(),\n        obsoleted: false,\n        peerIndex: info.peerIndex,\n      };\n      setRoomImages((prev) => {\n        const found = prev.find((item) => item.userId === roomImage.userId);\n        if (!found) {\n          return [...prev, roomImage];\n        }\n        return prev.map((item) =>\n          item.userId === roomImage.userId ? roomImage : item\n        );\n      });\n    }, [])\n  );\n\n  useRoomNetworkStatus(\n    roomId,\n    userId,\n    useCallback((networkStatus) => {\n      if (networkStatus && networkStatus.type === \"CONNECTION_CLOSED\") {\n        const { peerIndex } = networkStatus;\n        setRoomImages((prev) => {\n          let changed = false;\n          const next = prev.map((item) => {\n            if (item.peerIndex === peerIndex) {\n              changed = true;\n              return { ...item, obsoleted: true };\n            }\n            return item;\n          });\n          return changed ? next : prev;\n        });\n      }\n    }, [])\n  );\n\n  useEffect(() => {\n    const checkObsoletedImage = () => {\n      const twoMinAgo = Date.now() - 2 * 60 * 1000;\n      const tenMinAgo = Date.now() - 10 * 60 * 1000;\n      setRoomImages((prev) => {\n        let changed = false;\n        const next = prev\n          .map((item) => {\n            if (item.received < twoMinAgo && !item.obsoleted) {\n              changed = true;\n              return { ...item, obsoleted: true };\n            }\n            if (item.received < tenMinAgo && item.obsoleted) {\n              changed = true;\n              return null;\n            }\n            return item;\n          })\n          .filter((item) => item) as typeof prev;\n\n        return changed ? next : prev;\n      });\n    };\n    let timer: NodeJS.Timeout;\n    const loop = async () => {\n      try {\n        checkObsoletedImage();\n        const image = await takePhoto(deviceId);\n        setMyImage(image);\n        const info: FaceInfo = { nickname, message: statusMesg, liveMode };\n        const data: ImageData = {\n          image,\n          info,\n        };\n        broadcastData(data, true);\n      } catch (e) {\n        setFatalError(e);\n      }\n      timer = setTimeout(loop, 2 * 60 * 1000);\n    };\n    loop();\n    return () => {\n      clearTimeout(timer);\n    };\n  }, [roomId, userId, deviceId, nickname, statusMesg, liveMode, broadcastData]);\n\n  return {\n    myImage,\n    roomImages,\n  };\n};\n","import { sleep } from \"../utils/sleep\";\n\nexport const getVideoStream = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        video: { deviceId },\n      }\n    : { video: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const [track] = stream.getVideoTracks();\n  const dispose = () => {\n    track.stop();\n  };\n  return {\n    stream,\n    dispose,\n  };\n};\n\nexport const getFaceVideoStream = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        video: { deviceId },\n      }\n    : { video: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const [track] = stream.getVideoTracks();\n  const video = document.getElementById(\"internal-video\") as HTMLVideoElement;\n  video.style.display = \"block\";\n  video.srcObject = stream;\n  await sleep(1000);\n  const srcW = video.videoWidth;\n  const srcH = video.videoHeight;\n  const canvas = document.getElementById(\n    \"internal-canvas\"\n  ) as HTMLCanvasElement;\n  const ctx = canvas.getContext(\"2d\") as CanvasRenderingContext2D;\n  const dstW = 72;\n  const dstH = 72;\n  canvas.width = dstW;\n  canvas.height = dstH;\n  const ratio = Math.max(dstW / srcW, dstH / srcH);\n  const width = Math.min(srcW, dstW / ratio);\n  const height = Math.min(srcH, dstH / ratio);\n  const x = (srcW - width) / 2;\n  const y = (srcH - height) / 2;\n  let timer: NodeJS.Timeout;\n  const loop = () => {\n    ctx.drawImage(video, x, y, width, height, 0, 0, dstW, dstH);\n    timer = setTimeout(loop, 1000 / 15);\n  };\n  loop();\n  const canvasStream = (canvas as any).captureStream() as MediaStream;\n  const dispose = () => {\n    video.style.display = \"none\";\n    clearTimeout(timer);\n    track.stop();\n    canvasStream.getVideoTracks()[0].stop();\n  };\n  return {\n    stream: canvasStream,\n    dispose,\n  };\n};\n\nconst checkVideTrackFaceSize = async (track: MediaStreamTrack) => {\n  try {\n    const video = document.createElement(\"video\");\n    video.srcObject = new MediaStream([track]);\n    for (let i = 0; i < 50; i += 1) {\n      // eslint-disable-next-line no-await-in-loop\n      await sleep(100);\n      const width = video.videoWidth;\n      const height = video.videoHeight;\n      if (width > 0 && height > 0) {\n        return width === 72 && height === 72;\n      }\n    }\n    return true; // fallback to true\n  } catch (e) {\n    return true; // fallback to true\n  }\n};\n\nconst videoTrackFaceSizeMap = new WeakMap<MediaStreamTrack, Promise<boolean>>();\n\nexport const isVideoTrackFaceSize = (track: MediaStreamTrack) => {\n  if (videoTrackFaceSizeMap.has(track)) {\n    return videoTrackFaceSizeMap.get(track) as Promise<boolean>;\n  }\n  const promise = checkVideTrackFaceSize(track);\n  videoTrackFaceSizeMap.set(track, promise);\n  return promise;\n};\n","export const getAudioStream = async (deviceId?: string) => {\n  const constraints = deviceId\n    ? {\n        audio: { deviceId },\n      }\n    : { audio: true };\n  const stream = await navigator.mediaDevices.getUserMedia(constraints);\n  const [track] = stream.getAudioTracks();\n  await track.applyConstraints({\n    echoCancellation: true,\n    echoCancellationType: { ideal: \"system\" },\n    noiseSuppression: { ideal: true },\n  } as MediaTrackConstraints);\n  const dispose = () => {\n    track.stop();\n  };\n  return {\n    stream,\n    dispose,\n  };\n};\n","import { useCallback, useEffect, useState, useRef } from \"react\";\n\nimport { getFaceVideoStream, isVideoTrackFaceSize } from \"../media/video\";\nimport { getAudioStream } from \"../media/audio\";\nimport { useRoomMedia } from \"./useRoom\";\n\nconst addTrackToStream = (\n  track: MediaStreamTrack,\n  stream: MediaStream | null,\n  disposeStream: () => void\n) => {\n  const newStream = stream || new MediaStream();\n  newStream.addTrack(track);\n  track.addEventListener(\"ended\", () => {\n    newStream.removeTrack(track);\n    if (newStream.getTracks().length === 0) {\n      disposeStream();\n    }\n  });\n  return newStream;\n};\n\nexport const useFaceVideos = (\n  roomId: string,\n  userId: string,\n  videoEnabled: boolean,\n  audioEnabled: boolean,\n  micOn: boolean,\n  videoDeviceId?: string,\n  audioDeviceId?: string\n) => {\n  const [faceStream, setFaceStream] = useState<MediaStream | null>(null);\n  const [faceStreamMap, setFaceStreamMap] = useState<{\n    [userId: string]: MediaStream;\n  }>({});\n\n  const isMounted = useRef(true);\n  useEffect(() => {\n    isMounted.current = false;\n  }, []);\n\n  const onTrack = useCallback(async (track, info) => {\n    if (track.kind === \"video\" && !(await isVideoTrackFaceSize(track))) {\n      return;\n    }\n    const disposeStream = () => {\n      if (isMounted.current) {\n        setFaceStreamMap((prev) => {\n          const { [info.userId]: _, ...rest } = prev;\n          return rest;\n        });\n      }\n    };\n    setFaceStreamMap((prev) => {\n      const stream = prev[info.userId];\n      const newStream = addTrackToStream(track, stream, disposeStream);\n      if (stream === newStream) {\n        return prev;\n      }\n      return { ...prev, [info.userId]: newStream };\n    });\n  }, []);\n\n  const {\n    addTrack: addVideoTrack,\n    removeTrack: removeVideoTrack,\n  } = useRoomMedia(\n    roomId,\n    userId,\n    onTrack,\n    videoEnabled ? \"faceVideo\" : undefined\n  );\n\n  const {\n    addTrack: addAudioTrack,\n    removeTrack: removeAudioTrack,\n  } = useRoomMedia(\n    roomId,\n    userId,\n    onTrack,\n    audioEnabled ? \"faceAudio\" : undefined\n  );\n\n  useEffect(() => {\n    let dispose: (() => void) | null = null;\n    if (videoEnabled && addVideoTrack && removeVideoTrack) {\n      (async () => {\n        const {\n          stream: videoStream,\n          dispose: disposeVideo,\n        } = await getFaceVideoStream(videoDeviceId);\n        const [videoTrack] = videoStream.getVideoTracks();\n        addVideoTrack(videoTrack);\n        const disposeStream = () => {\n          if (isMounted.current) {\n            setFaceStream(null);\n          }\n        };\n        setFaceStream((prev) =>\n          addTrackToStream(videoTrack, prev, disposeStream)\n        );\n        dispose = () => {\n          removeVideoTrack(videoTrack);\n          disposeVideo();\n          // XXX we need to manually dispatch ended event, why?\n          videoTrack.dispatchEvent(new Event(\"ended\"));\n        };\n      })();\n    }\n    return () => {\n      if (dispose) dispose();\n    };\n  }, [roomId, videoEnabled, videoDeviceId, addVideoTrack, removeVideoTrack]);\n\n  useEffect(() => {\n    let dispose: (() => void) | null = null;\n    if (audioEnabled && addAudioTrack && removeAudioTrack) {\n      (async () => {\n        const {\n          stream: audioStream,\n          dispose: disposeAudio,\n        } = await getAudioStream(audioDeviceId);\n        const [audioTrack] = audioStream.getAudioTracks();\n        addAudioTrack(audioTrack);\n        const disposeStream = () => {\n          if (isMounted.current) {\n            setFaceStream(null);\n          }\n        };\n        setFaceStream((prev) =>\n          addTrackToStream(audioTrack, prev, disposeStream)\n        );\n        dispose = () => {\n          removeAudioTrack(audioTrack);\n          disposeAudio();\n          // XXX we need to manually dispatch ended event, why?\n          audioTrack.dispatchEvent(new Event(\"ended\"));\n        };\n      })();\n    }\n    return () => {\n      if (dispose) dispose();\n    };\n  }, [roomId, audioEnabled, audioDeviceId, addAudioTrack, removeAudioTrack]);\n  useEffect(() => {\n    if (faceStream) {\n      const [audioTrack] = faceStream.getAudioTracks();\n      if (audioTrack) {\n        audioTrack.enabled = micOn;\n      }\n    }\n  }, [faceStream, micOn]);\n\n  return { faceStream, faceStreamMap };\n};\n","import React from \"react\";\n\nimport \"./FaceImages.css\";\nimport { useFaceImages } from \"../hooks/useFaceImages\";\nimport { useFaceVideos } from \"../hooks/useFaceVideos\";\n\nconst BLANK_IMAGE =\n  \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQI12NgYAAAAAMAASDVlMcAAAAASUVORK5CYII=\";\n\nconst FaceImage = React.memo<{\n  image?: string;\n  nickname: string;\n  statusMesg: string;\n  obsoleted?: boolean;\n  liveMode?: boolean;\n  stream?: MediaStream;\n  speakerOn?: boolean;\n}>(\n  ({ image, nickname, statusMesg, obsoleted, liveMode, stream, speakerOn }) => (\n    <div className=\"FaceImages-card\" style={{ opacity: obsoleted ? 0.2 : 1 }}>\n      {liveMode && !obsoleted && stream ? (\n        <video\n          className=\"FaceImages-photo\"\n          ref={(videoEle) => {\n            if (videoEle && videoEle.srcObject !== stream) {\n              // eslint-disable-next-line no-param-reassign\n              videoEle.srcObject = stream;\n            }\n          }}\n          autoPlay\n          muted={!speakerOn}\n        />\n      ) : (\n        <img\n          src={image || BLANK_IMAGE}\n          className=\"FaceImages-photo\"\n          alt=\"myself\"\n        />\n      )}\n      <div className=\"FaceImages-name\">{nickname}</div>\n      <div className=\"FaceImages-mesg\">{statusMesg}</div>\n      {liveMode && !obsoleted && stream && (\n        <div className=\"FaceImages-live-indicator\" title=\"Live Mode On\">\n          &#9673;\n        </div>\n      )}\n      {liveMode && !obsoleted && !stream && (\n        <div className=\"FaceImages-live-indicator\" title=\"Live Mode Available\">\n          &#9678;\n        </div>\n      )}\n    </div>\n  )\n);\n\nexport const FaceImages = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n  statusMesg: string;\n  liveMode: boolean;\n  micOn: boolean;\n  speakerOn: boolean;\n  videoDeviceId?: string;\n  audioDeviceId?: string;\n}>(\n  ({\n    roomId,\n    userId,\n    nickname,\n    statusMesg,\n    liveMode,\n    micOn,\n    speakerOn,\n    videoDeviceId,\n    audioDeviceId,\n  }) => {\n    const { myImage, roomImages } = useFaceImages(\n      roomId,\n      userId,\n      nickname,\n      statusMesg,\n      liveMode,\n      videoDeviceId\n    );\n    const { faceStream, faceStreamMap } = useFaceVideos(\n      roomId,\n      userId,\n      liveMode,\n      liveMode,\n      micOn,\n      videoDeviceId,\n      audioDeviceId\n    );\n\n    return (\n      <div className=\"FaceImage-container\">\n        <FaceImage\n          image={myImage}\n          nickname={nickname}\n          statusMesg={statusMesg}\n          liveMode={liveMode}\n          stream={faceStream || undefined}\n        />\n        {roomImages.map((item) => (\n          <FaceImage\n            key={item.userId}\n            image={item.image}\n            nickname={item.info.nickname}\n            statusMesg={item.info.message}\n            obsoleted={item.obsoleted}\n            liveMode={item.info.liveMode}\n            stream={(liveMode && faceStreamMap[item.userId]) || undefined}\n            speakerOn={speakerOn}\n          />\n        ))}\n      </div>\n    );\n  }\n);\n","import { useState, useCallback, useRef } from \"react\";\n\nimport { isObject } from \"../utils/types\";\nimport { useRoomData, useBroadcastData } from \"./useRoom\";\n\nconst MAX_CHAT_LIST_SIZE = 100;\n\ntype ChatData = {\n  userId: string;\n  nickname: string;\n  chatSeq: number;\n  chatText: string;\n  chatInReplyTo?: {\n    userId: string;\n    chatSeq: number;\n  };\n};\n\nconst isChatData = (x: unknown): x is ChatData =>\n  isObject(x) &&\n  typeof (x as { userId: unknown }).userId === \"string\" &&\n  typeof (x as { nickname: unknown }).nickname === \"string\" &&\n  typeof (x as { chatSeq: unknown }).chatSeq === \"number\" &&\n  typeof (x as { chatText: unknown }).chatText === \"string\" &&\n  (typeof (x as { chatInReplyTo: unknown }).chatInReplyTo === \"undefined\" ||\n    typeof (x as { chatInReplyTo: { userId: unknown } }).chatInReplyTo\n      .userId === \"string\" ||\n    typeof (x as { chatInReplyTo: { chatSeq: unknown } }).chatInReplyTo\n      .chatSeq === \"number\");\n\ntype Reply = [string, number];\n\nexport type ChatItem = {\n  key: string;\n  replyTo: { userId: string; chatSeq: number };\n  nickname: string;\n  text: string;\n  replies: Reply[];\n  time: string;\n};\n\nconst compareReply = (a: Reply, b: Reply) => {\n  const countDiff = b[1] - a[1];\n  if (countDiff === 0) {\n    return a[0].length - b[0].length;\n  }\n  return countDiff;\n};\n\nexport const useMomentaryChat = (\n  roomId: string,\n  userId: string,\n  nickname: string\n) => {\n  const chatSeqRef = useRef(1);\n  const receivedSeqMap = useRef(new Map<string, number>());\n  const [chatList, setChatList] = useState<ChatItem[]>([]);\n\n  const addChatItem = useCallback((chatData: ChatData) => {\n    if ((receivedSeqMap.current.get(chatData.userId) || 0) < chatData.chatSeq) {\n      receivedSeqMap.current.set(chatData.userId, chatData.chatSeq);\n    } else {\n      return;\n    }\n    if (chatData.chatInReplyTo) {\n      const { chatText, chatInReplyTo } = chatData;\n      setChatList((prev) =>\n        prev.map((item) => {\n          if (\n            item.replyTo.userId === chatInReplyTo.userId &&\n            item.replyTo.chatSeq === chatInReplyTo.chatSeq\n          ) {\n            const replyMap = new Map(item.replies);\n            replyMap.set(chatText, (replyMap.get(chatText) || 0) + 1);\n            const replies = [...replyMap.entries()];\n            replies.sort(compareReply);\n            return { ...item, replies };\n          }\n          return item;\n        })\n      );\n    } else {\n      const time = new Date();\n      const chatItem: ChatItem = {\n        key: `${chatData.userId}_${chatData.chatSeq}`,\n        replyTo: {\n          userId: chatData.userId,\n          chatSeq: chatData.chatSeq,\n        },\n        nickname: chatData.nickname,\n        text: chatData.chatText,\n        replies: [],\n        time: time.toLocaleString().split(\" \")[1].slice(0, -3),\n      };\n      setChatList((prev) => [chatItem, ...prev].slice(0, MAX_CHAT_LIST_SIZE));\n    }\n  }, []);\n\n  const broadcastData = useBroadcastData(roomId, userId);\n  useRoomData(\n    roomId,\n    userId,\n    useCallback(\n      (data) => {\n        if (!isChatData(data)) return;\n        addChatItem(data);\n      },\n      [addChatItem]\n    )\n  );\n\n  const sendChat = useCallback(\n    (text: string) => {\n      const data: ChatData = {\n        userId,\n        nickname,\n        chatSeq: chatSeqRef.current,\n        chatText: text,\n      };\n      chatSeqRef.current += 1;\n      broadcastData(data);\n      addChatItem(data);\n    },\n    [broadcastData, userId, nickname, addChatItem]\n  );\n\n  const replyChat = useCallback(\n    (text: string, inReplyTo: { userId: string; chatSeq: number }) => {\n      const data: ChatData = {\n        userId,\n        nickname,\n        chatSeq: chatSeqRef.current,\n        chatText: text,\n        chatInReplyTo: inReplyTo,\n      };\n      chatSeqRef.current += 1;\n      broadcastData(data);\n      addChatItem(data);\n    },\n    [broadcastData, userId, nickname, addChatItem]\n  );\n\n  return {\n    chatList,\n    sendChat,\n    replyChat,\n  };\n};\n","import React from \"react\";\nimport \"emoji-mart/css/emoji-mart.css\";\nimport { BaseEmoji, Picker } from \"emoji-mart\";\n\nexport { Emoji } from \"emoji-mart\";\nexport type EmojiDataType = BaseEmoji;\n\n// we do not support custom emojis\nexport const EmojiPicker = Picker as React.ComponentType<\n  | Omit<React.ComponentProps<typeof Picker>, \"custom\" | \"onSelect\">\n  | {\n      onSelect: (emoji: BaseEmoji) => void;\n    }\n>;\n","import React, { useState, useRef, useLayoutEffect } from \"react\";\n\nimport \"./MomentaryChat.css\";\nimport { useMomentaryChat, ChatItem } from \"../hooks/useMomentaryChat\";\nimport { EmojiPicker } from \"../utils/emoji\";\n\ntype ChatList = ReturnType<typeof useMomentaryChat>[\"chatList\"];\ntype ReplyChat = ReturnType<typeof useMomentaryChat>[\"replyChat\"];\n\nconst MomentaryChatContentPart = React.memo<{\n  item: ChatItem;\n  replyChat: ReplyChat;\n}>(({ item, replyChat }) => {\n  const [openEmojiPicker, setOpenEmojiPicker] = useState(false);\n  const reply = (text: string) => replyChat(text, item.replyTo);\n  return (\n    <li key={item.key} className=\"MomentaryChat-listPart\">\n      {openEmojiPicker && (\n        <EmojiPicker\n          onSelect={(e) => {\n            reply(e.native);\n            setOpenEmojiPicker(false);\n          }}\n        />\n      )}\n      <div className=\"MomentaryChat-listPart-header\">\n        <div className=\"MomentaryChat-iconButton-container\">\n          <div className=\"MomentaryChat-iconButton\">\n            <button\n              type=\"button\"\n              onClick={() => {\n                setOpenEmojiPicker(!openEmojiPicker);\n              }}\n            >\n              +\n            </button>\n          </div>\n        </div>\n        <span className=\"MomentaryChat-nickname\">\n          {item.nickname || \"No Name\"}\n        </span>\n        <span className=\"MomentaryChat-time\">{item.time}</span>\n      </div>\n      <div>{item.text}</div>\n      {item.replies.map(([text, count]) => (\n        <button\n          key={text}\n          className=\"MomentaryChat-icon\"\n          type=\"button\"\n          onClick={() => reply(text)}\n        >\n          {text} {count}\n        </button>\n      ))}\n    </li>\n  );\n});\n\nconst MomentaryChatContent = React.memo<{\n  chatList: ChatList;\n  replyChat: ReplyChat;\n  onUpdateLayout: (height: number) => void;\n}>(({ chatList, replyChat, onUpdateLayout }) => {\n  const chatListRef = useRef<HTMLUListElement | null>(null);\n  useLayoutEffect(() => {\n    if (chatListRef.current) {\n      onUpdateLayout(chatListRef.current.scrollHeight);\n    }\n  });\n\n  return (\n    <ul className=\"MomentaryChat-list\" ref={chatListRef}>\n      {chatList.map((item) => (\n        <MomentaryChatContentPart\n          key={item.key}\n          item={item}\n          replyChat={replyChat}\n        />\n      ))}\n    </ul>\n  );\n});\n\nexport const MomentaryChat = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n}>(({ roomId, userId, nickname }) => {\n  const containerRef = useRef<HTMLDivElement | null>(null);\n  const { chatList, sendChat, replyChat } = useMomentaryChat(\n    roomId,\n    userId,\n    nickname\n  );\n\n  const [text, setText] = useState(\"\");\n  const onSubmit = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    if (text) {\n      sendChat(text);\n      setText(\"\");\n    }\n  };\n\n  return (\n    <div className=\"MomentaryChat-container\" ref={containerRef}>\n      <MomentaryChatContent\n        chatList={chatList}\n        replyChat={replyChat}\n        onUpdateLayout={(height: number) => {\n          if (containerRef.current) {\n            containerRef.current.scrollTop = height;\n          }\n        }}\n      />\n      <form onSubmit={onSubmit}>\n        <div className=\"MomentaryChat-message-input-area\">\n          <input\n            value={text}\n            onChange={(e) => setText(e.target.value)}\n            placeholder=\"Enter chat message\"\n          />\n          <button type=\"submit\" disabled={!text}>\n            Send\n          </button>\n        </div>\n      </form>\n    </div>\n  );\n});\n","export const getScreenStream = async () => {\n  try {\n    const constraints = { video: true };\n    const stream = (await (navigator.mediaDevices as any).getDisplayMedia(\n      constraints\n    )) as MediaStream;\n    const [track] = stream.getVideoTracks();\n    const dispose = () => {\n      track.stop();\n    };\n    return {\n      stream,\n      dispose,\n    };\n  } catch (e) {\n    return null;\n  }\n};\n","import { useCallback, useEffect, useState, useRef } from \"react\";\n\nimport { isVideoTrackFaceSize } from \"../media/video\";\nimport { getScreenStream } from \"../media/screen\";\nimport { useRoomMedia } from \"./useRoom\";\n\nconst isScreenTrack = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") return false;\n  const isFaceSize = await isVideoTrackFaceSize(track);\n  return !isFaceSize;\n};\n\nexport const useScreenShare = (\n  roomId: string,\n  userId: string,\n  enabled: boolean,\n  setEnabled: (enabled: boolean) => void\n) => {\n  const [screenStream, setScreenStream] = useState<MediaStream | null>(null);\n  const [screenStreamMap, setScreenStreamMap] = useState<{\n    [userId: string]: MediaStream | null;\n  }>({});\n\n  type CleanupFn = () => void;\n  const cleanupFns = useRef<CleanupFn[]>([]);\n  useEffect(() => {\n    const cleanup = () => {\n      cleanupFns.current.forEach((fn) => fn());\n    };\n    return cleanup;\n  }, []);\n\n  const onTrack = useCallback(async (track, info) => {\n    if (!(await isScreenTrack(track))) return;\n    setScreenStreamMap((prev) => ({\n      ...prev,\n      [info.userId]: new MediaStream([track]),\n    }));\n    const onended = () => {\n      setScreenStreamMap((prev) => ({\n        ...prev,\n        [info.userId]: null,\n      }));\n    };\n    track.addEventListener(\"ended\", onended);\n    cleanupFns.current.push(() => {\n      track.removeEventListener(\"ended\", onended);\n    });\n  }, []);\n\n  const { addTrack, removeTrack } = useRoomMedia(\n    roomId,\n    userId,\n    onTrack,\n    \"screenVideo\"\n  );\n\n  useEffect(() => {\n    let dispose: (() => void) | null = null;\n    if (enabled && addTrack && removeTrack) {\n      (async () => {\n        const result = await getScreenStream();\n        if (!result) {\n          setEnabled(false);\n          return;\n        }\n        const [track] = result.stream.getVideoTracks();\n        addTrack(track);\n        setScreenStream(result.stream);\n        dispose = () => {\n          removeTrack(track);\n          result.dispose();\n          setScreenStream(null);\n          setEnabled(false);\n        };\n        track.addEventListener(\"ended\", () => {\n          if (dispose) dispose();\n          dispose = null;\n        });\n      })();\n    }\n    return () => {\n      if (dispose) dispose();\n    };\n  }, [roomId, enabled, setEnabled, addTrack, removeTrack]);\n\n  return { screenStream, screenStreamMap };\n};\n","import React, { useState, useRef, useEffect } from \"react\";\n\nimport \"./ScreenShare.css\";\nimport { useScreenShare } from \"../hooks/useScreenShare\";\nimport { useNicknameMap } from \"../hooks/useNicknameMap\";\n\nconst Screen = React.memo<{\n  nickname: string;\n  stream: MediaStream;\n}>(({ nickname, stream }) => {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  useEffect(() => {\n    if (stream && videoRef.current) {\n      videoRef.current.srcObject = stream;\n    }\n  }, [stream]);\n  return (\n    <div>\n      <div className=\"ScreenShare-nickname\">{nickname}</div>\n      <video className=\"ScreenShare-video\" ref={videoRef} autoPlay muted />\n    </div>\n  );\n});\n\nexport const ScreenShare = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n}>(({ roomId, userId, nickname }) => {\n  const [enabled, setEnabled] = useState(false);\n  const { screenStream, screenStreamMap } = useScreenShare(\n    roomId,\n    userId,\n    enabled,\n    setEnabled\n  );\n  const nicknameMap = useNicknameMap(roomId, userId);\n\n  return (\n    <div className=\"ScreenShare-container\">\n      <button type=\"button\" onClick={() => setEnabled(!enabled)}>\n        {enabled ? \"Stop screen share\" : \"Start screen share\"}\n      </button>\n      {screenStream && <Screen nickname={nickname} stream={screenStream} />}\n      {Object.keys(screenStreamMap).map((screenUserId) => {\n        const stream = screenStreamMap[screenUserId];\n        if (!stream) return null;\n        return (\n          <Screen\n            key={screenUserId}\n            nickname={nicknameMap[screenUserId] || \"No Name\"}\n            stream={stream}\n          />\n        );\n      })}\n    </div>\n  );\n});\n","import { useCallback, useEffect, useState, useRef } from \"react\";\n\nimport { getVideoStream, isVideoTrackFaceSize } from \"../media/video\";\nimport { useRoomMedia } from \"./useRoom\";\n\nconst isVideoTrack = async (track: MediaStreamTrack) => {\n  if (track.kind !== \"video\") return false;\n  const isFaceSize = await isVideoTrackFaceSize(track);\n  return !isFaceSize;\n};\n\nexport const useVideoShare = (\n  roomId: string,\n  userId: string,\n  enabled: boolean,\n  setEnabled: (enabled: boolean) => void,\n  videoDeviceId?: string\n) => {\n  const [videoStream, setVideoStream] = useState<MediaStream | null>(null);\n  const [videoStreamMap, setVideoStreamMap] = useState<{\n    [userId: string]: MediaStream | null;\n  }>({});\n\n  type CleanupFn = () => void;\n  const cleanupFns = useRef<CleanupFn[]>([]);\n  useEffect(() => {\n    const cleanup = () => {\n      cleanupFns.current.forEach((fn) => fn());\n    };\n    return cleanup;\n  }, []);\n\n  const onTrack = useCallback(async (track, info) => {\n    if (!(await isVideoTrack(track))) return;\n    setVideoStreamMap((prev) => ({\n      ...prev,\n      [info.userId]: new MediaStream([track]),\n    }));\n    const onended = () => {\n      setVideoStreamMap((prev) => ({\n        ...prev,\n        [info.userId]: null,\n      }));\n    };\n    track.addEventListener(\"ended\", onended);\n    cleanupFns.current.push(() => {\n      track.removeEventListener(\"ended\", onended);\n    });\n  }, []);\n\n  const { addTrack, removeTrack } = useRoomMedia(\n    roomId,\n    userId,\n    onTrack,\n    \"cameraVideo\"\n  );\n\n  useEffect(() => {\n    let dispose: (() => void) | null = null;\n    if (enabled && addTrack && removeTrack) {\n      (async () => {\n        const result = await getVideoStream(videoDeviceId);\n        const [track] = result.stream.getVideoTracks();\n        addTrack(track);\n        setVideoStream(result.stream);\n        dispose = () => {\n          removeTrack(track);\n          result.dispose();\n          setVideoStream(null);\n          setEnabled(false);\n        };\n        track.addEventListener(\"ended\", () => {\n          if (dispose) dispose();\n          dispose = null;\n        });\n      })();\n    }\n    return () => {\n      if (dispose) dispose();\n    };\n  }, [roomId, videoDeviceId, enabled, setEnabled, addTrack, removeTrack]);\n\n  return { videoStream, videoStreamMap };\n};\n","import React, { useState, useRef, useEffect } from \"react\";\n\nimport \"./VideoShare.css\";\nimport { useVideoShare } from \"../hooks/useVideoShare\";\nimport { useVideoDevices } from \"../hooks/useAvailableDevices\";\nimport { useNicknameMap } from \"../hooks/useNicknameMap\";\n\nconst Video = React.memo<{\n  nickname: string;\n  stream: MediaStream;\n}>(({ nickname, stream }) => {\n  const videoRef = useRef<HTMLVideoElement>(null);\n  useEffect(() => {\n    if (stream && videoRef.current) {\n      videoRef.current.srcObject = stream;\n    }\n  }, [stream]);\n  return (\n    <div>\n      <div className=\"VideoShare-nickname\">{nickname}</div>\n      <video className=\"VideoShare-video\" ref={videoRef} autoPlay muted />\n    </div>\n  );\n});\n\nexport const VideoShare = React.memo<{\n  roomId: string;\n  userId: string;\n  nickname: string;\n}>(({ roomId, userId, nickname }) => {\n  const videoDevices = useVideoDevices();\n  const [videoDeviceId, setVideoDeviceId] = useState<string>();\n  const [enabled, setEnabled] = useState(false);\n  const { videoStream, videoStreamMap } = useVideoShare(\n    roomId,\n    userId,\n    enabled,\n    setEnabled,\n    videoDeviceId\n  );\n  const nicknameMap = useNicknameMap(roomId, userId);\n  const numOfVideos =\n    (videoStream ? 1 : 0) +\n    Object.values(videoStreamMap).filter((x) => x).length;\n\n  return (\n    <div className=\"VideoShare-container\">\n      <div>\n        Select Camera:{\" \"}\n        <select\n          value={videoDeviceId}\n          onChange={(e) => setVideoDeviceId(e.target.value)}\n        >\n          {videoDevices.map((videoDevice) => (\n            <option key={videoDevice.deviceId} value={videoDevice.deviceId}>\n              {videoDevice.label}\n            </option>\n          ))}\n        </select>\n      </div>\n      <button type=\"button\" onClick={() => setEnabled(!enabled)}>\n        {enabled ? \"Stop video share\" : \"Start video share\"}\n      </button>\n      <div\n        className=\"VideoShare-body\"\n        style={{\n          gridTemplateColumns: `repeat(${Math.ceil(\n            Math.sqrt(numOfVideos)\n          )}, 1fr)`,\n        }}\n      >\n        {videoStream && <Video nickname={nickname} stream={videoStream} />}\n        {Object.keys(videoStreamMap).map((screenUserId) => {\n          const stream = videoStreamMap[screenUserId];\n          if (!stream) return null;\n          return (\n            <Video\n              key={screenUserId}\n              nickname={nicknameMap[screenUserId] || \"No Name\"}\n              stream={stream}\n            />\n          );\n        })}\n      </div>\n    </div>\n  );\n});\n","import { ROOM_ID_PREFIX_LEN } from \"../network/peerUtils\";\nimport { importCryptoKey } from \"./crypto\";\n\nexport const generateExcalidrawURL = async (roomId: string) => {\n  const id = roomId.slice(0, 20);\n  const imported = await importCryptoKey(roomId.slice(ROOM_ID_PREFIX_LEN), [\n    \"encrypt\",\n    \"decrypt\",\n  ]);\n  const key = (await window.crypto.subtle.exportKey(\"jwk\", imported)).k;\n  return `https://excalidraw.com/#room=${id},${key}`;\n};\n","import React, { useEffect, useState } from \"react\";\n\nimport \"./CollabWhiteBoard.css\";\nimport { generateExcalidrawURL } from \"../utils/excalidraw\";\n\nexport const CollabWhiteBoard = React.memo<{\n  roomId: string;\n}>(({ roomId }) => {\n  const [url, setUrl] = useState<string>();\n  useEffect(() => {\n    (async () => {\n      const excalidrawUrl = await generateExcalidrawURL(roomId);\n      setUrl(excalidrawUrl);\n    })();\n  }, [roomId]);\n  return (\n    <div className=\"CollabWhiteBoard-container\">\n      {url && <iframe title=\"Excalidraw\" src={url} />}\n    </div>\n  );\n});\n","import React, { useState } from \"react\";\n\nimport \"./UserProfile.css\";\nimport { Emoji, EmojiPicker, EmojiDataType } from \"../utils/emoji\";\n\nconst TextField = React.memo<{\n  initialText: string;\n  onUpdate: (text: string) => void;\n  buttonLabel?: string;\n  placeholder?: string;\n  clearOnUpdate?: boolean;\n}>(({ initialText, onUpdate, buttonLabel, placeholder, clearOnUpdate }) => {\n  const [text, setText] = useState(initialText);\n  const onSubmit = (event: React.FormEvent<HTMLFormElement>) => {\n    event.preventDefault();\n    if (text) {\n      onUpdate(text);\n      if (clearOnUpdate) {\n        setText(\"\");\n      }\n    }\n  };\n\n  return (\n    <form onSubmit={onSubmit}>\n      <input\n        value={text}\n        onChange={(e) => setText(e.target.value)}\n        placeholder={placeholder}\n      />\n      {buttonLabel && (\n        <button type=\"submit\" disabled={!text}>\n          {buttonLabel}\n        </button>\n      )}\n    </form>\n  );\n});\n\nexport const UserProfile = React.memo<{\n  initialNickname: string;\n  emoji: EmojiDataType | null;\n  onUpdateNickname: (e: string) => void;\n  onUpdateStatusMesg: (e: string) => void;\n  onUpdateEmoji: (e: EmojiDataType | null) => void;\n}>(\n  ({\n    initialNickname,\n    emoji,\n    onUpdateNickname,\n    onUpdateStatusMesg,\n    onUpdateEmoji,\n  }) => {\n    const [openEmojiPicker, setOpenEmojiPicker] = useState(false);\n    return (\n      <div className=\"UserProfile-container\">\n        <div className=\"UserProfile-nickname\">\n          <TextField\n            initialText={initialNickname}\n            onUpdate={onUpdateNickname}\n            placeholder=\"Enter your name\"\n            buttonLabel=\"Set\"\n          />\n        </div>\n        <div className=\"UserProfile-status-area\">\n          <div className=\"UserProfile-emoji\">\n            <button\n              type=\"button\"\n              onClick={() => {\n                setOpenEmojiPicker(!openEmojiPicker);\n              }}\n            >\n              {emoji ? <Emoji emoji={emoji} size={10} /> : \":)\"}\n            </button>\n          </div>\n          <div className=\"UserProfile-statusmesg\">\n            <TextField\n              initialText=\"\"\n              onUpdate={onUpdateStatusMesg}\n              placeholder=\"Enter status message\"\n              buttonLabel=\"Set\"\n            />\n          </div>\n          <button\n            type=\"button\"\n            onClick={() => {\n              onUpdateEmoji(null);\n              onUpdateStatusMesg(\"\");\n              setOpenEmojiPicker(false);\n            }}\n          >\n            Clear\n          </button>\n        </div>\n        {openEmojiPicker && (\n          <EmojiPicker\n            onSelect={(e) => {\n              onUpdateEmoji(e);\n              setOpenEmojiPicker(false);\n            }}\n          />\n        )}\n      </div>\n    );\n  }\n);\n","import React, { useEffect, useState } from \"react\";\n\nimport \"./SingleRoom.css\";\nimport { setRoomIdToUrl } from \"../utils/url\";\nimport { setStringItem, getStringItem } from \"../utils/storage\";\nimport { useRoomNetworkStatus } from \"../hooks/useRoom\";\nimport { useNicknameMap } from \"../hooks/useNicknameMap\";\nimport { useVideoDevices, useAudioDevices } from \"../hooks/useAvailableDevices\";\nimport { FaceImages } from \"./FaceImages\";\nimport { MomentaryChat } from \"./MomentaryChat\";\nimport { ScreenShare } from \"./ScreenShare\";\nimport { VideoShare } from \"./VideoShare\";\nimport { CollabWhiteBoard } from \"./CollabWhiteBoard\";\nimport { UserProfile } from \"./UserProfile\";\nimport { EmojiDataType } from \"../utils/emoji\";\n\nconst initialNickname = getStringItem(\"nickname\");\nconst initialConfigOpen = getStringItem(\"config_hidden\") !== \"true\";\nconst initialVideoDeviceId = getStringItem(\"faceimage_video_device_id\");\nconst initialAudioDeviceId = getStringItem(\"faceimage_audio_device_id\");\n\nexport const SingleRoom = React.memo<{\n  roomId: string;\n  userId: string;\n}>(({ roomId, userId }) => {\n  const [nickname, setNickname] = useState(initialNickname);\n  const [statusMesg, setStatusMesg] = useState(\"\");\n  const [emoji, setEmoji] = useState<EmojiDataType | null>(null);\n  useEffect(() => {\n    setRoomIdToUrl(roomId);\n  }, [roomId]);\n\n  const videoDevices = useVideoDevices();\n  const audioDevices = useAudioDevices();\n  const [videoDeviceId, setVideoDeviceId] = useState(initialVideoDeviceId);\n  const [audioDeviceId, setAudioDeviceId] = useState(initialAudioDeviceId);\n  const [liveMode, setLiveMode] = useState(false);\n  const [micOn, setMicOn] = useState(false);\n  const [speakerOn, setSpeakerOn] = useState(false);\n  const [screenShareMode, setScreenShareMode] = useState(false);\n  const [videoShareMode, setVideoShareMode] = useState(false);\n  const [collabWBOpen, setCollabWBOpen] = useState(false);\n\n  const [configOpen, setConfigOpen] = useState(initialConfigOpen);\n  useEffect(() => {\n    setStringItem(\"config_hidden\", configOpen ? \"false\" : \"true\");\n  }, [configOpen]);\n\n  const networkStatus = useRoomNetworkStatus(roomId, userId);\n  useNicknameMap(roomId, userId); // to enable caching\n\n  const appLink = `remote-faces://${window.location.href.replace(\n    /^https:\\/\\//,\n    \"\"\n  )}`;\n\n  return (\n    <>\n      <div className=\"SingleRoom-body\">\n        <FaceImages\n          roomId={roomId}\n          userId={userId}\n          videoDeviceId={videoDeviceId}\n          audioDeviceId={audioDeviceId}\n          nickname={nickname}\n          statusMesg={`${emoji?.native || \"\"}${statusMesg}`}\n          liveMode={liveMode}\n          micOn={micOn}\n          speakerOn={speakerOn}\n        />\n        <div className=\"SingleRoom-2nd-column\">\n          <UserProfile\n            initialNickname={initialNickname}\n            emoji={emoji}\n            onUpdateNickname={(text) => {\n              setNickname(text);\n              setStringItem(\"nickname\", text);\n            }}\n            onUpdateStatusMesg={(text) => {\n              setStatusMesg(text);\n            }}\n            onUpdateEmoji={(e) => {\n              setEmoji(e);\n            }}\n          />\n          <div>\n            <button\n              type=\"button\"\n              className=\"SingleRoom-config-toggle\"\n              onClick={() => setConfigOpen((o) => !o)}\n            >\n              Setting{configOpen ? <>&#9660;</> : <>&#9654;</>}\n            </button>\n            {configOpen && (\n              <div className=\"SingleRoom-config\">\n                <div>\n                  Link to this room:\n                  <input value={window.location.href} readOnly />\n                  (Share this link with your colleagues)\n                  <a href={appLink}>Open App</a>\n                </div>\n                <div>\n                  Select Camera:{\" \"}\n                  <select\n                    value={videoDeviceId}\n                    onChange={(e) => {\n                      setVideoDeviceId(e.target.value);\n                      setStringItem(\n                        \"faceimage_video_device_id\",\n                        e.target.value\n                      );\n                    }}\n                  >\n                    {videoDevices.map((videoDevice) => (\n                      <option\n                        key={videoDevice.deviceId}\n                        value={videoDevice.deviceId}\n                      >\n                        {videoDevice.label}\n                      </option>\n                    ))}\n                  </select>\n                </div>\n                <div>\n                  Select Mic:{\" \"}\n                  <select\n                    value={audioDeviceId}\n                    onChange={(e) => {\n                      setAudioDeviceId(e.target.value);\n                      setStringItem(\n                        \"faceimage_audio_device_id\",\n                        e.target.value\n                      );\n                    }}\n                  >\n                    {audioDevices.map((audioDevice) => (\n                      <option\n                        key={audioDevice.deviceId}\n                        value={audioDevice.deviceId}\n                      >\n                        {audioDevice.label}\n                      </option>\n                    ))}\n                  </select>\n                </div>\n                <div>\n                  Live Mode:{\" \"}\n                  <button type=\"button\" onClick={() => setLiveMode((x) => !x)}>\n                    {liveMode ? \"Disable\" : \"Enable\"}\n                  </button>\n                  {liveMode && <>&#10004;</>}\n                  {liveMode && (\n                    <div>\n                      <label>\n                        <input\n                          type=\"checkbox\"\n                          checked={micOn}\n                          onChange={(e) => setMicOn(e.target.checked)}\n                        />\n                        Mic On\n                      </label>\n                      <label>\n                        <input\n                          type=\"checkbox\"\n                          checked={speakerOn}\n                          onChange={(e) => setSpeakerOn(e.target.checked)}\n                        />\n                        Speaker On\n                      </label>\n                    </div>\n                  )}\n                </div>\n                <div>\n                  Screen Share:{\" \"}\n                  <button\n                    type=\"button\"\n                    onClick={() => setScreenShareMode((x) => !x)}\n                  >\n                    {screenShareMode ? \"Close\" : \"Open\"}\n                  </button>\n                  {screenShareMode && <>&#10004;</>}\n                </div>\n                <div>\n                  Video Share:{\" \"}\n                  <button\n                    type=\"button\"\n                    onClick={() => setVideoShareMode((x) => !x)}\n                  >\n                    {videoShareMode ? \"Close\" : \"Open\"}\n                  </button>\n                  {videoShareMode && <>&#10004;</>}\n                </div>\n                <div>\n                  Collab White Board:{\" \"}\n                  <button\n                    type=\"button\"\n                    onClick={() => setCollabWBOpen((x) => !x)}\n                  >\n                    {collabWBOpen ? \"Close\" : \"Open\"}\n                  </button>\n                  {collabWBOpen && <>&#10004;</>}\n                </div>\n                <div className=\"SingleRoom-status\">\n                  {JSON.stringify(networkStatus)}\n                </div>\n              </div>\n            )}\n          </div>\n          <MomentaryChat roomId={roomId} userId={userId} nickname={nickname} />\n        </div>\n        <div className=\"SingleRoom-3rd-column\">\n          {screenShareMode && (\n            <ScreenShare roomId={roomId} userId={userId} nickname={nickname} />\n          )}\n          {videoShareMode && (\n            <VideoShare roomId={roomId} userId={userId} nickname={nickname} />\n          )}\n          {collabWBOpen && <CollabWhiteBoard roomId={roomId} />}\n        </div>\n      </div>\n    </>\n  );\n});\n","import React, { useState } from \"react\";\n\nimport \"./SingleRoomEntrance.css\";\nimport { secureRandomId, generateCryptoKey } from \"../utils/crypto\";\nimport { ROOM_ID_PREFIX_LEN } from \"../network/peerUtils\";\nimport { getRoomIdFromUrl, extractRoomIdFromLink } from \"../utils/url\";\nimport { SingleRoom } from \"./SingleRoom\";\n\nconst roomIdFromUrl = getRoomIdFromUrl();\nconst userId = secureRandomId();\n\nexport const SingleRoomEntrance = React.memo(() => {\n  const [roomId, setRoomId] = useState<string | null>(roomIdFromUrl);\n  const [linkText, setLinkText] = useState(\"\");\n\n  const onCreateNew = async () => {\n    setRoomId(\n      secureRandomId(ROOM_ID_PREFIX_LEN / 2) + (await generateCryptoKey())\n    );\n  };\n\n  const onEnter = () => {\n    setRoomId(extractRoomIdFromLink(linkText));\n  };\n\n  if (roomId) {\n    return <SingleRoom roomId={roomId} userId={userId} />;\n  }\n\n  return (\n    <div className=\"SingleRoomEntrance-init\">\n      <button type=\"button\" onClick={onCreateNew}>\n        Create a new room\n      </button>\n      OR\n      <input\n        value={linkText}\n        onChange={(e) => setLinkText(e.target.value)}\n        placeholder=\"Enter room link...\"\n      />\n      <button\n        type=\"button\"\n        onClick={onEnter}\n        disabled={!extractRoomIdFromLink(linkText)}\n      >\n        Enter room\n      </button>\n    </div>\n  );\n});\n","import React from \"react\";\n\nimport { ErrorFallback } from \"./ErrorFallback\";\nimport { SingleRoomEntrance } from \"./SingleRoomEntrance\";\nimport \"./App.css\";\n\nclass ErrorBoundary extends React.PureComponent {\n  state: { err?: Error } = {};\n\n  static getDerivedStateFromError(err: Error) {\n    return { err };\n  }\n\n  render() {\n    const { children } = this.props;\n    const { err } = this.state;\n    if (err) return <ErrorFallback err={err} />;\n    return children;\n  }\n}\n\nexport const App = React.memo(() => (\n  <div className=\"App\">\n    <ErrorBoundary>\n      <SingleRoomEntrance />\n    </ErrorBoundary>\n  </div>\n));\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { \"Service-Worker\": \"script\" },\n  })\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready\n      .then((registration) => {\n        registration.unregister();\n      })\n      .catch((error) => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport { App } from \"./components/App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}